(ns cleo.core.test)


(def tests (atom {}))
(def current-test (atom nil))
(def failed-tests (atom #{}))


(def {:macro :true} deftest
  (fn* deftest [&form &env name & body]
    `(swap! tests assoc* '~name (fn* [] (do ~@body)))))


(def fail
  (fn* [& msg]
    (do
      (swap! failed-tests conj* @current-test)
      (println @current-test (apply str msg)))))


(def {:macro :true} fail-unless
  (fn* fail-unless [&form &env conde & msg]
    `(if ~conde
       nil
       (fail ~@msg))))


(def {:macro :true} assert=
  (fn assert= [&form &env expected actual]
    `(let* [expected-val# ~expected]
       (try*
         (let* [actual-val# ~actual]
           (fail-unless (= expected-val# actual-val#)
                        "assertion failed: " ~(pr-str actual)
                        " expected to equal: " expected-val#
                        " actual: " actual-val#))
         (catch* Exception ~'e
           (fail "assertion failed: " ~(pr-str actual)
                 " expected to equal: " expected-val#
                 " actual exception: " ~'e))))))


(def {:macro :true} assert
  (fn* assert [&form &env actual]
    `(try*
       (let* [actual-val# ~actual]
         (fail-unless actual-val#
                      "assertion failed: " ~(pr-str actual)
                      " expected to be true, actual: " actual-val#))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to be true, actual exception: " ~'e)))))


(def {:macro :true} assert-not
  (fn* assert-not [&form &env actual]
    `(assert ~(list 'not actual))))


(def {:macro :true} assert-throws
  (fn* [&form &env expected actual]
    `(try*
       (try*
         (let* [actual-val# ~actual]
           (fail
            "assertion failed: " ~(pr-str actual)
            " expected to throw " ~(pr-str expected)
            " actual value: " actual-val#))
         (catch* ~expected ~'e nil))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to throw " ~(pr-str expected)
               " actual exception: " ~'e)))))


(def main
  (fn* main []
    (do
      (loop* [tests (seq @tests)]
        (if tests
          (do
            (reset! current-test ((first tests) 0))
            (((first tests) 1))
            (recur (next tests)))))
      (print "ok:" (- (count @tests) (count @failed-tests)))
      (if (< 0 (count @failed-tests))
        (print " failed:" (count @failed-tests)))
      (println)
      (if (= 0 (count @failed-tests)) 0 1))))


(deftest defmacro
  (assert= '(def {:macro :true} sonia (fn* sonia [&form &env x] (do (a) (b) (c)))) (macroexpand '(defmacro sonia [x] (a) (b) (c))))
  (assert= '(def {:macro :true} sonia (fn* sonia [&form &env x] (a))) (macroexpand '(defmacro sonia [x] (a))))
  (assert= '(def {:macro :true} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia [x]))))


(deftest let
  (assert= '(let* [a 1 b 2] (do (x) (y))) (macroexpand '(let [a 1 b 2] (x) (y))))
  (assert= '(let* [a 1 b 2] (x)) (macroexpand '(let [a 1 b 2] (x))))
  (assert= '(let* [a 1 b 2] nil) (macroexpand '(let [a 1 b 2]))))


(deftest let-destructuring
  (assert= nil ((fn* [v] (let [[] v] nil)) [:a :b :c]))
  (assert= :a ((fn* [v] (let [[x] v] x)) [:a :b :c]))
  (assert= nil ((fn* [v] (let [[x] v] x)) []))
  (assert= '(:a :b) ((fn* [v] (let [[x y] v] (list x y))) [:a :b :c]))
  (assert= '(:a :b :a :b :c) ((fn* [v] (let [[x y :as [z w u]] v] (list x y z w u))) [:a :b :c]))
  (assert= '(:a :b :c) ((fn* [v] (let [[x y z] v] (list x y z))) [:a :b :c]))
  (assert= '(:a :b :c (:a :b :c)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a :b :c]))
  (assert= '(:a nil nil (:a)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b :c]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) '(:a :b :c)))
  (assert= '(:a [:b :c] [:a :b :c]) ((fn* [v] (let [[x & y :as vn] v] (list x y vn))) '(:a :b :c)))
  (assert= '(:a [:b]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b]))
  (assert= '(:a nil) ((fn* [v] (let [[x & y] v] (list x y))) [:a]))
  (assert= '(:a :b :c nil) ((fn* [v] (let [[[x1 x2] [y1 y2]] v] (list x1 x2 y1 y2))) [[:a :b] [:c]]))
  (assert= '(:a :b :c) ((fn* [v] (let [[[x [y z]]] v] (list x y z))) [[:a [:b :c]]]))

  (assert= '() ((fn* [m] (let [{} m] [])) {:a 10 :b 20}))
  (assert= '(10) ((fn* [m] (let [{x :a} m] [x])) {:a 10 :b 20}))
  (assert= '(10 20) ((fn* [m] (let [{x :a y :b} m] [x y])) {:a 10 :b 20}))
  (assert= '(10 20 nil) ((fn* [m] (let [{x :a y :b z :c} m] [x y z])) {:a 10 :b 20}))

  (assert= '(17 20) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {:b 20}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) nil))
  (assert= '(nil 27) ((fn* [m] (let [{x :a y :b :or {y 27}} m] [x y])) {}))
  (assert= '(10 nil) ((fn* [m] (let [{x :a y :b :or nil} m] [x y])) {:a 10}))

  (assert= '(10 20 {:a 10 :b 20}) ((fn* [m] (let [{x :a y :b :as z} m] [x y z])) {:a 10 :b 20}))
  (assert= '(nil) ((fn* [m] (let [{:as z} m] [z])) nil))

  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:keys [a]} m] [a])) {:a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:keys [a b c]} m] [a b c])) {:a 10 :b 20 :c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {:a 10 :c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:syms [a]} m] [a])) {'a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:syms [a b c]} m] [a b c])) {'a 10 'b 20 'c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {'a 10 'c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:strs [a]} m] [a])) {"a" 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:strs [a b c]} m] [a b c])) {"a" 10 "b" 20 "c" 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {"a" 10 "c" 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(10 20 30 40) ((fn* [m] (let [{x :d :keys [a] :syms [b] :strs [c]} m] [a b c x])) {:a 10 'b 20 "c" 30 :d 40}))

  (assert= '(10 20 30 40) ((fn* [v] (let [[{:keys [a b]} {:syms [c d]}] v] [a b c d])) [{:a 10 :b 20} {'c 30 'd 40}]))

  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {}))
  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a []}))
  (assert= '(10 nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a [10]}))
  (assert= '(10 20) ((fn* [m] (let [{[x y] :a :or {[x y] [10 20]}} m] [x y])) {}))

  (assert= '(10 20) ((fn* [m] (let [{{:keys [b c]} :a} m] [b c])) {:a {:b 10 :c 20}}))

  (assert-throws IllegalArgument (macroexpand '(let [[x & y z] v] nil)))
  (assert-throws IllegalArgument (macroexpand '(let [10 v] nil))))


(deftest fn
  (assert= '(fn* []) (macroexpand '(fn [])))
  (assert= '(fn* [] 10) (macroexpand '(fn [] 10)))
  (assert= '(fn* [a b] (do (x) (y))) (macroexpand '(fn [a b] (x) (y))))
  (assert= '(fn* abc [a b] (do (x) (y))) (macroexpand '(fn abc [a b] (x) (y))))
  (assert= '(fn* [a b] (x)) (macroexpand '(fn [a b] (x))))
  (assert= '(fn* abc [a b] (x)) (macroexpand '(fn abc [a b] (x))))
  (assert= '(fn* [a b]) (macroexpand '(fn [a b])))
  (assert= '(fn* abc [a b]) (macroexpand '(fn abc [a b])))
  (assert= '(fn* ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* abc ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn abc ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* ([a b] (do (x) (y))) ([z])) (macroexpand '(fn ([a b] (x) (y)) ([z])))))


(deftest fn-destructuring
  (assert= [:a :b] ((fn [[x y]] [y x]) [:b :a]))
  (assert= [:a :b] ((fn [[x] [y]] [y x]) [:b] [:a]))
  (assert= [:a :b] ((fn [{:keys [x y]}] [y x]) {:x :b :y :a})))


(deftest loop
  (assert= '(loop* [a 1 b 2] (do (x) (y))) (macroexpand '(loop [a 1 b 2] (x) (y))))
  (assert= '(loop* [a 1 b 2] (x)) (macroexpand '(loop [a 1 b 2] (x))))
  (assert= '(loop* [a 1 b 2] nil) (macroexpand '(loop [a 1 b 2]))))


(deftest loop-destructuring
  (assert= [:b :a] ((fn* [v] (loop [[x y] v] [y x])) [:a :b :c]))
  (assert= :c ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b :c]))
  (assert= :b ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b nil :c]))
  (assert= [:c 7] ((fn* [v u] (loop [[v0 v1 :as allv] v [u0 u1 :as allu] u] (if v1 (recur (next allv) (next allu)) [v0 u0]))) [:a :b :c] [4 5 7]))
  (assert= [:b [5 6 7]] ((fn* [v u] (loop [[x y :as all] v u u] (if y (recur (next all) (next u)) [x u]))) [:a :b nil :c] [4 5 6 7])))


(deftest defn
  (assert= '(def abc (cleo.core/fn abc [a b] (x) (y))) (macroexpand '(defn abc [a b] (x) (y)))))


(defn df-example1 [[x y]] [y x])
(defn df-example2 [[x] [y]] [y x])
(defn df-example3 [{:keys [x y]}] [y x])


(deftest defn-destructuring
  (assert= [:a :b] (df-example1 [:b :a]))
  (assert= [:a :b] (df-example2 [:b] [:a]))
  (assert= [:a :b] (df-example3 {:x :b :y :a})))


(defmacro dm-example1 [[x y z]] (list y x z))
(defmacro dm-example2 [{:keys [op vals]}] (conj vals op))


(deftest defmacro-destructuring
  (assert= 30 (dm-example1 [10 + 20]))
  (assert= 33 (dm-example2 {:op + :vals (11 22)})))


(deftest not
  (assert= nil (not 10))
  (assert= nil (not [1]))
  (assert= :true (not nil)))


(deftest or
  (assert= nil (or))
  (assert= 10 (or 10))
  (assert= nil (or nil))
  (assert= :x (or nil :x))
  (assert= :x (or :x :y))
  (assert= nil (or nil nil))
  (assert= :x (or nil nil :x))
  (assert= :y (or nil :y :x))
  (assert= :a (or :a nil :x))
  (assert= nil (or nil nil nil)))


(deftest and
  (assert= :true (and))
  (assert= 10 (and 10))
  (assert= nil (and nil))
  (assert= nil (and nil :x))
  (assert= nil (and :x nil))
  (assert= :y (and :x :y))
  (assert= nil (and nil nil))
  (assert= nil (and nil nil :x))
  (assert= nil (and nil :y :x))
  (assert= nil (and :a nil :x))
  (assert= :d (and :a :b :c :d)))


(deftest seq?
  (assert (seq? ()))
  (assert (seq? (list 1 2)))
  (assert (not (seq? nil)))
  (assert (not (seq? [1 2])))
  (assert (seq? (seq [1 2])))
  (assert (not (seq? #{1 2})))
  (assert (not (seq? {1 2})))
  (assert (not (seq? 10))))


(deftest when
  (assert= '(if x (do)) (macroexpand '(when x)))
  (assert= '(if x (do y)) (macroexpand '(when x y)))
  (assert= '(if x (do y z)) (macroexpand '(when x y z))))


(deftest cond
  (assert= nil (macroexpand '(cond)))
  (assert= `(if (~'= 1 2) (~'= 3 4) (cond)) (macroexpand '(cond (= 1 2) (= 3 4))))
  (assert= `(if :a :b (cond :c :d)) (macroexpand '(cond :a :b :c :d)))
  (assert-throws IllegalArgument (macroexpand '(cond :a))))


(deftest bit-and
  (assert= (bit-and* 12345 54321) (bit-and 12345 54321))
  (assert= (bit-and* (bit-and* 12345 54321) 97553) (bit-and 12345 54321 97553))
  (assert= (bit-and* (bit-and* (bit-and* 12345 54321) 97553) 57753) (bit-and 12345 54321 97553 57753)))


(deftest bit-or
  (assert= (bit-or* 12345 54321) (bit-or 12345 54321))
  (assert= (bit-or* (bit-or* 12345 54321) 97553) (bit-or 12345 54321 97553))
  (assert= (bit-or* (bit-or* (bit-or* 12345 54321) 97553) 57753) (bit-or 12345 54321 97553 57753)))


(deftest bit-xor
  (assert= (bit-xor* 12345 54321) (bit-xor 12345 54321))
  (assert= (bit-xor* (bit-xor* 12345 54321) 97553) (bit-xor 12345 54321 97553))
  (assert= (bit-xor* (bit-xor* (bit-xor* 12345 54321) 97553) 57753) (bit-xor 12345 54321 97553 57753)))


(deftest bit-and-not
  (assert= (bit-and-not* 12345 54321) (bit-and-not 12345 54321))
  (assert= (bit-and-not* (bit-and-not* 12345 54321) 97553) (bit-and-not 12345 54321 97553))
  (assert= (bit-and-not* (bit-and-not* (bit-and-not* 12345 54321) 97553) 57753) (bit-and-not 12345 54321 97553 57753)))


(deftest even?
  (assert (even? 10))
  (assert-not (even? 11))
  (assert (even? -10))
  (assert-not (even? -11)))


(deftest odd?
  (assert (odd? 11))
  (assert-not (odd? 10))
  (assert (odd? -11))
  (assert-not (odd? -10)))


(deftest conj
  (assert= [] (conj))
  (assert= [10 20] (conj [10 20]))
  (assert= [10 20 30] (conj [10 20] 30))
  (assert= [10 20 30 40] (conj [10 20] 30 40))
  (assert= [10 20 30 40 50] (conj [10 20] 30 40 50))
  (assert= [10 20 nil nil] (conj [10 20] nil nil))
  (assert= nil (conj nil))
  (assert= '(20 10) (conj nil 10 20))
  (assert= '(nil) (conj nil nil)))


(deftest assoc
  (assert= {:a 1 :b 2} (assoc {:a 1} :b 2))
  (assert= {:a 1 :b 2 :c 3} (assoc {:a 1} :b 2 :c 3))
  (assert= {:a 1 :b 2 :c 3 :d 4} (assoc {:a 1} :b 2 :c 3 :d 4))
  (assert= {:a 1 :b 2} (assoc nil :a 1 :b 2))
  (assert-throws IllegalArgument (assoc {} :a 1 :b)))


(deftest dissoc
  (assert= {:a 1 :b 2} (dissoc {:a 1 :b 2}))
  (assert= {:a 1} (dissoc {:a 1 :b 2} :b))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3} :b :c))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3 :d 4} :b :c :d))
  (assert= nil (dissoc nil))
  (assert= nil (dissoc nil :a)))


(deftest every?
  (assert (every? odd? nil))
  (assert (every? odd? []))
  (assert (every? odd? [1 3 5]))
  (assert-not (every? odd? [2 3 5]))
  (assert-not (every? odd? [1 2 5]))
  (assert-not (every? odd? [1 3 2])))


(deftest some
  (let [pred (fn [x] (and (even? x) (pr-str x)))]
    (assert= nil (some pred nil))
    (assert= nil (some pred []))
    (assert= nil (some pred [1 3 5]))
    (assert= "4" (some pred [4 3 5]))
    (assert= "8" (some pred [1 8 5]))
    (assert= "10" (some pred [1 3 10]))))


(deftest if-let
  (assert= :a (if-let [x (seq [:a])] (first x)))
  (assert= nil (if-let [x (seq [])] (first x)))
  (assert= :a (if-let [x (seq [:a])] (first x) :b))
  (assert= :b (if-let [x (seq [])] (first x) :b)))


(deftest when-let
  (assert= nil (when-let [x (seq [:a])]))
  (assert= :a (when-let [x (seq [:a])] (+ 1 2) (first x)))
  (assert= nil (when-let [x (seq [])] (+ 1 2) (first x))))


(deftest partition-kv
  (assert= () (partition-kv []))
  (assert= [[nil :b]] (partition-kv [nil :b]))
  (assert= [[:a nil]] (partition-kv [:a nil]))
  (assert= [[:a :b]] (partition-kv [:a :b :c]))
  (assert= [[:a :b]] (partition-kv [:a :b nil]))
  (assert= [[:a :b] [:c :d]] (partition-kv [:a :b :c :d]))
  (assert= [[:a :b] [:c nil]] (partition-kv [:a :b :c nil]))
  (assert= [[:a :b] [:c nil]] (partition-kv [:a :b :c nil :e])))


(deftest reduce1
  (assert= 100 (reduce1 + 100 nil))
  (assert= 100 (reduce1 + 100 []))
  (assert= 110 (reduce1 + 100 [10]))
  (assert= 160 (reduce1 + 100 [10 20 30]))
  (assert= [[30 20] 10] (reduce1 list 30 [20 10])))


(deftest concati
  (assert= [] (concati))
  (assert= [:a :b] (concati [:a :b]))
  (assert= [:a :b :c :d] (concati [:a :b] [:c :d]))
  (assert= [:a :b] (concati [] '(:a :b)))
  (assert= [:a :b] (concati () [:a :b]))
  (assert= [:a :b] (concati [:a :b] []))
  (assert= [:a :b :c :d :e :f] (concati [:a :b] [:c :d] [:e :f]))
  (assert= [:a :b :c :d :e :f] (concati '(:a :b) () '(:c) [:d] '(:e :f) [])))


(deftest dotimes
  (assert= [0 1 2 3 4]
           (let [v (atom [])]
             (dotimes [i 5] (swap! v conj i))
             @v))
  (assert-not (let [called? (atom nil)]
                (dotimes [i 0] (reset! called? :true))
                @called?)))


(deftest doseq
  (assert= [:c :b :a]
           (let [l (atom ())]
             (doseq [x [:a :b :c]] (swap! l conj x))
             @l))
  (assert-not (let [called? (atom nil)]
                (doseq [x nil] (reset! called? :true))
                @called?))
  (assert-not (let [called? (atom nil)]
                (doseq [x []] (reset! called? :true))
                @called?)))


(deftest map
  (assert= () (map inc nil))
  (assert= () (map inc []))
  (assert= '(11) (map inc [10]))
  (assert= '(9 7 2) (map dec [10 8 3])))


(deftest filter
  (assert= () (filter even? nil))
  (assert= () (filter even? []))
  (assert= '(4 10) (filter even? [1 3 4 7 10]))
  (assert= () (filter zero? [1 3 4 7 10]))
  (assert= '(10) (filter even? [10]))
  (assert= () (filter odd? [10])))


(deftest ns
  (assert= '(do (cleo.core/in-ns 'some.thing) (cleo.core/refer 'cleo.core)) (macroexpand '(ns some.thing)))
  (assert= '(do (cleo.core/in-ns 'abc) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]) (cleo.core/require '[zzz] '[nnn]))
           (macroexpand '(ns abc (:require [xyz] [rst]) (:require [zzz] [nnn])))))


(deftest update
  (assert= {:abc 31 :xyz 12} (update {:abc 30 :xyz 12} :abc inc)))
