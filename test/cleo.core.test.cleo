(ns cleo.core.test)
(require 'cleo.compiler)
(alias 'cc 'cleo.compiler)
(require 'cleo.vm)
(alias 'vm 'cleo.vm)

(def slow-tests :true)
(def tests (atom {}))
(def current-test (atom nil))
(def failed-tests (atom #{}))


(def {:macro :true} deftest
  (fn* deftest [&form &env name & body]
    `(swap! tests assoc* '~name (fn* [] (do ~@body)))))


(def fail
  (fn* [& msg]
    (do
      (swap! failed-tests conj* @current-test)
      (println @current-test (apply str msg)))))


(def {:macro :true} fail-unless
  (fn* fail-unless [&form &env conde & msg]
    `(if ~conde
       nil
       (fail ~@msg))))


(def {:macro :true} assert=
  (fn assert= [&form &env expected actual]
    `(let* [expected-val# ~expected]
       (try*
         (let* [actual-val# ~actual]
           (fail-unless (= expected-val# actual-val#)
                        "assertion failed: " ~(pr-str actual)
                        " expected to equal: " (pr-str expected-val#)
                        " actual: " (pr-str actual-val#)))
         (catch* Exception ~'e
           (fail "assertion failed: " ~(pr-str actual)
                 " expected to equal: " (pr-str expected-val#)
                 " actual exception: " ~'e))))))


(def {:macro :true} assert
  (fn* assert [&form &env actual]
    `(try*
       (let* [actual-val# ~actual]
         (fail-unless actual-val#
                      "assertion failed: " ~(pr-str actual)
                      " expected to be true, actual: " (pr-str actual-val#)))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to be true, actual exception: " ~'e)))))


(def {:macro :true} assert-not
  (fn* assert-not [&form &env actual]
    `(assert ~(list 'not actual))))


(def {:macro :true} assert-throws
  (fn* [&form &env expected actual]
    `(try*
       (try*
         (let* [actual-val# ~actual]
           (fail
            "assertion failed: " ~(pr-str actual)
            " expected to throw " ~(pr-str expected)
            " actual value: " (pr-str actual-val#)))
         (catch* ~expected ~'e nil))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to throw " ~(pr-str expected)
               " actual exception: " ~'e)))))


(def {:macro :true} assert-no-exception
  (fn* [&form &env actual]
    `(try*
       ~actual
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected no exception, got: " ~'e)))))


(def {:macro :true} assert-compilation-error
  (fn* [&form &env expected actual]
    `(try*
       (try*
         (let* [actual-val# ~actual]
           (fail
            "assertion failed: " ~(pr-str actual)
            " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
            " actual value: " (pr-str actual-val#)))
         (catch* CompilationError ~'e
           (when (not (= ~expected (~'.-msg ~'e)))
             (fail "assertion failed: " ~(pr-str actual)
                   " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
                   " actual exception: " ~'e))))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
               " actual exception: " ~'e)))))

(def main
  (fn* main []
    (do
      (loop* [tests (seq @tests)]
        (if tests
          (do
            (reset! current-test ((first tests) 0))
            (((first tests) 1))
            (recur (next tests)))))
      (print "ok:" (- (count @tests) (count @failed-tests)))
      (if (< 0 (count @failed-tests))
        (print " failed:" (count @failed-tests)))
      (println)
      (if (= 0 (count @failed-tests)) 0 1))))


(deftest deftype
  (assert= '(do (def Xyz (cleo.core/type* 'Xyz '[a b c])) (cleo.core/defn ->Xyz [a b c] (cleo.core/new Xyz a b c)) Xyz) (macroexpand '(deftype Xyz [a b c]))))


(deftest defmulti
  (assert= '(def abc (cleo.core/multi* 'cleo.core.run/abc (fn* [x] x) :default)) (macroexpand '(defmulti abc (fn* [x] x))))
  (assert= '(def abc (cleo.core/multi* 'cleo.core.run/abc (fn* [x] x) 7)) (macroexpand '(defmulti abc (fn* [x] x) :default 7))))


(deftest defmethod
  (assert= '(cleo.core/defmethod* abc 10 (cleo.core/fn [x y] (x y))) (macroexpand '(defmethod abc 10 [x y] (x y))))
  (assert= '(cleo.core/defmethod* abc 10 (cleo.core/fn ([x] x) ([x y] (x y)))) (macroexpand '(defmethod abc 10 ([x] x) ([x y] (x y))))))


(deftest defmacro
  (assert= '(def {:macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x] (do (a) (b) (c)))) (macroexpand '(defmacro sonia [x] (a) (b) (c))))
  (assert= '(def {:macro :true, :arglists '([] [x] [a b])} sonia (fn* sonia ([&form &env] 1) ([&form &env x] 2) ([&form &env a b] 3))) (macroexpand '(defmacro sonia ([] 1) ([x] 2) ([a b] 3))))
  (assert= '(def {:macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x] (a))) (macroexpand '(defmacro sonia [x] (a))))
  (assert= '(def {:macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia [x])))
  (assert= '(def {:doc "some", :macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia "some" [x])))
  (assert= '(def {:const :true, :macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia {:const :true} [x])))
  (assert= '(def {:const :true, :doc "some", :macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia "some" {:const :true} [x])))
  (assert= '(def {:const :true, :doc "better", :macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia "some" {:const :true, :doc "better"} [x])))
  (assert= '(def {:macro :true, :arglists '([x])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia {:macro false} [x])))
  (assert= '(def {:macro :true, :arglists '([1 2 3])} sonia (fn* sonia [&form &env x])) (macroexpand '(defmacro sonia {:arglists '([1 2 3])} [x]))))


(deftest let
  (assert= '(let* [a 1 b 2] (do (x) (y))) (macroexpand '(let [a 1 b 2] (x) (y))))
  (assert= '(let* [a 1 b 2] (x)) (macroexpand '(let [a 1 b 2] (x))))
  (assert= '(let* [a 1 b 2] nil) (macroexpand '(let [a 1 b 2]))))


(deftest let-destructuring
  (assert= nil ((fn* [v] (let [[] v] nil)) [:a :b :c]))
  (assert= :a ((fn* [v] (let [[x] v] x)) [:a :b :c]))
  (assert= nil ((fn* [v] (let [[x] v] x)) []))
  (assert= '(:a :b) ((fn* [v] (let [[x y] v] (list x y))) [:a :b :c]))
  (assert= '(:a :b :a :b :c) ((fn* [v] (let [[x y :as [z w u]] v] (list x y z w u))) [:a :b :c]))
  (assert= '(:a :b :c) ((fn* [v] (let [[x y z] v] (list x y z))) [:a :b :c]))
  (assert= '(:a :b :c (:a :b :c)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a :b :c]))
  (assert= '(:a nil nil (:a)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b :c]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) '(:a :b :c)))
  (assert= '(:a :b :c :d) ((fn* [v] (let [[x y & [z w]] v] (list x y z w))) [:a :b :c :d]))
  (assert= '(:a :b :c :d) ((fn* [v] (let [[x y & [z w]] v] (list x y z w))) '(:a :b :c :d)))
  (assert= '(:a [:b :c] [:a :b :c]) ((fn* [v] (let [[x & y :as vn] v] (list x y vn))) '(:a :b :c)))
  (assert= '(:a [:b]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b]))
  (assert= '(:a nil) ((fn* [v] (let [[x & y] v] (list x y))) [:a]))
  (assert= '(:a :b :c nil) ((fn* [v] (let [[[x1 x2] [y1 y2]] v] (list x1 x2 y1 y2))) [[:a :b] [:c]]))
  (assert= '(:a :b :c) ((fn* [v] (let [[[x [y z]]] v] (list x y z))) [[:a [:b :c]]]))

  (assert= '() ((fn* [m] (let [{} m] [])) {:a 10 :b 20}))
  (assert= '(10) ((fn* [m] (let [{x :a} m] [x])) {:a 10 :b 20}))
  (assert= '(10 20) ((fn* [m] (let [{x :a y :b} m] [x y])) {:a 10 :b 20}))
  (assert= '(10 20 nil) ((fn* [m] (let [{x :a y :b z :c} m] [x y z])) {:a 10 :b 20}))

  (assert= '(17 20) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {:b 20}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) nil))
  (assert= '(nil 27) ((fn* [m] (let [{x :a y :b :or {y 27}} m] [x y])) {}))
  (assert= '(10 nil) ((fn* [m] (let [{x :a y :b :or nil} m] [x y])) {:a 10}))

  (assert= '(10 20 {:a 10 :b 20}) ((fn* [m] (let [{x :a y :b :as z} m] [x y z])) {:a 10 :b 20}))
  (assert= '(nil) ((fn* [m] (let [{:as z} m] [z])) nil))

  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:keys [a]} m] [a])) {:a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:keys [a b c]} m] [a b c])) {:a 10 :b 20 :c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {:a 10 :c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:syms [a]} m] [a])) {'a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:syms [a b c]} m] [a b c])) {'a 10 'b 20 'c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {'a 10 'c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:strs [a]} m] [a])) {"a" 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:strs [a b c]} m] [a b c])) {"a" 10 "b" 20 "c" 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {"a" 10 "c" 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(10 20 30 40) ((fn* [m] (let [{x :d :keys [a] :syms [b] :strs [c]} m] [a b c x])) {:a 10 'b 20 "c" 30 :d 40}))

  (assert= '(10 20 30 40) ((fn* [v] (let [[{:keys [a b]} {:syms [c d]}] v] [a b c d])) [{:a 10 :b 20} {'c 30 'd 40}]))

  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {}))
  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a []}))
  (assert= '(10 nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a [10]}))
  (assert= '(10 20) ((fn* [m] (let [{[x y] :a :or {[x y] [10 20]}} m] [x y])) {}))

  (assert= '(10 20) ((fn* [m] (let [{{:keys [b c]} :a} m] [b c])) {:a {:b 10 :c 20}}))

  (assert-throws IllegalArgument (macroexpand '(let [[x & y z] v] nil)))
  (assert-throws IllegalArgument (macroexpand '(let [10 v] nil)))
  (assert-throws IllegalArgument (macroexpand '(let [{:keys [10]} x] 0))))


(deftest fn
  (assert= '(fn* []) (macroexpand '(fn [])))
  (assert= '(fn* [] 10) (macroexpand '(fn [] 10)))
  (assert= '(fn* [a b] (do (x) (y))) (macroexpand '(fn [a b] (x) (y))))
  (assert= '(fn* abc [a b] (do (x) (y))) (macroexpand '(fn abc [a b] (x) (y))))
  (assert= '(fn* [a b] (x)) (macroexpand '(fn [a b] (x))))
  (assert= '(fn* abc [a b] (x)) (macroexpand '(fn abc [a b] (x))))
  (assert= '(fn* [a b]) (macroexpand '(fn [a b])))
  (assert= '(fn* abc [a b]) (macroexpand '(fn abc [a b])))
  (assert= '(fn* ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* abc ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn abc ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* ([a b] (do (x) (y))) ([z])) (macroexpand '(fn ([a b] (x) (y)) ([z])))))


(deftest fn-destructuring
  (assert= [:a :b] ((fn [[x y]] [y x]) [:b :a]))
  (assert= [:a :b] ((fn [[x] [y]] [y x]) [:b] [:a]))
  (assert= [:a :b] ((fn [{:keys [x y]}] [y x]) {:x :b :y :a}))
  (assert= [:a :b] ((fn [x & [y]] [y x]) :b :a)))


(deftest loop
  (assert= '(loop* [a 1 b 2] (do (x) (y))) (macroexpand '(loop [a 1 b 2] (x) (y))))
  (assert= '(loop* [a 1 b 2] (x)) (macroexpand '(loop [a 1 b 2] (x))))
  (assert= '(loop* [a 1 b 2] nil) (macroexpand '(loop [a 1 b 2]))))


(deftest loop-destructuring
  (assert= [:b :a] ((fn* [v] (loop [[x y] v] [y x])) [:a :b :c]))
  (assert= :c ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b :c]))
  (assert= :b ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b nil :c]))
  (assert= [:c 7] ((fn* [v u] (loop [[v0 v1 :as allv] v [u0 u1 :as allu] u] (if v1 (recur (next allv) (next allu)) [v0 u0]))) [:a :b :c] [4 5 7]))
  (assert= [:b [5 6 7]] ((fn* [v u] (loop [[x y :as all] v u u] (if y (recur (next all) (next u)) [x u]))) [:a :b nil :c] [4 5 6 7])))


(deftest defn
  (assert= '(def {:arglists '([a b])} abc (cleo.core/fn abc [a b] (x) (y))) (macroexpand '(defn abc [a b] (x) (y))))
  (assert= '(def {:arglists '([] [x] [a b])} abc (cleo.core/fn abc ([] 1) ([x] 2) ([a b] 3))) (macroexpand '(defn abc ([] 1) ([x] 2) ([a b] 3))))
  (assert= '(def {:arglists '([x]) :doc "some"} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn abc "some" [x] y)))
  (assert= '(def {:arglists '([x]) :const :true} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn abc {:const :true} [x] y)))
  (assert= '(def {:arglists '([x]) :const :true, :doc "some"} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn abc "some" {:const :true} [x] y)))
  (assert= '(def {:arglists '([x]) :const :true, :doc "better doc"} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn abc "some" {:const :true, :doc "better doc"} [x] y)))
  (assert= '(def {:arglists '([1 2 3])} abc (cleo.core/fn abc [a b])) (macroexpand '(defn abc {:arglists '([1 2 3])} [a b]))))


(deftest defn-
  (assert= '(def {:private :true, :arglists '([a b])} abc (cleo.core/fn abc [a b] (x) (y))) (macroexpand '(defn- abc [a b] (x) (y))))
  (assert= '(def {:private :true, :arglists '([x]) :doc "some"} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn- abc "some" [x] y)))
  (assert= '(def {:private :true, :arglists '([x]) :const :true} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn- abc {:const :true} [x] y)))
  (assert= '(def {:private :true, :arglists '([x]) :const :true, :doc "some"} abc (cleo.core/fn abc [x] y)) (macroexpand '(defn- abc "some" {:const :true} [x] y)))
  (assert= '(def {:private :true, :arglists '([x])} abc (cleo.core/fn abc [x])) (macroexpand '(defn- abc {:private 10} [x]))))


(defn df-example1 [[x y]] [y x])
(defn df-example2 [[x] [y]] [y x])
(defn df-example3 [{:keys [x y]}] [y x])


(deftest defn-destructuring
  (assert= [:a :b] (df-example1 [:b :a]))
  (assert= [:a :b] (df-example2 [:b] [:a]))
  (assert= [:a :b] (df-example3 {:x :b :y :a})))


(defmacro dm-example1 [[x y z]] (list y x z))
(defmacro dm-example2 [{:keys [op vals]}] (conj vals op))


(deftest defmacro-destructuring
  (assert= 30 (dm-example1 [10 + 20]))
  (assert= 33 (dm-example2 {:op + :vals (11 22)})))


(deftest not
  (assert= nil (not 10))
  (assert= nil (not [1]))
  (assert= :true (not nil)))


(deftest or
  (assert= nil (or))
  (assert= 10 (or 10))
  (assert= nil (or nil))
  (assert= :x (or nil :x))
  (assert= :x (or :x :y))
  (assert= nil (or nil nil))
  (assert= :x (or nil nil :x))
  (assert= :y (or nil :y :x))
  (assert= :a (or :a nil :x))
  (assert= nil (or nil nil nil)))


(deftest and
  (assert= :true (and))
  (assert= 10 (and 10))
  (assert= nil (and nil))
  (assert= nil (and nil :x))
  (assert= nil (and :x nil))
  (assert= :y (and :x :y))
  (assert= nil (and nil nil))
  (assert= nil (and nil nil :x))
  (assert= nil (and nil :y :x))
  (assert= nil (and :a nil :x))
  (assert= :d (and :a :b :c :d)))


(deftest seq?
  (assert (seq? ()))
  (assert (seq? (list 1 2)))
  (assert (not (seq? nil)))
  (assert (not (seq? [1 2])))
  (assert (seq? (seq [1 2])))
  (assert (not (seq? #{1 2})))
  (assert (not (seq? {1 2})))
  (assert (not (seq? 10))))


(deftest when
  (assert= '(if x (do)) (macroexpand '(when x)))
  (assert= '(if x (do y)) (macroexpand '(when x y)))
  (assert= '(if x (do y z)) (macroexpand '(when x y z))))


(deftest cond
  (assert= nil (macroexpand '(cond)))
  (assert= `(if (~'= 1 2) (~'= 3 4) (cond)) (macroexpand '(cond (= 1 2) (= 3 4))))
  (assert= `(if :a :b (cond :c :d)) (macroexpand '(cond :a :b :c :d)))
  (assert-throws IllegalArgument (macroexpand '(cond :a))))


(deftest bit-and
  (assert= (bit-and* 12345 54321) (bit-and 12345 54321))
  (assert= (bit-and* (bit-and* 12345 54321) 97553) (bit-and 12345 54321 97553))
  (assert= (bit-and* (bit-and* (bit-and* 12345 54321) 97553) 57753) (bit-and 12345 54321 97553 57753)))


(deftest bit-or
  (assert= (bit-or* 12345 54321) (bit-or 12345 54321))
  (assert= (bit-or* (bit-or* 12345 54321) 97553) (bit-or 12345 54321 97553))
  (assert= (bit-or* (bit-or* (bit-or* 12345 54321) 97553) 57753) (bit-or 12345 54321 97553 57753)))


(deftest bit-xor
  (assert= (bit-xor* 12345 54321) (bit-xor 12345 54321))
  (assert= (bit-xor* (bit-xor* 12345 54321) 97553) (bit-xor 12345 54321 97553))
  (assert= (bit-xor* (bit-xor* (bit-xor* 12345 54321) 97553) 57753) (bit-xor 12345 54321 97553 57753)))


(deftest bit-and-not
  (assert= (bit-and-not* 12345 54321) (bit-and-not 12345 54321))
  (assert= (bit-and-not* (bit-and-not* 12345 54321) 97553) (bit-and-not 12345 54321 97553))
  (assert= (bit-and-not* (bit-and-not* (bit-and-not* 12345 54321) 97553) 57753) (bit-and-not 12345 54321 97553 57753)))


(deftest even?
  (assert (even? 10))
  (assert-not (even? 11))
  (assert (even? -10))
  (assert-not (even? -11)))


(deftest odd?
  (assert (odd? 11))
  (assert-not (odd? 10))
  (assert (odd? -11))
  (assert-not (odd? -10)))


(deftest conj
  (assert= [] (conj))
  (assert= [10 20] (conj [10 20]))
  (assert= [10 20 30] (conj [10 20] 30))
  (assert= [10 20 30 40] (conj [10 20] 30 40))
  (assert= [10 20 30 40 50] (conj [10 20] 30 40 50))
  (assert= [10 20 nil nil] (conj [10 20] nil nil))
  (assert= nil (conj nil))
  (assert= '(20 10) (conj nil 10 20))
  (assert= '(nil) (conj nil nil)))


(deftest assoc
  (assert= {:a 1 :b 2} (assoc {:a 1} :b 2))
  (assert= {:a 1 :b 2 :c 3} (assoc {:a 1} :b 2 :c 3))
  (assert= {:a 1 :b 2 :c 3 :d 4} (assoc {:a 1} :b 2 :c 3 :d 4))
  (assert= {:a 1 :b 2} (assoc nil :a 1 :b 2))
  (assert-throws IllegalArgument (assoc {} :a 1 :b)))


(deftest dissoc
  (assert= {:a 1 :b 2} (dissoc {:a 1 :b 2}))
  (assert= {:a 1} (dissoc {:a 1 :b 2} :b))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3} :b :c))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3 :d 4} :b :c :d))
  (assert= nil (dissoc nil))
  (assert= nil (dissoc nil :a)))


(deftest every?
  (assert (every? odd? nil))
  (assert (every? odd? []))
  (assert (every? odd? [1 3 5]))
  (assert-not (every? odd? [2 3 5]))
  (assert-not (every? odd? [1 2 5]))
  (assert-not (every? odd? [1 3 2])))


(deftest some
  (let [pred (fn [x] (and (even? x) (pr-str x)))]
    (assert= nil (some pred nil))
    (assert= nil (some pred []))
    (assert= nil (some pred [1 3 5]))
    (assert= "4" (some pred [4 3 5]))
    (assert= "8" (some pred [1 8 5]))
    (assert= "10" (some pred [1 3 10]))))


(deftest if-let
  (assert= :a (if-let [x (seq [:a])] (first x)))
  (assert= nil (if-let [x (seq [])] (first x)))
  (assert= :a (if-let [x (seq [:a])] (first x) :b))
  (assert= :b (if-let [x (seq [])] (first x) :b)))


(deftest when-let
  (assert= nil (when-let [x (seq [:a])]))
  (assert= :a (when-let [x (seq [:a])] (+ 1 2) (first x)))
  (assert= nil (when-let [x (seq [])] (+ 1 2) (first x))))


(deftest partition-kv
  (assert= () (#'cleo.core/partition-kv []))
  (assert= [[nil :b]] (#'cleo.core/partition-kv [nil :b]))
  (assert= [[:a nil]] (#'cleo.core/partition-kv [:a nil]))
  (assert= [[:a :b]] (#'cleo.core/partition-kv [:a :b :c]))
  (assert= [[:a :b]] (#'cleo.core/partition-kv [:a :b nil]))
  (assert= [[:a :b] [:c :d]] (#'cleo.core/partition-kv [:a :b :c :d]))
  (assert= [[:a :b] [:c nil]] (#'cleo.core/partition-kv [:a :b :c nil]))
  (assert= [[:a :b] [:c nil]] (#'cleo.core/partition-kv [:a :b :c nil :e])))


(deftest reduce
  (assert= "" (reduce str nil))
  (assert= "" (reduce str []))
  (assert= 10 (reduce str [10]))
  (assert= "102030" (reduce str [10 20 30]))
  (assert= [[30 20] 10] (reduce list [30 20 10]))
  (assert= 100 (reduce + 100 nil))
  (assert= 100 (reduce + 100 []))
  (assert= 110 (reduce + 100 [10]))
  (assert= 160 (reduce + 100 [10 20 30]))
  (assert= [[30 20] 10] (reduce list 30 [20 10])))


(deftest concati
  (assert= [] (concati))
  (assert= [:a :b] (concati [:a :b]))
  (assert= [:a :b :c :d] (concati [:a :b] [:c :d]))
  (assert= [:a :b] (concati [] '(:a :b)))
  (assert= [:a :b] (concati () [:a :b]))
  (assert= [:a :b] (concati [:a :b] []))
  (assert= [:a :b :c :d :e :f] (concati [:a :b] [:c :d] [:e :f]))
  (assert= [:a :b :c :d :e :f] (concati '(:a :b) () '(:c) [:d] '(:e :f) [])))


(deftest dotimes
  (assert= [0 1 2 3 4]
           (let [v (atom [])]
             (dotimes [i 5] (swap! v conj i))
             @v))
  (assert-not (let [called? (atom nil)]
                (dotimes [i 0] (reset! called? :true))
                @called?)))


(deftest doseq
  (assert= [:c :b :a]
           (let [l (atom ())]
             (doseq [x [:a :b :c]] (swap! l conj x))
             @l))
  (assert-not (let [called? (atom nil)]
                (doseq [x nil] (reset! called? :true))
                @called?))
  (assert-not (let [called? (atom nil)]
                (doseq [x []] (reset! called? :true))
                @called?)))


(deftest map
  (assert= () (map inc nil))
  (assert= () (map inc []))
  (assert= '(11) (map inc [10]))
  (assert= '(9 7 2) (map dec [10 8 3])))


(deftest mapv
  (assert= [] (mapv inc nil))
  (assert= [] (mapv inc []))
  (assert= [11] (mapv inc [10]))
  (assert= [9 7 2] (mapv dec [10 8 3])))


(deftest filter
  (assert= () (filter even? nil))
  (assert= () (filter even? []))
  (assert= '(4 10) (filter even? [1 3 4 7 10]))
  (assert= () (filter zero? [1 3 4 7 10]))
  (assert= '(10) (filter even? [10]))
  (assert= () (filter odd? [10])))


(deftest drop
  (assert= () (drop 5 nil))
  (assert= '(:a :b :c :d) (drop -5 [:a :b :c :d]))
  (assert= '(:a :b :c :d) (drop 0 [:a :b :c :d]))
  (assert= '(:b :c :d) (drop 1 [:a :b :c :d]))
  (assert= '(:d) (drop 3 [:a :b :c :d]))
  (assert= () (drop 6 [:a :b :c :d])))


(deftest ns
  (assert= '(do (cleo.core/in-ns 'some.thing nil) (cleo.core/refer 'cleo.core)) (macroexpand '(ns some.thing)))
  (assert= '(do (cleo.core/in-ns 'abc nil) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc nil) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]) (cleo.core/require '[zzz] '[nnn]))
           (macroexpand '(ns abc (:require [xyz] [rst]) (:require [zzz] [nnn]))))
  (assert= '(do (cleo.core/in-ns 'abc {:doc "some"}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc "some" (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc {:x :y}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc {:x :y} (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc {:x :y :doc "some"}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc "some" {:x :y} (:require [xyz] [rst])))))


(deftest update
  (assert= {:abc 31 :xyz 12} (update {:abc 30 :xyz 12} :abc inc)))


(deftest ->
  (assert= 'x (macroexpand '(-> x)))
  (assert= '(f0 x) (macroexpand '(-> x f0)))
  (assert= '(f0 x a b) (macroexpand '(-> x (f0 a b))))
  (assert= '(f2 (f1 (f0 x))) (macroexpand '(-> x f0 f1 f2)))
  (assert= '(f1 (f0 x a) b c) (macroexpand '(-> x (f0 a) (f1 b c)))))


(deftest ->>
  (assert= 'x (macroexpand '(->> x)))
  (assert= '(f0 x) (macroexpand '(->> x f0)))
  (assert= '(f0 a b x) (macroexpand '(->> x (f0 a b))))
  (assert= '(f2 (f1 (f0 x))) (macroexpand '(->> x f0 f1 f2)))
  (assert= '(f1 b c (f0 a x)) (macroexpand '(->> x (f0 a) (f1 b c)))))


(deftest empty?
  (assert (empty? nil))
  (assert (empty? []))
  (assert-not (empty? [1]))
  (assert (empty? ()))
  (assert-not (empty? '(1)))
  (assert (empty? {}))
  (assert-not (empty? {1 2})))


(deftest max
  (assert= 10 (max 10))
  (assert= 20 (max 10 20))
  (assert= 10 (max 10 0))
  (assert= 3 (max 1 2 3))
  (assert= 3 (max 3 1 2))
  (assert= 4 (max 3 1 2 4)))


(deftest parse-const
  (assert= 10 (cc/parse 10))
  (assert= 3.5 (cc/parse 3.5))
  (assert= "abc" (cc/parse "abc"))
  (assert= :abc (cc/parse :abc))
  (assert= nil (cc/parse nil))
  (assert= () (cc/parse ()))
  (assert= {:tag :const, :value {:a 10}} (cc/parse {:a 10})))


(deftest parse-var
  (assert= {:tag :var, :name 'abc} (cc/parse 'abc)))


(deftest parse-if
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else nil} (cc/parse '(if c a)))
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else nil} (cc/parse '(if c a nil)))
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else {:tag :var, :name 'b}} (cc/parse '(if c a b))))


(deftest parse-call
  (assert= {:tag :call, :fn [7], :args []} (cc/parse '([7])))
  (assert= {:tag :call, :fn {:tag :var, :name 'f}, :args [10 {:tag :var, :name 'x}]} (cc/parse '(f 10 x))))


(deftest parse-quote
  (assert= 10 (cc/parse ''10))
  (assert= '(10 20) (cc/parse ''(10 20)))
  (assert= {:tag :const, :value {:a :b}} (cc/parse ''{:a :b})))


(deftest parse-do
  (assert= {:tag :do, :exprs []} (cc/parse '(do)))
  (assert= {:tag :do, :exprs [{:tag :var, :name 'x}]} (cc/parse '(do x)))
  (assert= {:tag :do, :exprs [{:tag :var, :name 'x} {:tag :var, :name 'y}]} (cc/parse '(do x y))))


(deftest parse-let
   (assert= {:tag :let, :locals [], :exprs []} (cc/parse '(let* [])))
   (assert= {:tag :let, :locals [], :exprs [nil]} (cc/parse '(let* [] nil)))
   (assert= {:tag :let, :locals [], :exprs [{:tag :var, :name 'a} 10]} (cc/parse '(let* [] a 10)))
   (assert= {:tag :let, :locals [{:name 'a, :index 0, :expr 10}], :exprs []} (cc/parse '(let* [a 10])))
   (assert= {:tag :let, :locals [{:name 'a, :index 0, :expr 10}
                                 {:name 'b, :index 1, :expr 20}
                                 {:name 'c, :index 2, :expr 30}], :exprs []} (cc/parse '(let* [a 10 b 20 c 30])))
   (assert= [{:tag :local, :index 1} {:tag :local, :index 2} {:tag :local, :index 0}] (:exprs (cc/parse '(let* [a 10 b 20 c 30] b c a))))
   (let [let3 (cc/parse '(let* [a :x] (let* [b :y c :z] (let* [d :w]))))]
     (assert= [{:name 'a, :index 0, :expr :x}] (-> let3 :locals))
     (assert= [{:name 'b, :index 1, :expr :y} {:name 'c, :index 2, :expr :z}] (-> let3 :exprs first :locals))
     (assert= [{:name 'd, :index 3, :expr :w}] (-> let3 :exprs first :exprs first :locals)))
   (assert= {:tag :let
             :locals [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
                      {:name 'x, :index 1, :expr {:tag :local, :index 0}}
                      {:name 'x, :index 2, :expr {:tag :local, :index 1}}]
             :exprs [{:tag :local, :index 2}]} (cc/parse '(let* [x x x x x x] x)))
   (assert= [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
             {:name 'y, :index 1, :expr {:tag :var, :name 'y}}
             {:name 'x, :index 2, :expr {:tag :local, :index 1}}
             {:name 'y, :index 3, :expr {:tag :local, :index 2}}] (:locals (cc/parse '(let* [x x y y x y y x])))))


(deftest parse-loop
   (assert= {:tag :loop, :locals [], :exprs []} (cc/parse '(loop* [])))
   (assert= {:tag :loop, :locals [], :exprs [nil]} (cc/parse '(loop* [] nil)))
   (assert= {:tag :loop, :locals [], :exprs [{:tag :var, :name 'a} 10]} (cc/parse '(loop* [] a 10)))
   (assert= {:tag :loop, :locals [{:name 'a, :index 0, :expr 10}], :exprs []} (cc/parse '(loop* [a 10])))
   (assert= {:tag :loop, :locals [{:name 'a, :index 0, :expr 10}
                                 {:name 'b, :index 1, :expr 20}
                                 {:name 'c, :index 2, :expr 30}], :exprs []} (cc/parse '(loop* [a 10 b 20 c 30])))
   (assert= [{:tag :local, :index 1} {:tag :local, :index 2} {:tag :local, :index 0}] (:exprs (cc/parse '(loop* [a 10 b 20 c 30] b c a))))
   (let [loop3 (cc/parse '(loop* [a :x] (loop* [b :y c :z] (loop* [d :w]))))]
     (assert= [{:name 'a, :index 0, :expr :x}] (-> loop3 :locals))
     (assert= [{:name 'b, :index 1, :expr :y} {:name 'c, :index 2, :expr :z}] (-> loop3 :exprs first :locals))
     (assert= [{:name 'd, :index 3, :expr :w}] (-> loop3 :exprs first :exprs first :locals)))
   (assert= {:tag :loop
             :locals [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
                      {:name 'x, :index 1, :expr {:tag :local, :index 0}}
                      {:name 'x, :index 2, :expr {:tag :local, :index 1}}]
             :exprs [{:tag :local, :index 2}]} (cc/parse '(loop* [x x x x x x] x)))
   (assert= [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
             {:name 'y, :index 1, :expr {:tag :var, :name 'y}}
             {:name 'x, :index 2, :expr {:tag :local, :index 1}}
             {:name 'y, :index 3, :expr {:tag :local, :index 2}}] (:locals (cc/parse '(loop* [x x y y x y y x])))))


(deftest parse-def
  (assert= {:tag :def, :name 'x, :expr 10} (cc/parse '(def x 10)))
  (assert= {:tag :def, :name 'x, :expr nil} (cc/parse '(def x nil)))
  (assert= {:tag :def, :name 'x} (cc/parse '(def x)))
  (assert= {:tag :def, :name 'a/x, :expr 10} (cc/parse '(def a/x 10)))
  (assert= {:tag :def, :name 'xr, :expr {:tag :var, :name 'xr}} (cc/parse '(def xr xr)))
  (assert= {:tag :def, :name 'z, :meta {10 20}, :expr 13} (cc/parse '(def {10 20} z 13)))
  (assert= {:tag :def, :name 'z, :meta {10 20}} (cc/parse '(def {10 20} z))))


(deftest parse-throw
  (assert= {:tag :throw, :expr {:tag :var, :name 'x}} (cc/parse '(throw x))))


(deftest parse-dot
  (assert= {:tag :dot, :expr {:tag :var, :name 'x}, :member 'xf} (cc/parse '(. x -xf))))


(deftest parse-vector
  (assert= [] (cc/parse []))
  (assert= [5 6 7] (cc/parse [5 6 7]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [3 4]) x))) (cc/parse '[3 4 x]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/conj! (cleo.core/conj! (cleo.core/transient []) z) x) y))) (cc/parse '[z x y]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [2 4.0 "x" :k]) (f 3)))) (cc/parse '[2 4.0 "x" :k (f 3)]))
  (assert= [10 [20 30]] (cc/parse [10 [20 30]]))
  (assert= (cc/parse '(cleo.core/persistent!
                       (cleo.core/conj!
                        (cleo.core/transient [10])
                        (cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [20]) x))))) (cc/parse '[10 [20 x]])))


(deftest parse-hash-set
  (assert= #{} (cc/parse #{}))
  (assert= #{5 6 7} (cc/parse #{5 6 7}))
  (assert= (cc/parse '(cleo.core/conj #{3 4} x)) (cc/parse '#{3 x 4}))
  (assert= (cc/parse '(cleo.core/conj (cleo.core/conj (cleo.core/conj #{} z) x) y)) (cc/parse '#{z x y}))
  (assert= (cc/parse '(cleo.core/conj #{2 4.0 "x" :k} (f 3))) (cc/parse '#{2 4.0 "x" (f 3) :k}))
  (assert= #{10 #{20 30}} (cc/parse #{10 #{20 30}}))
  (assert= (cc/parse '(cleo.core/conj #{10} (cleo.core/conj #{20} x))) (cc/parse '#{10 #{20 x}})))


(deftest parse-hash-map
  (assert= {:tag :const, :value {}} (cc/parse {}))
  (assert= {:tag :const, :value {5 6 7 8}} (cc/parse {5 6 7 8}))
  (assert= (cc/parse '(cleo.core/assoc {3 4 5 6} x y)) (cc/parse '{3 4 5 6 x y}))
  (assert= (cc/parse '(cleo.core/assoc {3 4} x 6)) (cc/parse '{3 4 x 6}))
  (assert= (cc/parse '(cleo.core/assoc {3 4} 5 x)) (cc/parse '{3 4 5 x}))
  (assert= {:tag :const, :value {{1 2} 3 4 {5 6}}} (cc/parse '{{1 2} 3 4 {5 6}}))
  (let [m2 (cc/parse '{3 4 5 x y 6})]
    (assert (or (= (cc/parse '(cleo.core/assoc (cleo.core/assoc {3 4} 5 x) y 6)) m2)
                (= (cc/parse '(cleo.core/assoc (cleo.core/assoc {3 4} y 6) 5 x)) m2))))
  (assert= (cc/parse '(cleo.core/assoc {1 2} 10 (cleo.core/assoc {} 20 x))) (cc/parse '{1 2 10 {20 x}}))
  (assert= (cc/parse '(cleo.core/assoc {1 2} (cleo.core/assoc {} x 20) 10)) (cc/parse '{1 2 {x 20} 10})))


(deftest parse-nested-structures
  (assert= [[10 20] [[30 [40]]]] (cc/parse [[10 20] [[30 [40]]]]))
  (assert= #{10 20 [30 40] #{50 #{} #{60}}} (cc/parse #{10 20 [30 40] #{50 #{} #{60}}}))
  (assert= [10 {20 {30 40}} #{50} [60]] (cc/parse [10 {20 {30 40}} #{50} [60]]))
  (assert= {:tag :const, :value {10 {20 {30 40}} #{50} [60]}} (cc/parse {10 {20 {30 40}} #{50} [60]})))


(deftest parse-let-with-other-forms
  (assert= [{:tag :if
             :cond {:tag :local, :index 1}
             :then {:tag :local, :index 2}
             :else {:tag :local, :index 0}}] (:exprs (cc/parse '(let* [x 10 y 20 z 30] (if y z x)))))
  (assert= [{:tag :do
             :exprs [{:tag :local, :index 1}
                     {:tag :local, :index 0}]}] (:exprs (cc/parse '(let* [x 10 y 20] (do y x)))))
  (assert= [{:tag :call
             :fn {:tag :local, :index 0}
             :args [{:tag :local, :index 1}]}] (:exprs (cc/parse '(let* [f 0 x 10] (f x)))))
  (assert= [{:tag :def
             :name 'x
             :meta {10 20}
             :expr {:tag :local, :index 1}}] (:exprs (cc/parse '(let* [x 1 y 2] (def {10 20} x y)))))
  (assert= [{:tag :throw
             :expr {:tag :local, :index 0}}] (:exprs (cc/parse '(let* [x 1] (throw x)))))
  (assert= [{:tag :dot
             :expr {:tag :local, :index 0}
             :member 'mz}] (:exprs (cc/parse '(let* [x 1] (. x -mz)))))
  (assert= (:exprs (cc/parse '(let* [x 1] (cleo.core/persistent! (cleo.core/conj! (cleo.core/transient []) x))))) (:exprs (cc/parse '(let* [x 1] [x]))))
  (assert= (:exprs (cc/parse '(let* [x 1] (cleo.core/conj #{} x)))) (:exprs (cc/parse '(let* [x 1] #{x}))))
  (assert= (:exprs (cc/parse '(let* [x 1 y 2] (cleo.core/assoc {3 4 5 6} x y)))) (:exprs (cc/parse '(let* [x 1 y 2] {3 4 5 6 x y}))))
  (assert= [{:tag :local, :index 0}] (:exprs (cc/parse '(let* [x 1] (try* x)))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :finally {:tag :local, :index 1}}] (:exprs (cc/parse '(let* [f 1 g 2] (try* f (finally* g))))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :catch {:type 'X, :local {:name 'x :index 2}, :expr {:tag :local, :index 1}}}]
           (:exprs (cc/parse '(let* [f 1 g 2] (try* f (catch* X x g))))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :catch {:type 'X, :local {:name 'x :index 2}, :expr {:tag :local, :index 2}}}]
           (:exprs (cc/parse '(let* [f 1 g 2] (try* f (catch* X x x))))))  )


(defmacro add-macro [x y] `(cleo.core/+ ~x ~y))


(deftest parse-macro
  (assert= (cc/parse '(cleo.core/+ (cleo.core/+ 1 2) (cleo.core/+ 3 4))) (cc/parse '(cleo.core.test/add-macro (cleo.core.test/add-macro 1 2) (cleo.core.test/add-macro 3 4)))))


(deftest parse-try
  (assert= nil (cc/parse '(try*)))
  (assert= {:tag :var, :name 'x} (cc/parse '(try* x))))


(deftest parse-try-catch
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :catch {:type 'X, :local {:name 'x :index 0}, :expr {:tag :var, :name 'g}}} (cc/parse '(try* f (catch* X x g))))
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :catch {:type 'X, :local {:name 'x :index 0}, :expr {:tag :local, :index 0}}} (cc/parse '(try* f (catch* X x x)))))


(deftest parse-try-finally
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :finally {:tag :var, :name 'g}} (cc/parse '(try* f (finally* g)))))


(deftest parse-fn
  (assert= {:tag :fn, :bodies []} (cc/parse '(fn*)))
  (assert= {:tag :fn, :name 'abc, :name-index 0, :bodies []} (cc/parse '(fn* abc)))
  (assert= {:tag :fn, :bodies [{:params [] :expr nil}]} (cc/parse '(fn* [])))
  (assert= {:tag :fn, :name 'abc, :name-index 0, :bodies [{:params [] :expr nil}]} (cc/parse '(fn* abc [])))
  (assert= [{:params [] :expr {:tag :var, :name 'f}}] (:bodies (cc/parse '(fn* [] f))))
  (assert= [{:params [] :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* f [] f))))
  (assert= [{:params [{:name 'x, :index 0}], :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [x] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [x y] x))))
  (assert= [{:params [{:name 'x, :index 1} {:name 'y, :index 2}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* f [x y] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y] y))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y &] y))))
  (assert= [{:params [{:name 'x, :index 0}], :vararg :true, :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [& x] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :vararg :true, :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x & y] y))))
  (assert-no-exception (cc/parse '(fn* ([x] nil) ([x & xs] nil))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1} {:name 'z, :index 2}], :vararg :true, :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y & z] y))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* ([x y] y)))))
  (assert= 'abc (:name (cc/parse '(fn* abc ([x y] y)))))
  (assert= [{:params [{:name 'z, :index 0}], :expr {:tag :local, :index 0}}
            {:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}]
           (:bodies (cc/parse '(fn* ([z] z) ([x y] y)))))
  (assert= {:params [{:name 'a, :index 0} {:name 'b, :index 1}]
            :expr {:tag :fn
                   :bodies [{:params [{:name 'a, :index 2} {:name 'c, :index 3}]
                             :expr {:tag :do
                                    :exprs [{:tag :local, :index 2}
                                            {:tag :local, :index 1}
                                            {:tag :local, :index 3}]}}]}}
           (-> (cc/parse '(fn* [a b] (fn* [a c] (do a b c)))) :bodies first))
  (assert= {:params [{:name 'a, :index 1}]
            :expr {:tag :fn
                   :name 'g
                   :name-index 2
                   :bodies [{:params [{:name 'b, :index 3}]
                             :expr {:tag :do
                                    :exprs [{:tag :local, :index 0}
                                            {:tag :local, :index 1}
                                            {:tag :local, :index 2}
                                            {:tag :local, :index 3}]}}]}}
           (-> (cc/parse '(fn* f [a] (fn* g [b] (do f a g b)))) :bodies first))
  (assert= {:tag :let
            :locals [{:name 'z, :index 1, :expr 10}]
            :exprs [{:tag :local, :index 1}]}
           (-> (cc/parse '(fn* [z] (let* [z 10] z))) :bodies first :expr))
  (assert= {:params [{:name 'z, :index 2}]
            :expr {:tag :do
                   :exprs [{:tag :local, :index 0} {:tag :local, :index 2}]}}
           (-> (cc/parse '(let* [x 10 z 20] (fn* [z] (do x z)))) :exprs first :bodies first)))


(deftest parse-recur
  (assert= {:tag :recur
            :args [{:tag :local, :index 1}
                   {:tag :local, :index 0}]}
           (-> (cc/parse '(fn* [a b] (recur b a))) :bodies first :expr))
  (assert= {:tag :recur
            :args [{:tag :local, :index 1}
                   {:tag :local, :index 2}]}
           (-> (cc/parse '(fn* [a b] (let [c 5] (recur b c)))) :bodies first :expr :exprs first))
  (assert-no-exception (cc/parse '(fn* [x] (do 10 (recur 20)))))
  (assert-no-exception (cc/parse '(fn* [x] (let* [c 0] 10 (recur 20)))))
  (assert-no-exception (cc/parse '(loop* [c 0] 10 (recur 20))))
  (assert-no-exception (cc/parse '(fn* [x] (if x (recur x) 1))))
  (assert-no-exception (cc/parse '(fn* [x] (if x 1 (recur x))))))


(deftest parse-errors
  (assert-compilation-error "Too few arguments to if" (cc/parse '(if)))
  (assert-compilation-error "Too few arguments to if" (cc/parse '(if 1)))
  (assert-compilation-error "Too many arguments to if" (cc/parse '(if 1 2 3 4 )))

  (assert-compilation-error "Wrong number of args (0) passed to quote, form: (quote)" (cc/parse '(quote)))
  (assert-compilation-error "Wrong number of args (2) passed to quote, form: (quote 10 \"20\")" (cc/parse '(quote 10 "20")))

  (assert-compilation-error "Wrong number of args (0) passed to let*, form: (let*)" (cc/parse '(let*)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(let* nil)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(let* ())))
  (assert-compilation-error "Bad binding form, expected matched symbol expression pairs" (cc/parse '(let* [a 10 b])))
  (assert-compilation-error "Unsupported binding form: 10" (cc/parse '(let* [10 20])))
  (assert-compilation-error "Can't let qualified name: x/a" (cc/parse '(let* [x/a 20])))

  (assert-compilation-error "Wrong number of args (0) passed to loop*, form: (loop*)" (cc/parse '(loop*)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(loop* nil)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(loop* ())))
  (assert-compilation-error "Bad binding form, expected matched symbol expression pairs" (cc/parse '(loop* [a 10 b])))
  (assert-compilation-error "Unsupported binding form: 10" (cc/parse '(loop* [10 20])))
  (assert-compilation-error "Can't let qualified name: x/a" (cc/parse '(loop* [x/a 20])))

  (assert-compilation-error "Too few arguments to def" (cc/parse '(def)))
  (assert-compilation-error "Too few arguments to def" (cc/parse '(def {2 3})))
  (assert-compilation-error "Too many arguments to def" (cc/parse '(def x 10 30)))
  (assert-compilation-error "Too many arguments to def" (cc/parse '(def {} x 10 30)))
  (assert-compilation-error "First argument to def must be a Symbol" (cc/parse '(def 10 20)))
  (assert-compilation-error "First argument to def must be a Symbol" (cc/parse '(def 10 x)))

  (assert-compilation-error "Too few arguments to throw, expected a single value" (cc/parse '(throw)))
  (assert-compilation-error "Too many arguments to throw, expected a single value" (cc/parse '(throw 10 20)))

  (assert-compilation-error "Malformed member expression" (cc/parse '(. x y)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x 10)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x -)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(.)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x y)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x -y 20)))

  (assert-compilation-error "expected catch* or finally* block in try*" (cc/parse '(try* 10 20)))
  (assert-compilation-error "expected catch* or finally* block in try*" (cc/parse '(try* 10 (something))))
  (assert-compilation-error "missing exception type in catch*" (cc/parse '(try* 10 (catch*))))
  (assert-compilation-error "missing exception binding in catch*" (cc/parse '(try* 10 (catch* Exception))))
  (assert-compilation-error "missing catch* body" (cc/parse '(try* 10 (catch* Exception x))))
  (assert-compilation-error "missing finally* body" (cc/parse '(try* 10 (finally*))))
  (assert-compilation-error "Too many expressions in finally*, expected one" (cc/parse '(try* 10 (finally* 20 30))))
  (assert-compilation-error "Too many expressions in catch*, expected one" (cc/parse '(try* 10 (catch* Exception x 20 30))))
  (assert-compilation-error "Too many expressions in try*" (cc/parse '(try* 10 (catch* Exception x nil) (finally* nil))))

  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* 10 nil)))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* nil [])))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* some 10 nil)))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* (10 nil))))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* some (10 nil))))
  (assert-compilation-error "fn* params must be symbols" (cc/parse '(fn* [10] nil)))
  (assert-compilation-error "fn* params must be symbols" (cc/parse '(fn* [x y 20] nil)))
  (assert-compilation-error "Can't user qualified name as parameter: a/x" (cc/parse '(fn* [a/x y] nil)))
  (assert-compilation-error "Can't user qualified name as parameter: b/y" (cc/parse '(fn* [x b/y] nil)))
  (assert-compilation-error "Too many forms passed to fn*" (cc/parse '(fn* [] 10 20)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [& x y] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x & y z] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x & y z &] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x y & &] nil)))

  (assert-compilation-error "Mismatched argument count to recur, expected 0 args, got 1" (cc/parse '(fn* [x] (loop* [] (recur 1)))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 0" (cc/parse '(fn* [] (loop* [x 5 y 6] (recur)))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(loop* [x 5 y 6] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(loop* [x 5 y 6] (recur 1 2 3))))
  (assert-compilation-error "Mismatched argument count to recur, expected 0 args, got 1" (cc/parse '(fn* [] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(fn* [x y] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(fn* [x y] (recur 1 2 3))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(fn* [x & y] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(fn* [x & y] (recur 1 2 3))))

  (assert-compilation-error "Can only recur from tail position" (cc/parse '(recur 10)))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do (recur) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do 1 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y (recur 10)] 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y 1] (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y 1] 2 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y (recur 10)]) 0)))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y 1] (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y 1] 2 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10) (catch* Exception e e)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* 10 (catch* Exception e (recur 10))))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10) (finally* 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* 10 (finally* (recur 10))))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] [(recur 10)])))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] #{(recur 10)})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] {(recur 10) :v})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] {:k (recur 10)})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (f (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (f 0 (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] ((recur 10) 20))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (def z (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (if (recur 10) 1 2))))

  (assert-compilation-error "Can't have fixed arity function with more params than variadic function" (cc/parse '(fn* ([a b] nil) ([a & b] nil))))
  (assert-compilation-error "Can't have fixed arity function with more params than variadic function" (cc/parse '(fn* ([a b & c] nil) ([a b] nil) ([a b c]))))
  (assert-compilation-error "Can't have more than 1 variadic overload" (cc/parse '(fn* ([a & b] nil) ([& b] nil))))
  (assert-compilation-error "Can't have 2 overloads with same arity" (cc/parse '(fn* ([x] nil) ([x y] nil) ([x] nil)))))


(defn translate-body [form]
  (-> form
      cc/parse
      cc/translate
      :bodies
      first))


(deftest translate-fn
  (assert= {:bodies [{:arity 0
                      :bytecode [vm/CNIL]}]}
           (cc/translate (cc/parse '(fn* []))))
  (assert= {:name 'abc
            :bodies [{:arity 0
                      :bytecode [vm/CNIL]}]}
           (cc/translate (cc/parse '(fn* abc []))))
  (assert= {:name 'abc
            :bodies [{:arity 0
                      :bytecode [vm/LDL 255 255]}]}
           (cc/translate (cc/parse '(fn* abc [] abc))))
  (assert= {:name 'abc
            :bodies [{:arity 2
                      :bytecode [vm/LDL 254 255
                                 vm/POP
                                 vm/LDL 255 255
                                 vm/POP
                                 vm/LDL 253 255]}]}
           (cc/translate (cc/parse '(fn* abc [x y] (do x y abc)))))
  (assert= {:name 'abc
            :bodies [{:arity 2
                      :vararg :true
                      :bytecode [vm/LDL 254 255
                                 vm/POP
                                 vm/LDL 255 255
                                 vm/POP
                                 vm/LDL 253 255]}]}
           (cc/translate (cc/parse '(fn* abc [x & y] (do x y abc)))))
  (assert= {:bodies [{:arity 0
                      :bytecode [vm/CNIL]}
                     {:arity 1
                      :bytecode [vm/CNIL]}
                     {:arity 3
                      :bytecode [vm/CNIL]}]}
           (cc/translate (cc/parse '(fn* ([]) ([x]) ([x y z])))))
  (when slow-tests
    (assert-compilation-error "Too many params: 32768" (translate-body (list 'fn*
                                                                             (loop [i 0 bindings (transient [])]
                                                                               (if (< i 32768)
                                                                                 (recur (inc i) (-> bindings (conj! 'p)))
                                                                                 (persistent! bindings)))
                                                                             nil)))))


(deftest translate-const
  (assert= {:arity 0
            :consts [:xyz]
            :bytecode [vm/LDC 0 0]}
           (translate-body :xyz))
  (assert= {:arity 0
            :consts [100]
            :bytecode [vm/LDC 0 0]}
           (translate-body 100))
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body nil))
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(do)))
  (assert= {:arity 0
            :consts [{:a :b}]
            :bytecode [vm/LDC 0 0]}
           (translate-body {:a :b}))
  (assert= {:arity 0
            :consts [10 20 30]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 0 0
                       vm/POP
                       vm/CNIL
                       vm/POP
                       vm/LDC 2 0]}
           (translate-body '(do 10 20 10 nil 30)))
  (assert= {:arity 0
            :consts [() [] #{} {}]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 2 0
                       vm/POP
                       vm/LDC 3 0]}
           (translate-body '(do () [] #{} {})))
  (assert= {:arity 0
            :consts [10 20 30]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 0 0
                       vm/POP
                       vm/CNIL
                       vm/POP
                       vm/LDC 2 0]}
           (translate-body '(do (do 10 (do 20  10)) (do) 30)))
  (assert= [vm/LDC 254 0
            vm/LDC 255 0
            vm/LDC 0 1
            vm/LDC 1 1
            vm/CALL 226]
           (->> (translate-body '(fn* [f] (f (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
                                             33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                             65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                             97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                             129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                             161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                             193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                             225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257)))
                :bytecode (drop (+ 2 (* 3 256))))))


(defmacro binding-ns [name expr]
  `(let [prev# (ns-name *ns*)]
     (try*
       (do
         (in-ns ~name)
         ~expr)
       (finally*
         (in-ns prev#)))))


(def test-var1 10)
(def {:dynamic nil} test-var2 20)
(def {:dynamic :true} test-dynvar 30)
(def {:macro :true} test-macro 40)


(define-var 'cleo.compiler.private-var.test/test-var {:private :true})


(deftest translate-var
  (assert= {:arity 0
            :vars [#'test-var1]
            :bytecode [vm/LDV 0 0]}
           (translate-body 'cleo.core.test/test-var1))
  (assert-compilation-error "unable to resolve symbol: cleo.core.test/missing-var" (translate-body 'cleo.core.test/missing-var))
  (assert= {:arity 0
            :vars [#'test-var2 #'test-dynvar]
            :bytecode [vm/LDV 0 0
                       vm/POP
                       vm/LDDV 1 0]}
           (translate-body '(do cleo.core.test/test-var2 cleo.core.test/test-dynvar)))
  (assert= {:arity 0
            :vars [#'test-var1 #'test-var2]
            :bytecode [vm/LDV 0 0
                       vm/POP
                       vm/LDV 1 0
                       vm/POP
                       vm/LDV 0 0]}
           (translate-body '(do cleo.core.test/test-var1 cleo.core.test/test-var2 cleo.core.test/test-var1)))
  (assert-compilation-error "var: cleo.compiler.private-var.test/test-var is not public" (cc/translate (cc/parse 'cleo.compiler.private-var.test/test-var)))
  (binding-ns 'cleo.compiler.private-var.test
              (assert= {:arity 0
                        :vars [#'cleo.compiler.private-var.test/test-var]
                        :bytecode [vm/LDV 0 0]}
                       (translate-body 'cleo.compiler.private-var.test/test-var)))
  (assert-compilation-error "Can't take value of a macro: #'cleo.core.test/test-macro" (cc/translate (cc/parse 'cleo.core.test/test-macro))))


(deftest translate-param
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [a] a)))
  (assert= {:arity 3
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 253 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* fx [a b c] (do b a c)))))


(deftest translate-call
  (assert= {:arity 0
            :vars [#'test-var1]
            :bytecode [vm/LDV 0 0
                       vm/CALL 0]}
           (translate-body '(cleo.core.test/test-var1)))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/CALL 0]}
           (translate-body '(fn* [p] (p))))
  (assert= {:arity 1
            :consts [10 20]
            :vars [#'test-var1]
            :bytecode [vm/LDL 255 255
                       vm/LDV 0 0
                       vm/LDC 0 0
                       vm/LDC 1 0
                       vm/CALL 3]}
           (translate-body '(fn* [f] (f cleo.core.test/test-var1 10 20))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 253 255
                       vm/CALL 1
                       vm/CALL 1
                       vm/CALL 2]}
           (translate-body '(fn* [a b c] (a (b) (c (b a))))))
  (assert-no-exception (translate-body
                        '(fn* [f] (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
                                     33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                     65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                     97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                     129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                     161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                     193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                     225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254))))
  (assert-compilation-error "Too many arguments: 256"
                            (translate-body
                             '(fn* [f] (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
                                          33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                          65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                          97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                          129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                          161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                          193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                          225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255)))))


(deftest translate-let
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(let* [])))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [x] (let* [] x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* [x y] (let* [] x y))))
  (assert= {:arity 0
            :locals-size 2
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 0 0
                       vm/LDC 0 0
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/POP
                       vm/LDL 1 0]}
           (translate-body '(let* [x 10 y 10] x y)))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [x] (let* [x x] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0]}
           (translate-body '(fn* [x] (let* [x x
                                            x x] x))))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (let* [x (let* [y (let* [z a] z)] y)] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/LDL 1 0
                       vm/CALL 1
                       vm/BR 9 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (if a (let* [x a y a] (x y)) (let* [x a] x)))))
  (let [let257 (translate-body '(fn* [a] (let* [a00 nil a01 nil a02 nil a03 nil a04 nil a05 nil a06 nil a07 nil
                                                a08 nil a09 nil a0a nil a0b nil a0c nil a0d nil a0e nil a0f nil
                                                a10 nil a11 nil a12 nil a13 nil a14 nil a15 nil a16 nil a17 nil
                                                a18 nil a19 nil a1a nil a1b nil a1c nil a1d nil a1e nil a1f nil
                                                a20 nil a21 nil a22 nil a23 nil a24 nil a25 nil a26 nil a27 nil
                                                a28 nil a29 nil a2a nil a2b nil a2c nil a2d nil a2e nil a2f nil
                                                a30 nil a31 nil a32 nil a33 nil a34 nil a35 nil a36 nil a37 nil
                                                a38 nil a39 nil a3a nil a3b nil a3c nil a3d nil a3e nil a3f nil
                                                a40 nil a41 nil a42 nil a43 nil a44 nil a45 nil a46 nil a47 nil
                                                a48 nil a49 nil a4a nil a4b nil a4c nil a4d nil a4e nil a4f nil
                                                a50 nil a51 nil a52 nil a53 nil a54 nil a55 nil a56 nil a57 nil
                                                a58 nil a59 nil a5a nil a5b nil a5c nil a5d nil a5e nil a5f nil
                                                a60 nil a61 nil a62 nil a63 nil a64 nil a65 nil a66 nil a67 nil
                                                a68 nil a69 nil a6a nil a6b nil a6c nil a6d nil a6e nil a6f nil
                                                a70 nil a71 nil a72 nil a73 nil a74 nil a75 nil a76 nil a77 nil
                                                a78 nil a79 nil a7a nil a7b nil a7c nil a7d nil a7e nil a7f nil
                                                a80 nil a81 nil a82 nil a83 nil a84 nil a85 nil a86 nil a87 nil
                                                a88 nil a89 nil a8a nil a8b nil a8c nil a8d nil a8e nil a8f nil
                                                a90 nil a91 nil a92 nil a93 nil a94 nil a95 nil a96 nil a97 nil
                                                a98 nil a99 nil a9a nil a9b nil a9c nil a9d nil a9e nil a9f nil
                                                aa0 nil aa1 nil aa2 nil aa3 nil aa4 nil aa5 nil aa6 nil aa7 nil
                                                aa8 nil aa9 nil aaa nil aab nil aac nil aad nil aae nil aaf nil
                                                ab0 nil ab1 nil ab2 nil ab3 nil ab4 nil ab5 nil ab6 nil ab7 nil
                                                ab8 nil ab9 nil aba nil abb nil abc nil abd nil abe nil abf nil
                                                ac0 nil ac1 nil ac2 nil ac3 nil ac4 nil ac5 nil ac6 nil ac7 nil
                                                ac8 nil ac9 nil aca nil acb nil acc nil acd nil ace nil acf nil
                                                ad0 nil ad1 nil ad2 nil ad3 nil ad4 nil ad5 nil ad6 nil ad7 nil
                                                ad8 nil ad9 nil ada nil adb nil adc nil add nil ade nil adf nil
                                                ae0 nil ae1 nil ae2 nil ae3 nil ae4 nil ae5 nil ae6 nil ae7 nil
                                                ae8 nil ae9 nil aea nil aeb nil aec nil aed nil aee nil aef nil
                                                af0 nil af1 nil af2 nil af3 nil af4 nil af5 nil af6 nil af7 nil
                                                af8 nil af9 nil afa nil afb nil afc nil afd nil afe nil aff nil
                                                a100 a] a100)))]
    (assert= [vm/LDL 255 255
              vm/STL 0 1
              vm/LDL 0 1] (drop (* 4 256) (:bytecode let257))))
  (when slow-tests
    (assert-compilation-error "Too many locals: 32769" (translate-body (list 'let* (loop [i 0 bindings (transient [])]
                                                                                     (if (< i 32769)
                                                                                       (recur (inc i) (-> bindings (conj! 'l) (conj! i)))
                                                                                       (persistent! bindings))))))))


(deftest translate-loop
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(loop* [])))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [x] (loop* [] x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* [x y] (loop* [] x y))))
  (assert= {:arity 0
            :locals-size 2
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 0 0
                       vm/LDC 0 0
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/POP
                       vm/LDL 1 0]}
           (translate-body '(loop* [x 10 y 10] x y)))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [x] (loop* [x x] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0]}
           (translate-body '(fn* [x] (loop* [x x
                                             x x] x))))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (loop* [x (let* [y (loop* [z a] z)] y)] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/LDL 1 0
                       vm/CALL 1
                       vm/BR 9 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (if a (loop* [x a y a] (x y)) (let* [x a] x))))))


(deftest translate-throw
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/THROW]}
           (translate-body '(fn* [p] (throw p))))
  (assert= {:arity 0
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/THROW]}
           (translate-body '(throw 10))))


(deftest translate-if
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/BNIL 6 0
                       vm/LDL 254 255
                       vm/BR 3 0
                       vm/LDL 255 255]}
           (translate-body '(fn* [a b c] (if a b c))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/BNIL 8 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 5 0
                       vm/LDL 255 255
                       vm/CALL 0]}
           (translate-body '(fn* [a b c] (if (a) (b) (c)))))
  (assert= {:arity 3
            :consts [101 102 103 104]
            :bytecode [vm/LDL 253 255
                       vm/BNIL 30 0
                       vm/LDL 254 255
                       vm/BNIL 18 0
                       vm/LDL 255 255
                       vm/BNIL 6 0
                       vm/LDC 0 0
                       vm/BR 3 0
                       vm/LDC 1 0
                       vm/BR 3 0
                       vm/LDC 2 0
                       vm/BR 3 0
                       vm/LDC 3 0]}
           (translate-body '(fn* [a b c] (if a (if b (if c 101 102) 103) 104)))))


(deftest translate-dot
  (assert= {:arity 1
            :consts ['xf]
            :bytecode [vm/LDL 255 255
                       vm/LDC 0 0
                       vm/LDDF]}
           (translate-body '(fn* [x] (. x -xf))))
  (assert= {:arity 2
            :consts ['xf]
            :bytecode [vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 1
                       vm/LDC 0 0
                       vm/LDDF]}
           (translate-body '(fn* [f x] (. (f x) -xf)))))


(deftest translate-apply
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/CNIL
                       vm/APPLY 0]}
           (translate-body '(fn* [f] (cleo.core/apply f nil))))
  (assert= {:arity 1
            :consts [10 20 30]
            :bytecode [vm/LDL 255 255
                       vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDC 2 0
                       vm/CNIL
                       vm/APPLY 3]}
           (translate-body '(fn* [f] (apply f 10 20 30 nil))))
  (assert= {:arity 3
            :consts [10 20]
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDC 0 0
                       vm/APPLY 0
                       vm/LDL 255 255
                       vm/LDC 1 0
                       vm/CALL 1
                       vm/APPLY 1]}
           (translate-body '(fn* [f g h] (apply f (apply g 10) (h 20)))))
  (assert-compilation-error "Wrong number of args (0) passed to cleo.core/apply" (cc/translate (cc/parse '(apply))))
  (assert-compilation-error "Wrong number of args (0) passed to cleo.core/apply" (cc/translate (cc/parse '(cleo.core/apply))))
  (assert-compilation-error "Wrong number of args (1) passed to cleo.core/apply" (cc/translate (cc/parse '(fn* [f] (cleo.core/apply f))))))


(define-var 'cleo.compiler.def.test.other/ex nil)

(in-ns 'cleo.compiler.def.test)
(def existing 10)
(cleo.core/in-ns 'cleo.core.test)

(deftest translate-def
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def x 10)))]
    (assert (resolve 'cleo.compiler.def.test/x))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/x) 10]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/SVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def z nil)))]
    (assert (resolve 'cleo.compiler.def.test/z))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/z)]
              :bytecode [vm/LDC 0 0
                         vm/CNIL
                         vm/SVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def w)))]
    (assert (resolve 'cleo.compiler.def.test/w))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/w)]
              :bytecode [vm/LDC 0 0]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def xr xr)))]
    (assert (resolve 'cleo.compiler.def.test/xr))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/xr)]
              :vars [(resolve 'cleo.compiler.def.test/xr)]
              :bytecode [vm/LDC 0 0
                         vm/LDV 0 0
                         vm/SVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def {:x 7} y 10)))]
    (assert= 7 (:x (meta (resolve 'cleo.compiler.def.test/y))))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/y) 10 {:x 7}]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/SVV
                         vm/LDC 2 0
                         vm/SVM]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def {:x 7} s)))]
    (assert= 7 (:x (meta (resolve 'cleo.compiler.def.test/s))))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/s) {:x 7}]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/SVM]}
             tbody))
  (assert (resolve 'cleo.compiler.def.test.other/ex))
  (assert-compilation-error "Can't create defs outside of current ns"
                            (binding-ns 'cleo.compiler.def.test
                                        (cc/translate (cc/parse '(def cleo.compiler.def.test.other/ex)))))
  (assert-compilation-error "Can't refer to qualified var that doesn't exist"
                            (binding-ns 'cleo.compiler.def.test
                                        (cc/translate (cc/parse '(def cleo.compiler.def.test.other/nex)))))
  (do
    (binding-ns 'cleo.compiler.def.test
                (translate-body '(def existing 7)))
    (assert= 10 cleo.compiler.def.test/existing)))


(deftest translate-recur
  (assert= {:arity 0
            :bytecode [vm/BR 253 255]}
           (translate-body '(fn* [] (recur))))
  (assert= {:arity 1
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 255 255
                       vm/BR (- 256 9) 255]}
           (translate-body '(fn* [x] (recur 10))))
  (assert= {:arity 3
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/LDL 255 255
                       vm/LDL 253 255
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/STL 253 255
                       vm/BR (- 256 21) 255]}
           (translate-body '(fn* [x y z] (recur 10 z x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 254 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 1
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/BR (- 256 26) 255
                       vm/BR 1 0
                       vm/CNIL]}
           (translate-body '(fn* [f x] (if x (recur f (f x))))))
  (assert= {:arity 2
            :vararg :true
            :consts [1 2]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [x & xs] (recur 1 2))))
  (assert= {:arity 0
            :bytecode [vm/BR 253 255]}
           (translate-body '(fn* [] (loop* [] (recur)))))
  (assert= {:arity 3
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/LDL 253 255
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/STL 1 0
                       vm/LDL 1 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/STL 0 0
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [a b f] (do (f) (loop* [x a y b] (recur y x))))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0
                       vm/STL 0 0
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [x] (loop* [a x] (let* [b a] (recur b)))))))


(deftest translate-try-catch
  (assert= {:arity 2
            :locals-size 1
            :bytecode [vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/LDL 0 0
                       vm/CALL 1]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 8, :stack-size 0, :type Exception}]}
           (translate-body '(fn* [f g] (try* (f) (catch* Exception e (g e))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/LDL 0 0
                       vm/CALL 1
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/LDL 0 0
                       vm/CALL 1]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 8, :stack-size 0, :type Exception}
                              {:start-offset 0, :end-offset 19, :handler-offset 22, :stack-size 0, :type IllegalArgument}]}
           (translate-body '(fn* [f g h] (try* (try* (f) (catch* Exception e (g e))) (catch* IllegalArgument e (h e))))))
  (assert= {:arity 2
            :locals-size 3
            :bytecode [vm/LDL 254 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 2 0
                       vm/LDL 1 0
                       vm/LDL 2 0
                       vm/CALL 1]
            :exception-table [{:start-offset 12, :end-offset 17, :handler-offset 20, :stack-size 0, :type Exception}]}
           (translate-body '(fn* [a b] (let* [f a g b] (try* (f) (catch* Exception e (g e)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/CALL 1]
            :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}]}
           (translate-body '(fn* [f g x] (f (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/CALL 3]
            :exception-table [{:start-offset 9, :end-offset 14, :handler-offset 17, :stack-size 3, :type Exception}]}
           (translate-body '(fn* [f g x] (f x g (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/APPLY 2]
            :exception-table [{:start-offset 9, :end-offset 14, :handler-offset 17, :stack-size 3, :type Exception}]}
           (translate-body '(fn* [f g x] (cleo.core/apply f x g (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 6 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 6 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/CALL 2]
            :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}
                              {:start-offset 17, :end-offset 22, :handler-offset 25, :stack-size 2, :type Exception}]}
           (translate-body '(fn* [f x y] (f (try* (x) (catch* Exception e e)) (try* (y) (catch* Exception e e))))))
  (let [body (binding-ns 'cleo.compiler.def.test
                         (translate-body '(fn* [x] (def z (try* (x) (catch* cleo.core/Exception e e))))))]
    (assert= {:arity 1
              :locals-size 1
              :consts [(resolve 'cleo.compiler.def.test/z)]
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/CALL 0
                         vm/BR 6 0
                         vm/STL 0 0
                         vm/LDL 0 0
                         vm/SVV]
              :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}]}
             body)))


(deftest translate-try-finally
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}]}
           (translate-body '(fn* [f g] (try* (f) (finally* (g))))))
  (assert= {:arity 2
            :locals-size 2
            :bytecode [vm/LDL 254 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/CALL 0
                       vm/LDL 1 0
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 1 0
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 12, :end-offset 17, :handler-offset 26, :stack-size 0}]}
           (translate-body '(fn* [a b] (let* [f a g b] (try* (f) (finally* (g)))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}
                              {:start-offset 0, :end-offset 21, :handler-offset 30, :stack-size 0}]}
           (translate-body '(fn* [f g h] (try* (try* (f) (finally* (g))) (finally* (h))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/CALL 2]
            :exception-table [{:start-offset 6, :end-offset 11, :handler-offset 20, :stack-size 2}]}
           (translate-body '(fn* [f g x] (f g (try* (x) (finally* (g)))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255 ; (f)
                       vm/CALL 0

                       vm/LDL 254 255 ; (g)
                       vm/CALL 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP

                       vm/BR 7 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP
                       vm/THROW

                       vm/POP

                       vm/BR 23 0
                       vm/LDL 254 255 ; (g)
                       vm/CALL 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP

                       vm/BR 7 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP
                       vm/THROW

                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 5, :end-offset 10, :handler-offset 19, :stack-size 1}
                              {:start-offset 30, :end-offset 35, :handler-offset 44, :stack-size 2}
                              {:start-offset 0, :end-offset 5, :handler-offset 30, :stack-size 0}]}
           (translate-body '(fn* [f g h] (try* (f) (finally* (try* (g) (finally* (h))))))))
  (assert= {:arity 4
            :bytecode [vm/LDL 252 255
                       vm/CALL 0
                       vm/LDL 253 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 253 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/POP
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}
                              {:start-offset 22, :end-offset 27, :handler-offset 36, :stack-size 0}]}
           (translate-body '(fn* [f g h i] (do (try* (f) (finally* (g))) (try* (h) (finally* (i))))))))


(deftest translate-ifn
  (let [f (translate-body '(fn* [] (fn* [] 10)))]
    (assert= {:arity 0
              :bytecode [vm/LDC 0 0]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:bodies [{:arity 0,
                        :consts [10],
                        :bytecode [vm/LDC 0 0]}]}
             (-> f :consts first deserialize-fn)))
  (let [f (translate-body '(fn* [x y] (fn* [] (x y))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (fn* [] (x 10 y y x 20 30))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [10 20 30 nil nil],
              :bytecode [vm/LDC 3 0
                         vm/LDC 0 0
                         vm/LDC 4 0
                         vm/LDC 4 0
                         vm/LDC 3 0
                         vm/LDC 1 0
                         vm/LDC 2 0
                         vm/CALL 6]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (let* [z x] (fn* [] (z x)))))]
    (assert= {:arity 2
              :locals-size 1
              :bytecode [vm/LDL 254 255
                         vm/STL 0 0
                         vm/LDC 0 0
                         vm/LDL 0 0
                         vm/LDL 254 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (fn* ([] (x 10)) ([a] (a x y)) ([a & b] (b y)))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= [{:arity 0
               :consts [10 nil nil]
               :bytecode [vm/LDC 1 0
                          vm/LDC 0 0
                          vm/CALL 1]}
              {:arity 1
               :consts [nil nil]
               :bytecode [vm/LDL 255 255
                          vm/LDC 0 0
                          vm/LDC 1 0
                          vm/CALL 2]}
              {:arity 2
               :vararg :true
               :consts [nil nil]
               :bytecode [vm/LDL 255 255
                          vm/LDC 1 0
                          vm/CALL 1]}]
             (-> f :consts first deserialize-fn :bodies)))
  (let [f (translate-body '(fn* [x] (fn* [x] (fn* [] x))))
        inner-f (-> f :consts first deserialize-fn :bodies first)]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0]}
             (dissoc f :consts))
    (assert= {:arity 1,
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/IFN 1]}
             (dissoc inner-f :consts))
    (assert= {:arity 0,
              :consts [nil],
              :bytecode [vm/LDC 0 0]}
             (-> inner-f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x] (fn* [y] (fn* [] (x y)))))
        inner-f (-> f :consts first deserialize-fn :bodies first)]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/IFN 1]}
             (dissoc f :consts))
    (assert= {:arity 1,
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc inner-f :consts))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> inner-f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* f1 [x] (fn* [] (f1 x 20))))]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [20 nil nil],
              :bytecode [vm/LDC 1 0
                         vm/LDC 2 0
                         vm/LDC 0 0
                         vm/CALL 2]}
             (-> f :consts first deserialize-fn :bodies first))))


(deftest compile-fn
  (let [f (binding-ns 'cleo.core.test
                      (cc/compile '(fn dummy [x & xs] (reduce + x xs))))]
    (assert= 4 (f 4))
    (assert= 10 (f 4 6))
    (assert= 19 (f 4 6 9)))
  (let [f (binding-ns 'cleo.core.test
                      (cc/compile '(fn dummy
                                     ([x y z] (+ x (- y z)))
                                     ([a b c & d] [a b c d])
                                     ([x] 10))))]
    (assert= 7 (f 8 4 5))
    (assert= 10 (f 8))
    (assert= '(1 2 3 (4)) (f 1 2 3 4)))
  (let [f (binding-ns 'cleo.core.test
                      (cc/compile '(fn dummy
                                     ([a] (try* (throw (IllegalArgument. "Bad")) (finally* (reset! a 5))))
                                     ([_ x] (try* (throw x) (catch* IllegalArgument e e))))))
        a (atom 1)]
    (assert-throws IllegalArgument (f a))
    (assert= 5 @a)
    (assert-throws IndexOutOfBounds (f 0 (IndexOutOfBounds.)))
    (assert= IllegalArgument (type (f 0 (IllegalArgument. "x"))))))
