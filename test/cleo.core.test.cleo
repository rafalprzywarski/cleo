(ns cleo.core.test)


(def tests (atom {}))
(def current-test (atom nil))
(def failed-tests (atom #{}))


(def deftest
  (macro* deftest [name & body]
    `(swap! tests assoc '~name (fn* ~name [] (do ~@body)))))


(def assert=
  (macro* assert= [expected actual]
    `(let* [expected-val# ~expected
            actual-val# ~actual]
       (if (= expected-val# actual-val#)
         nil
         (do
           (swap! failed-tests conj @current-test)
           (println @current-test "assertion failed:" ~(pr-str actual) "expected to equal:" expected-val# "actual:" actual-val#))))))


(def assert
  (macro* assert [actual]
    `(let* [actual-val# ~actual]
       (if actual-val#
         nil
         (do
           (swap! failed-tests conj @current-test)
           (println @current-test "assertion failed:" ~(pr-str actual) "expected to be true, actual:" actual-val#))))))


(def assert-throws
  (macro* [expected actual]
    `(try*
      (let* [actual-val# ~actual]
        (do
          (swap! failed-tests conj @current-test)
          (println @current-test "assertion failed:" ~(pr-str actual) "expected to throw" ~(pr-str expected) "actual value:" actual-val#)))
      (catch* ~expected ~'e nil))))

(def main
  (fn* main []
    (do
      (loop* [tests (seq @tests)]
        (if tests
          (do
            (reset! current-test ((first tests) 0))
            (((first tests) 1))
            (recur (next tests)))))
      (print "ok:" (- (count @tests) (count @failed-tests)))
      (if (< 0 (count @failed-tests))
        (print " failed:" (count @failed-tests)))
      (println)
      (if (= 0 (count @failed-tests)) 0 1))))


(deftest defmacro
  (assert= '(def sonia (macro* sonia [x] (do (a) (b) (c)))) (macroexpand '(defmacro sonia [x] (a) (b) (c))))
  (assert= '(def sonia (macro* sonia [x] (a))) (macroexpand '(defmacro sonia [x] (a))))
  (assert= '(def sonia (macro* sonia [x])) (macroexpand '(defmacro sonia [x]))))


(deftest let
  (assert= '(let* [a 1 b 2] (do (x) (y))) (macroexpand '(let [a 1 b 2] (x) (y))))
  (assert= '(let* [a 1 b 2] (x)) (macroexpand '(let [a 1 b 2] (x))))
  (assert= '(let* [a 1 b 2]) (macroexpand '(let [a 1 b 2]))))


(deftest fn
  (assert= '(fn* [a b] (do (x) (y))) (macroexpand '(fn [a b] (x) (y))))
  (assert= '(fn* abc [a b] (do (x) (y))) (macroexpand '(fn abc [a b] (x) (y))))
  (assert= '(fn* [a b] (x)) (macroexpand '(fn [a b] (x))))
  (assert= '(fn* abc [a b] (x)) (macroexpand '(fn abc [a b] (x))))
  (assert= '(fn* [a b]) (macroexpand '(fn [a b])))
  (assert= '(fn* abc [a b]) (macroexpand '(fn abc [a b])))
  (assert= '(fn* ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* abc ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn abc ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* ([a b] (do (x) (y))) ([z])) (macroexpand '(fn ([a b] (x) (y)) ([z])))))


(deftest defn
  (assert= '(def abc (cleo.core/fn abc [a b] (x) (y))) (macroexpand '(defn abc [a b] (x) (y)))))


(deftest not
  (assert= nil (not 10))
  (assert= nil (not [1]))
  (assert= :true (not nil)))


(deftest or
  (assert= nil (or))
  (assert= 10 (or 10))
  (assert= nil (or nil))
  (assert= :x (or nil :x))
  (assert= :x (or :x :y))
  (assert= nil (or nil nil))
  (assert= :x (or nil nil :x))
  (assert= :y (or nil :y :x))
  (assert= :a (or :a nil :x))
  (assert= nil (or nil nil nil)))


(deftest and
  (assert= :true (and))
  (assert= 10 (and 10))
  (assert= nil (and nil))
  (assert= nil (and nil :x))
  (assert= nil (and :x nil))
  (assert= :y (and :x :y))
  (assert= nil (and nil nil))
  (assert= nil (and nil nil :x))
  (assert= nil (and nil :y :x))
  (assert= nil (and :a nil :x))
  (assert= :d (and :a :b :c :d)))


(deftest seq?
  (assert (seq? ()))
  (assert (seq? (list 1 2)))
  (assert (not (seq? nil)))
  (assert (not (seq? [1 2])))
  (assert (seq? (seq [1 2])))
  (assert (not (seq? #{1 2})))
  (assert (not (seq? {1 2})))
  (assert (not (seq? 10))))


(deftest when
  (assert= '(if x (do)) (macroexpand '(when x)))
  (assert= '(if x (do y)) (macroexpand '(when x y)))
  (assert= '(if x (do y z)) (macroexpand '(when x y z))))


(deftest cond
  (assert= nil (macroexpand '(cond)))
  (assert= `(if (~'= 1 2) (~'= 3 4) (cond)) (macroexpand '(cond (= 1 2) (= 3 4))))
  (assert= `(if :a :b (cond :c :d)) (macroexpand '(cond :a :b :c :d)))
  (assert-throws IllegalArgument (cond :a))
  (assert-throws IllegalArgument (cond (= 1 2) :b :c)))


(deftest bit-and
  (assert= (bit-and* 12345 54321) (bit-and 12345 54321))
  (assert= (bit-and* (bit-and* 12345 54321) 97553) (bit-and 12345 54321 97553))
  (assert= (bit-and* (bit-and* (bit-and* 12345 54321) 97553) 57753) (bit-and 12345 54321 97553 57753)))


(deftest bit-or
  (assert= (bit-or* 12345 54321) (bit-or 12345 54321))
  (assert= (bit-or* (bit-or* 12345 54321) 97553) (bit-or 12345 54321 97553))
  (assert= (bit-or* (bit-or* (bit-or* 12345 54321) 97553) 57753) (bit-or 12345 54321 97553 57753)))


(deftest bit-xor
  (assert= (bit-xor* 12345 54321) (bit-xor 12345 54321))
  (assert= (bit-xor* (bit-xor* 12345 54321) 97553) (bit-xor 12345 54321 97553))
  (assert= (bit-xor* (bit-xor* (bit-xor* 12345 54321) 97553) 57753) (bit-xor 12345 54321 97553 57753)))


(deftest bit-and-not
  (assert= (bit-and-not* 12345 54321) (bit-and-not 12345 54321))
  (assert= (bit-and-not* (bit-and-not* 12345 54321) 97553) (bit-and-not 12345 54321 97553))
  (assert= (bit-and-not* (bit-and-not* (bit-and-not* 12345 54321) 97553) 57753) (bit-and-not 12345 54321 97553 57753)))
