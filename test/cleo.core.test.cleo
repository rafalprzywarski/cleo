(ns cleo.core.test)
(require 'cleo.compiler)
(alias 'cc 'cleo.compiler)
(require 'cleo.vm)
(alias 'vm 'cleo.vm)

(def slow-tests :true)
(def tests (atom {}))
(def current-test (atom nil))
(def failed-tests (atom #{}))


(def {:macro :true} deftest
  (fn* deftest [&form &env name & body]
    `(swap! tests assoc* '~name (fn* [] (do ~@body)))))


(def fail
  (fn* [& msg]
    (do
      (swap! failed-tests conj* @current-test)
      (println @current-test (apply str msg)))))


(def {:macro :true} fail-unless
  (fn* fail-unless [&form &env conde & msg]
    `(if ~conde
       nil
       (fail ~@msg))))


(def {:macro :true} assert=
  (fn assert= [&form &env expected actual]
    `(let* [expected-val# ~expected]
       (try*
         (let* [actual-val# ~actual]
           (fail-unless (= expected-val# actual-val#)
                        "assertion failed: " ~(pr-str actual)
                        " expected to equal: " (pr-str expected-val#)
                        " actual: " (pr-str actual-val#)))
         (catch* Exception ~'e
           (fail "assertion failed: " ~(pr-str actual)
                 " expected to equal: " (pr-str expected-val#)
                 " actual exception: " ~'e))))))


(def {:macro :true} assert
  (fn* assert [&form &env actual]
    `(try*
       (let* [actual-val# ~actual]
         (fail-unless actual-val#
                      "assertion failed: " ~(pr-str actual)
                      " expected to be true, actual: " (pr-str actual-val#)))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to be true, actual exception: " ~'e)))))


(def {:macro :true} assert-not
  (fn* assert-not [&form &env actual]
    `(assert ~(list 'not actual))))


(def {:macro :true} assert-throws
  (fn* [&form &env expected actual]
    `(try*
       (try*
         (let* [actual-val# ~actual]
           (fail
            "assertion failed: " ~(pr-str actual)
            " expected to throw " ~(pr-str expected)
            " actual value: " (pr-str actual-val#)))
         (catch* ~expected ~'e nil))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to throw " ~(pr-str expected)
               " actual exception: " ~'e)))))


(def {:macro :true} assert-no-exception
  (fn* [&form &env actual]
    `(try*
       ~actual
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected no exception, got: " ~'e)))))


(def {:macro :true} assert-compilation-error
  (fn* [&form &env expected actual]
    `(try*
       (try*
         (let* [actual-val# ~actual]
           (fail
            "assertion failed: " ~(pr-str actual)
            " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
            " actual value: " (pr-str actual-val#)))
         (catch* CompilationError ~'e
           (when (not (= ~expected (~'.-msg ~'e)))
             (fail "assertion failed: " ~(pr-str actual)
                   " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
                   " actual exception: " ~'e))))
       (catch* Exception ~'e
         (fail "assertion failed: " ~(pr-str actual)
               " expected to throw " ~(pr-str CompilationError) " with message " ~(pr-str expected)
               " actual exception: " ~'e)))))

(def main
  (fn* main []
    (do
      (loop* [tests (seq @tests)]
        (if tests
          (do
            (reset! current-test ((first tests) 0))
            (((first tests) 1))
            (recur (next tests)))))
      (print "ok:" (- (count @tests) (count @failed-tests)))
      (if (< 0 (count @failed-tests))
        (print " failed:" (count @failed-tests)))
      (println)
      (if (= 0 (count @failed-tests)) 0 1))))


(deftest cast
  (let [x "abc"]
    (assert (identical? x (cast UTF8String x))))
  (let [x 10]
    (assert (identical? x (cast Int64 x))))
  (let [x '(1 2 3)]
    (assert (identical? x (cast List x))))
  (assert-throws CastError (cast Int64 "abc"))
  (assert-throws CastError (cast List [1 2]))
  (assert-throws CastError (cast List nil)))


(deftest addition
  (assert= 0 (+))
  (assert= 7 (+ 7))
  (assert= 27 (+ 7 20))
  (assert= 123 (+ 100 20 3)))


(deftest deftype
  (assert= '(do
              (def {:const :true} Xyz (cleo.core/type* 'Xyz '[a b c] [nil nil nil]))
              (cleo.core/defn ->Xyz {:const :true} [a b c] (cleo.core/new Xyz a b c)) Xyz)
           (macroexpand '(deftype Xyz [a b c])))
  (assert= '(do
              (def {:const :true} Xyz (cleo.core/type* 'Xyz '[] []))
              (cleo.core/defn ->Xyz {:const :true} []  (cleo.core/new Xyz)) Xyz)
           (macroexpand '(deftype Xyz [])))
  (assert= '(do
              (def {:const :true} Xyz (cleo.core/type* 'Xyz '[a b c] [Int64 nil UTF8String]))
              (cleo.core/defn ->Xyz {:const :true} [a b c] (cleo.core/new Xyz a b c)) Xyz)
           (macroexpand '(deftype Xyz [(a Int64) b (c UTF8String)]))))


(deftest defmulti
  (assert= '(def abc (cleo.core/multi* 'cleo.core.run/abc (fn* [x] x) :default)) (macroexpand '(defmulti abc (fn* [x] x))))
  (assert= '(def abc (cleo.core/multi* 'cleo.core.run/abc (fn* [x] x) 7)) (macroexpand '(defmulti abc (fn* [x] x) :default 7))))


(deftest defmethod
  (assert= '(cleo.core/defmethod* abc 10 (cleo.core/fn [x y] (x y))) (macroexpand '(defmethod abc 10 [x y] (x y))))
  (assert= '(cleo.core/defmethod* abc 10 (cleo.core/fn ([x] x) ([x y] (x y)))) (macroexpand '(defmethod abc 10 ([x] x) ([x y] (x y))))))


(deftest defmacro
  (assert= '(def {:macro :true, :arglists '([x]), :source-form '(defmacro sonia [x] (a) (b) (c))} sonia (fn* sonia [&form &env x] (do (a) (b) (c))))
           (macroexpand '(defmacro sonia [x] (a) (b) (c))))
  (assert= '(def {:macro :true, :arglists '([] [x] [a b]), :source-form '(defmacro sonia ([] 1) ([x] 2) ([a b] 3))} sonia (fn* sonia ([&form &env] 1) ([&form &env x] 2) ([&form &env a b] 3)))
           (macroexpand '(defmacro sonia ([] 1) ([x] 2) ([a b] 3))))
  (assert= '(def {:macro :true, :arglists '([x]), :source-form '(defmacro sonia [x] (a))} sonia (fn* sonia [&form &env x] (a)))
           (macroexpand '(defmacro sonia [x] (a))))
  (assert= '(def {:macro :true, :arglists '([x]), :source-form '(defmacro sonia [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia [x])))
  (assert= '(def {:doc "some", :macro :true, :arglists '([x]), :source-form '(defmacro sonia "some" [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia "some" [x])))
  (assert= '(def {:const :true, :macro :true, :arglists '([x]), :source-form '(defmacro sonia {:const :true} [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia {:const :true} [x])))
  (assert= '(def {:const :true, :doc "some", :macro :true, :arglists '([x]), :source-form '(defmacro sonia "some" {:const :true} [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia "some" {:const :true} [x])))
  (assert= '(def {:const :true, :doc "better", :macro :true, :arglists '([x]), :source-form '(defmacro sonia "some" {:const :true, :doc "better"} [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia "some" {:const :true, :doc "better"} [x])))
  (assert= '(def {:macro :true, :arglists '([x]), :source-form '(defmacro sonia {:macro false} [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia {:macro false} [x])))
  (assert= '(def {:macro :true, :arglists '([1 2 3]), :source-form '(defmacro sonia {:arglists '([1 2 3])} [x])} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia {:arglists '([1 2 3])} [x])))
  (assert= '(def {:macro :true, :arglists '([x]), :source-form :custom} sonia (fn* sonia [&form &env x]))
           (macroexpand '(defmacro sonia {:macro false, :source-form :custom} [x]))))


(deftest let
  (assert= '(let* [a 1 b 2] (do (x) (y))) (macroexpand '(let [a 1 b 2] (x) (y))))
  (assert= '(let* [a 1 b 2] (x)) (macroexpand '(let [a 1 b 2] (x))))
  (assert= '(let* [a 1 b 2] nil) (macroexpand '(let [a 1 b 2]))))


(deftest let-destructuring
  (assert= nil ((fn* [v] (let [[] v] nil)) [:a :b :c]))
  (assert= :a ((fn* [v] (let [[x] v] x)) [:a :b :c]))
  (assert= nil ((fn* [v] (let [[x] v] x)) []))
  (assert= '(:a :b) ((fn* [v] (let [[x y] v] (list x y))) [:a :b :c]))
  (assert= '(:a :b :a :b :c) ((fn* [v] (let [[x y :as [z w u]] v] (list x y z w u))) [:a :b :c]))
  (assert= '(:a :b :c) ((fn* [v] (let [[x y z] v] (list x y z))) [:a :b :c]))
  (assert= '(:a :b :c (:a :b :c)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a :b :c]))
  (assert= '(:a nil nil (:a)) ((fn* [v] (let [[x y z :as vn] v] (list x y z vn))) [:a]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b :c]))
  (assert= '(:a [:b :c]) ((fn* [v] (let [[x & y] v] (list x y))) '(:a :b :c)))
  (assert= '(:a :b :c :d) ((fn* [v] (let [[x y & [z w]] v] (list x y z w))) [:a :b :c :d]))
  (assert= '(:a :b :c :d) ((fn* [v] (let [[x y & [z w]] v] (list x y z w))) '(:a :b :c :d)))
  (assert= '(:a [:b :c] [:a :b :c]) ((fn* [v] (let [[x & y :as vn] v] (list x y vn))) '(:a :b :c)))
  (assert= '(:a [:b]) ((fn* [v] (let [[x & y] v] (list x y))) [:a :b]))
  (assert= '(:a nil) ((fn* [v] (let [[x & y] v] (list x y))) [:a]))
  (assert= '(:a :b :c nil) ((fn* [v] (let [[[x1 x2] [y1 y2]] v] (list x1 x2 y1 y2))) [[:a :b] [:c]]))
  (assert= '(:a :b :c) ((fn* [v] (let [[[x [y z]]] v] (list x y z))) [[:a [:b :c]]]))

  (assert= '() ((fn* [m] (let [{} m] [])) {:a 10 :b 20}))
  (assert= '(10) ((fn* [m] (let [{x :a} m] [x])) {:a 10 :b 20}))
  (assert= '(10 20) ((fn* [m] (let [{x :a y :b} m] [x y])) {:a 10 :b 20}))
  (assert= '(10 20 nil) ((fn* [m] (let [{x :a y :b z :c} m] [x y z])) {:a 10 :b 20}))

  (assert= '(17 20) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {:b 20}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) {}))
  (assert= '(17 27) ((fn* [m] (let [{x :a y :b :or {x 17 y 27}} m] [x y])) nil))
  (assert= '(nil 27) ((fn* [m] (let [{x :a y :b :or {y 27}} m] [x y])) {}))
  (assert= '(10 nil) ((fn* [m] (let [{x :a y :b :or nil} m] [x y])) {:a 10}))

  (assert= '(10 20 {:a 10 :b 20}) ((fn* [m] (let [{x :a y :b :as z} m] [x y z])) {:a 10 :b 20}))
  (assert= '(nil) ((fn* [m] (let [{:as z} m] [z])) nil))

  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:keys [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:keys [a]} m] [a])) {:a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:keys [a b c]} m] [a b c])) {:a 10 :b 20 :c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {:a 10 :c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:keys [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:syms [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:syms [a]} m] [a])) {'a 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:syms [a b c]} m] [a b c])) {'a 10 'b 20 'c 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {'a 10 'c 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:syms [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) nil))
  (assert= '(nil) ((fn* [m] (let [{:strs [a]} m] [a])) {}))
  (assert= '(10) ((fn* [m] (let [{:strs [a]} m] [a])) {"a" 10}))
  (assert= '(10 20 30) ((fn* [m] (let [{:strs [a b c]} m] [a b c])) {"a" 10 "b" 20 "c" 30}))
  (assert= '(10 27 30) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) {"a" 10 "c" 30}))
  (assert= '(17 27 37) ((fn* [m] (let [{:strs [a b c] :or {a 17 b 27 c 37}} m] [a b c])) nil))

  (assert= '(10 20 30 40) ((fn* [m] (let [{x :d :keys [a] :syms [b] :strs [c]} m] [a b c x])) {:a 10 'b 20 "c" 30 :d 40}))

  (assert= '(10 20 30 40) ((fn* [v] (let [[{:keys [a b]} {:syms [c d]}] v] [a b c d])) [{:a 10 :b 20} {'c 30 'd 40}]))

  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {}))
  (assert= '(nil nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a []}))
  (assert= '(10 nil) ((fn* [m] (let [{[x y] :a} m] [x y])) {:a [10]}))
  (assert= '(10 20) ((fn* [m] (let [{[x y] :a :or {[x y] [10 20]}} m] [x y])) {}))

  (assert= '(10 20) ((fn* [m] (let [{{:keys [b c]} :a} m] [b c])) {:a {:b 10 :c 20}}))

  (assert-throws IllegalArgument (macroexpand '(let [[x & y z] v] nil)))
  (assert-throws IllegalArgument (macroexpand '(let [10 v] nil)))
  (assert-throws IllegalArgument (macroexpand '(let [{:keys [10]} x] 0))))


(deftest fn
  (assert= '(fn* []) (macroexpand '(fn [])))
  (assert= '(fn* [] 10) (macroexpand '(fn [] 10)))
  (assert= '(fn* [a b] (do (x) (y))) (macroexpand '(fn [a b] (x) (y))))
  (assert= '(fn* abc [a b] (do (x) (y))) (macroexpand '(fn abc [a b] (x) (y))))
  (assert= '(fn* [a b] (x)) (macroexpand '(fn [a b] (x))))
  (assert= '(fn* abc [a b] (x)) (macroexpand '(fn abc [a b] (x))))
  (assert= '(fn* [a b]) (macroexpand '(fn [a b])))
  (assert= '(fn* abc [a b]) (macroexpand '(fn abc [a b])))
  (assert= '(fn* ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* abc ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn abc ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* ([a b] (do (x) (y))) ([z])) (macroexpand '(fn ([a b] (x) (y)) ([z])))))


(deftest fn-destructuring
  (assert= [:a :b] ((fn [[x y]] [y x]) [:b :a]))
  (assert= [:a :b] ((fn [[x] [y]] [y x]) [:b] [:a]))
  (assert= [:a :b] ((fn [{:keys [x y]}] [y x]) {:x :b :y :a}))
  (assert= [:a :b] ((fn [x & [y]] [y x]) :b :a)))


(deftest loop
  (assert= '(loop* [a 1 b 2] (do (x) (y))) (macroexpand '(loop [a 1 b 2] (x) (y))))
  (assert= '(loop* [a 1 b 2] (x)) (macroexpand '(loop [a 1 b 2] (x))))
  (assert= '(loop* [a 1 b 2] nil) (macroexpand '(loop [a 1 b 2]))))


(deftest loop-destructuring
  (assert= [:b :a] ((fn* [v] (loop [[x y] v] [y x])) [:a :b :c]))
  (assert= :c ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b :c]))
  (assert= :b ((fn* [v] (loop [[x y :as all] v] (if y (recur (next all)) x))) [:a :b nil :c]))
  (assert= [:c 7] ((fn* [v u] (loop [[v0 v1 :as allv] v [u0 u1 :as allu] u] (if v1 (recur (next allv) (next allu)) [v0 u0]))) [:a :b :c] [4 5 7]))
  (assert= [:b [5 6 7]] ((fn* [v u] (loop [[x y :as all] v u u] (if y (recur (next all) (next u)) [x u]))) [:a :b nil :c] [4 5 6 7])))


(deftest defn
  (assert= '(def {:arglists '([a b]), :source-form '(defn abc [a b] (x) (y))} abc (cleo.core/fn abc [a b] (x) (y)))
           (macroexpand '(defn abc [a b] (x) (y))))
  (assert= '(def {:arglists '([] [x] [a b]), :source-form '(defn abc ([] 1) ([x] 2) ([a b] 3))} abc (cleo.core/fn abc ([] 1) ([x] 2) ([a b] 3)))
           (macroexpand '(defn abc ([] 1) ([x] 2) ([a b] 3))))
  (assert= '(def {:arglists '([x]), :doc "some", :source-form '(defn abc "some" [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn abc "some" [x] y)))
  (assert= '(def {:arglists '([x]), :const :true, :source-form '(defn abc {:const :true} [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn abc {:const :true} [x] y)))
  (assert= '(def {:arglists '([x]), :const :true, :doc "some", :source-form '(defn abc "some" {:const :true} [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn abc "some" {:const :true} [x] y)))
  (assert= '(def {:arglists '([x]), :const :true, :doc "better doc", :source-form '(defn abc "some" {:const :true, :doc "better doc"} [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn abc "some" {:const :true, :doc "better doc"} [x] y)))
  (assert= '(def {:arglists '([1 2 3]), :source-form '(defn abc {:arglists '([1 2 3])} [a b])} abc (cleo.core/fn abc [a b]))
           (macroexpand '(defn abc {:arglists '([1 2 3])} [a b])))
  (assert= '(def {:arglists '([x]), :source-form :custom} abc (cleo.core/fn abc [x] x))
           (macroexpand '(defn abc {:source-form :custom} [x] x))))


(deftest defn-
  (assert= '(def {:private :true, :arglists '([a b]), :source-form '(defn- abc [a b] (x) (y))} abc (cleo.core/fn abc [a b] (x) (y)))
           (macroexpand '(defn- abc [a b] (x) (y))))
  (assert= '(def {:private :true, :arglists '([x]) :doc "some", :source-form '(defn- abc "some" [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn- abc "some" [x] y)))
  (assert= '(def {:private :true, :arglists '([x]) :const :true, :source-form '(defn- abc {:const :true} [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn- abc {:const :true} [x] y)))
  (assert= '(def {:private :true, :arglists '([x]) :const :true, :doc "some", :source-form '(defn- abc "some" {:const :true} [x] y)} abc (cleo.core/fn abc [x] y))
           (macroexpand '(defn- abc "some" {:const :true} [x] y)))
  (assert= '(def {:private :true, :arglists '([x]), :source-form '(defn- abc {:private 10} [x])} abc (cleo.core/fn abc [x]))
           (macroexpand '(defn- abc {:private 10} [x])))
  (assert= '(def {:private :true, :arglists '([x]), :source-form :custom} abc (cleo.core/fn abc [x] x))
           (macroexpand '(defn- abc {:source-form :custom, :private 10} [x] x))))


(defn df-example1 [[x y]] [y x])
(defn df-example2 [[x] [y]] [y x])
(defn df-example3 [{:keys [x y]}] [y x])


(deftest defn-destructuring
  (assert= [:a :b] (df-example1 [:b :a]))
  (assert= [:a :b] (df-example2 [:b] [:a]))
  (assert= [:a :b] (df-example3 {:x :b :y :a})))


(defmacro dm-example1 [[x y z]] (list y x z))
(defmacro dm-example2 [{:keys [op vals]}] (conj vals op))


(deftest defmacro-destructuring
  (assert= 30 (dm-example1 [10 + 20]))
  (assert= 33 (dm-example2 {:op + :vals (11 22)})))


(deftest not
  (assert= nil (not 10))
  (assert= nil (not [1]))
  (assert= :true (not nil)))


(deftest or
  (assert= nil (or))
  (assert= 10 (or 10))
  (assert= nil (or nil))
  (assert= :x (or nil :x))
  (assert= :x (or :x :y))
  (assert= nil (or nil nil))
  (assert= :x (or nil nil :x))
  (assert= :y (or nil :y :x))
  (assert= :a (or :a nil :x))
  (assert= nil (or nil nil nil)))


(deftest and
  (assert= :true (and))
  (assert= 10 (and 10))
  (assert= nil (and nil))
  (assert= nil (and nil :x))
  (assert= nil (and :x nil))
  (assert= :y (and :x :y))
  (assert= nil (and nil nil))
  (assert= nil (and nil nil :x))
  (assert= nil (and nil :y :x))
  (assert= nil (and :a nil :x))
  (assert= :d (and :a :b :c :d)))


(deftest seq?
  (assert (seq? ()))
  (assert (seq? (list 1 2)))
  (assert (not (seq? nil)))
  (assert (not (seq? [1 2])))
  (assert (seq? (seq [1 2])))
  (assert (not (seq? #{1 2})))
  (assert (not (seq? {1 2})))
  (assert (not (seq? 10))))


(deftest when
  (assert= '(if x (do)) (macroexpand '(when x)))
  (assert= '(if x (do y)) (macroexpand '(when x y)))
  (assert= '(if x (do y z)) (macroexpand '(when x y z))))


(deftest cond
  (assert= nil (macroexpand '(cond)))
  (assert= `(if (~'= 1 2) (~'= 3 4) (cond)) (macroexpand '(cond (= 1 2) (= 3 4))))
  (assert= `(if :a :b (cond :c :d)) (macroexpand '(cond :a :b :c :d)))
  (assert-throws IllegalArgument (macroexpand '(cond :a))))


(deftest bit-and
  (assert= (bit-and* 12345 54321) (bit-and 12345 54321))
  (assert= (bit-and* (bit-and* 12345 54321) 97553) (bit-and 12345 54321 97553))
  (assert= (bit-and* (bit-and* (bit-and* 12345 54321) 97553) 57753) (bit-and 12345 54321 97553 57753)))


(deftest bit-or
  (assert= (bit-or* 12345 54321) (bit-or 12345 54321))
  (assert= (bit-or* (bit-or* 12345 54321) 97553) (bit-or 12345 54321 97553))
  (assert= (bit-or* (bit-or* (bit-or* 12345 54321) 97553) 57753) (bit-or 12345 54321 97553 57753)))


(deftest bit-xor
  (assert= (bit-xor* 12345 54321) (bit-xor 12345 54321))
  (assert= (bit-xor* (bit-xor* 12345 54321) 97553) (bit-xor 12345 54321 97553))
  (assert= (bit-xor* (bit-xor* (bit-xor* 12345 54321) 97553) 57753) (bit-xor 12345 54321 97553 57753)))


(deftest bit-and-not
  (assert= (bit-and-not* 12345 54321) (bit-and-not 12345 54321))
  (assert= (bit-and-not* (bit-and-not* 12345 54321) 97553) (bit-and-not 12345 54321 97553))
  (assert= (bit-and-not* (bit-and-not* (bit-and-not* 12345 54321) 97553) 57753) (bit-and-not 12345 54321 97553 57753)))


(deftest even?
  (assert (even? 10))
  (assert-not (even? 11))
  (assert (even? -10))
  (assert-not (even? -11)))


(deftest odd?
  (assert (odd? 11))
  (assert-not (odd? 10))
  (assert (odd? -11))
  (assert-not (odd? -10)))


(deftest conj
  (assert= [] (conj))
  (assert= [10 20] (conj [10 20]))
  (assert= [10 20 30] (conj [10 20] 30))
  (assert= [10 20 30 40] (conj [10 20] 30 40))
  (assert= [10 20 30 40 50] (conj [10 20] 30 40 50))
  (assert= [10 20 nil nil] (conj [10 20] nil nil))
  (assert= nil (conj nil))
  (assert= '(20 10) (conj nil 10 20))
  (assert= '(nil) (conj nil nil)))


(deftest assoc
  (assert= {:a 1 :b 2} (assoc {:a 1} :b 2))
  (assert= {:a 1 :b 2 :c 3} (assoc {:a 1} :b 2 :c 3))
  (assert= {:a 1 :b 2 :c 3 :d 4} (assoc {:a 1} :b 2 :c 3 :d 4))
  (assert= {:a 1 :b 2} (assoc nil :a 1 :b 2))
  (assert-throws IllegalArgument (assoc {} :a 1 :b)))


(deftest dissoc
  (assert= {:a 1 :b 2} (dissoc {:a 1 :b 2}))
  (assert= {:a 1} (dissoc {:a 1 :b 2} :b))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3} :b :c))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3 :d 4} :b :c :d))
  (assert= nil (dissoc nil))
  (assert= nil (dissoc nil :a)))


(deftest every?
  (assert (every? odd? nil))
  (assert (every? odd? []))
  (assert (every? odd? [1 3 5]))
  (assert-not (every? odd? [2 3 5]))
  (assert-not (every? odd? [1 2 5]))
  (assert-not (every? odd? [1 3 2])))


(deftest some
  (let [pred (fn [x] (and (even? x) (pr-str x)))]
    (assert= nil (some pred nil))
    (assert= nil (some pred []))
    (assert= nil (some pred [1 3 5]))
    (assert= "4" (some pred [4 3 5]))
    (assert= "8" (some pred [1 8 5]))
    (assert= "10" (some pred [1 3 10]))))


(deftest if-let
  (assert= :a (if-let [x (seq [:a])] (first x)))
  (assert= nil (if-let [x (seq [])] (first x)))
  (assert= :a (if-let [x (seq [:a])] (first x) :b))
  (assert= :b (if-let [x (seq [])] (first x) :b)))


(deftest when-let
  (assert= nil (when-let [x (seq [:a])]))
  (assert= :a (when-let [x (seq [:a])] (+ 1 2) (first x)))
  (assert= nil (when-let [x (seq [])] (+ 1 2) (first x))))


(deftest partition-kv
  (assert= () (#'cleo.core/partition-kv []))
  (assert= [[nil :b]] (#'cleo.core/partition-kv [nil :b]))
  (assert= [[:a nil]] (#'cleo.core/partition-kv [:a nil]))
  (assert= [[:a :b]] (#'cleo.core/partition-kv [:a :b :c]))
  (assert= [[:a :b]] (#'cleo.core/partition-kv [:a :b nil]))
  (assert= [[:a :b] [:c :d]] (#'cleo.core/partition-kv [:a :b :c :d]))
  (assert= [[:a :b] [:c nil]] (#'cleo.core/partition-kv [:a :b :c nil]))
  (assert= [[:a :b] [:c nil]] (#'cleo.core/partition-kv [:a :b :c nil :e])))


(deftest reduce
  (assert= "" (reduce str nil))
  (assert= "" (reduce str []))
  (assert= 10 (reduce str [10]))
  (assert= "102030" (reduce str [10 20 30]))
  (assert= [[30 20] 10] (reduce list [30 20 10]))
  (assert= 100 (reduce + 100 nil))
  (assert= 100 (reduce + 100 []))
  (assert= 110 (reduce + 100 [10]))
  (assert= 160 (reduce + 100 [10 20 30]))
  (assert= [[30 20] 10] (reduce list 30 [20 10])))


(deftest concati
  (assert= [] (concati))
  (assert= [:a :b] (concati [:a :b]))
  (assert= [:a :b :c :d] (concati [:a :b] [:c :d]))
  (assert= [:a :b] (concati [] '(:a :b)))
  (assert= [:a :b] (concati () [:a :b]))
  (assert= [:a :b] (concati [:a :b] []))
  (assert= [:a :b :c :d :e :f] (concati [:a :b] [:c :d] [:e :f]))
  (assert= [:a :b :c :d :e :f] (concati '(:a :b) () '(:c) [:d] '(:e :f) [])))


(deftest dotimes
  (assert= [0 1 2 3 4]
           (let [v (atom [])]
             (dotimes [i 5] (swap! v conj i))
             @v))
  (assert-not (let [called? (atom nil)]
                (dotimes [i 0] (reset! called? :true))
                @called?)))


(deftest doseq
  (assert= [:c :b :a]
           (let [l (atom ())]
             (doseq [x [:a :b :c]] (swap! l conj x))
             @l))
  (assert-not (let [called? (atom nil)]
                (doseq [x nil] (reset! called? :true))
                @called?))
  (assert-not (let [called? (atom nil)]
                (doseq [x []] (reset! called? :true))
                @called?)))


(deftest map
  (assert= () (map inc nil))
  (assert= () (map inc []))
  (assert= '(11) (map inc [10]))
  (assert= '(9 7 2) (map dec [10 8 3])))


(deftest mapv
  (assert= [] (mapv inc nil))
  (assert= [] (mapv inc []))
  (assert= [11] (mapv inc [10]))
  (assert= [9 7 2] (mapv dec [10 8 3])))


(deftest filter
  (assert= () (filter even? nil))
  (assert= () (filter even? []))
  (assert= '(4 10) (filter even? [1 3 4 7 10]))
  (assert= () (filter zero? [1 3 4 7 10]))
  (assert= '(10) (filter even? [10]))
  (assert= () (filter odd? [10])))


(deftest drop
  (assert= () (drop 5 nil))
  (assert= '(:a :b :c :d) (drop -5 [:a :b :c :d]))
  (assert= '(:a :b :c :d) (drop 0 [:a :b :c :d]))
  (assert= '(:b :c :d) (drop 1 [:a :b :c :d]))
  (assert= '(:d) (drop 3 [:a :b :c :d]))
  (assert= () (drop 6 [:a :b :c :d])))


(deftest take
  (assert= () (take -1 [:a]))
  (assert= () (take 0 [:a]))
  (assert= () (take 1 nil))
  (assert= () (take 1 []))
  (assert= '(:a :b) (take 3 [:a :b]))
  (assert= '(:a :b :c) (take 3 [:a :b :c]))
  (assert= '(:a :b :c) (take 3 [:a :b :c :d :e]))
  (assert= '(:a :b :c) (take 3 '(:a :b :c :d :e))))


(deftest iterate
  (assert= '(10 11 12) (take 3 (iterate inc 10)))
  (assert= '(7 6 5) (take 3 (iterate dec 7))))


(deftest cycle
  (assert= '() (cycle []))
  (assert= '(7) (take 1 (cycle [7])))
  (assert= '(3) (take 1 (cycle [3 4 5])))
  (assert= '(3 4) (take 2 (cycle [3 4 5])))
  (assert= '(3 4 5) (take 3 (cycle [3 4 5])))
  (assert= '(7 7 7) (take 3 (cycle [7])))
  (assert= '(3 4 5 3 4) (take 5 (cycle [3 4 5])))
  (assert= '(3 4 5 3 4 5 3 4 5) (take 9 (cycle [3 4 5]))))


(deftest ns
  (assert= '(do (cleo.core/in-ns 'some.thing nil) (cleo.core/refer 'cleo.core)) (macroexpand '(ns some.thing)))
  (assert= '(do (cleo.core/in-ns 'abc nil) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc nil) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]) (cleo.core/require '[zzz] '[nnn]))
           (macroexpand '(ns abc (:require [xyz] [rst]) (:require [zzz] [nnn]))))
  (assert= '(do (cleo.core/in-ns 'abc {:doc "some"}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc "some" (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc {:x :y}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc {:x :y} (:require [xyz] [rst]))))
  (assert= '(do (cleo.core/in-ns 'abc {:x :y :doc "some"}) (cleo.core/refer 'cleo.core) (cleo.core/require '[xyz] '[rst]))
           (macroexpand '(ns abc "some" {:x :y} (:require [xyz] [rst])))))


(deftest update
  (assert= {:abc 31 :xyz 12} (update {:abc 30 :xyz 12} :abc inc)))


(deftest ->
  (assert= 'x (macroexpand '(-> x)))
  (assert= '(f0 x) (macroexpand '(-> x f0)))
  (assert= '(f0 x a b) (macroexpand '(-> x (f0 a b))))
  (assert= '(f2 (f1 (f0 x))) (macroexpand '(-> x f0 f1 f2)))
  (assert= '(f1 (f0 x a) b c) (macroexpand '(-> x (f0 a) (f1 b c)))))


(deftest ->>
  (assert= 'x (macroexpand '(->> x)))
  (assert= '(f0 x) (macroexpand '(->> x f0)))
  (assert= '(f0 a b x) (macroexpand '(->> x (f0 a b))))
  (assert= '(f2 (f1 (f0 x))) (macroexpand '(->> x f0 f1 f2)))
  (assert= '(f1 b c (f0 a x)) (macroexpand '(->> x (f0 a) (f1 b c)))))


(deftest empty?
  (assert (empty? nil))
  (assert (empty? []))
  (assert-not (empty? [1]))
  (assert (empty? ()))
  (assert-not (empty? '(1)))
  (assert (empty? {}))
  (assert-not (empty? {1 2})))


(deftest max
  (assert= 10 (max 10))
  (assert= 20 (max 10 20))
  (assert= 10 (max 10 0))
  (assert= 3 (max 1 2 3))
  (assert= 3 (max 3 1 2))
  (assert= 4 (max 3 1 2 4)))


(deftest min
  (assert= 10 (min 10))
  (assert= 10 (min 10 20))
  (assert= 0 (min 10 0))
  (assert= 1 (min 1 2 3))
  (assert= 1 (min 3 1 2))
  (assert= 1 (min 3 4 2 1)))


(deftest peek
  (assert= nil (peek []))
  (assert= 4 (peek [4]))
  (assert= 2 (peek [3 2]))
  (assert= nil (peek '()))
  (assert= 4 (peek '(4)))
  (assert= 3 (peek '(3 2)))
  (assert= nil (peek (transient [])))
  (assert= 4 (peek (transient [4])))
  (assert= 2 (peek (transient [3 2]))))


(deftest sort
  (assert= [] (sort < nil))
  (assert= [] (sort < []))
  (assert= [1] (sort < '(1)))
  (assert= [4 3 1] (sort > '(1 4 3)))
  (assert= [1 3 4] (sort < '(4 3 1)))
  (assert= [1 3 4] (sort '(4 3 1))))


(deftest parse-const
  (assert= 10 (cc/parse 10))
  (assert= 3.5 (cc/parse 3.5))
  (assert= "abc" (cc/parse "abc"))
  (assert= :abc (cc/parse :abc))
  (assert= nil (cc/parse nil))
  (assert= () (cc/parse ()))
  (assert= {:tag :const, :value {:a 10}} (cc/parse {:a 10})))


(deftest parse-var
  (assert= {:tag :var, :name 'abc} (cc/parse 'abc)))


(deftest parse-if
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else nil} (cc/parse '(if c a)))
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else nil} (cc/parse '(if c a nil)))
  (assert= {:tag :if, :cond {:tag :var, :name 'c}, :then {:tag :var, :name 'a}, :else {:tag :var, :name 'b}} (cc/parse '(if c a b))))


(deftest parse-call
  (assert= {:tag :call, :fn [7], :args []} (cc/parse '([7])))
  (assert= {:tag :call, :fn {:tag :var, :name 'f}, :args [10 {:tag :var, :name 'x}]} (cc/parse '(f 10 x))))


(deftest parse-quote
  (assert= 10 (cc/parse ''10))
  (assert= '(10 20) (cc/parse ''(10 20)))
  (assert= {:tag :const, :value {:a :b}} (cc/parse ''{:a :b})))


(deftest parse-do
  (assert= {:tag :do, :exprs []} (cc/parse '(do)))
  (assert= {:tag :do, :exprs [{:tag :var, :name 'x}]} (cc/parse '(do x)))
  (assert= {:tag :do, :exprs [{:tag :var, :name 'x} {:tag :var, :name 'y}]} (cc/parse '(do x y))))


(deftest parse-let
   (assert= {:tag :let, :locals [], :exprs []} (cc/parse '(let* [])))
   (assert= {:tag :let, :locals [], :exprs [nil]} (cc/parse '(let* [] nil)))
   (assert= {:tag :let, :locals [], :exprs [{:tag :var, :name 'a} 10]} (cc/parse '(let* [] a 10)))
   (assert= {:tag :let, :locals [{:name 'a, :index 0, :expr 10}], :exprs []} (cc/parse '(let* [a 10])))
   (assert= {:tag :let, :locals [{:name 'a, :index 0, :expr 10}
                                 {:name 'b, :index 1, :expr 20}
                                 {:name 'c, :index 2, :expr 30}], :exprs []} (cc/parse '(let* [a 10 b 20 c 30])))
   (assert= [{:tag :local, :index 1} {:tag :local, :index 2} {:tag :local, :index 0}] (:exprs (cc/parse '(let* [a 10 b 20 c 30] b c a))))
   (let [let3 (cc/parse '(let* [a :x] (let* [b :y c :z] (let* [d :w]))))]
     (assert= [{:name 'a, :index 0, :expr :x}] (-> let3 :locals))
     (assert= [{:name 'b, :index 1, :expr :y} {:name 'c, :index 2, :expr :z}] (-> let3 :exprs first :locals))
     (assert= [{:name 'd, :index 3, :expr :w}] (-> let3 :exprs first :exprs first :locals)))
   (assert= {:tag :let
             :locals [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
                      {:name 'x, :index 1, :expr {:tag :local, :index 0}}
                      {:name 'x, :index 2, :expr {:tag :local, :index 1}}]
             :exprs [{:tag :local, :index 2}]} (cc/parse '(let* [x x x x x x] x)))
   (assert= [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
             {:name 'y, :index 1, :expr {:tag :var, :name 'y}}
             {:name 'x, :index 2, :expr {:tag :local, :index 1}}
             {:name 'y, :index 3, :expr {:tag :local, :index 2}}] (:locals (cc/parse '(let* [x x y y x y y x])))))


(deftest parse-loop
   (assert= {:tag :loop, :locals [], :exprs []} (cc/parse '(loop* [])))
   (assert= {:tag :loop, :locals [], :exprs [nil]} (cc/parse '(loop* [] nil)))
   (assert= {:tag :loop, :locals [], :exprs [{:tag :var, :name 'a} 10]} (cc/parse '(loop* [] a 10)))
   (assert= {:tag :loop, :locals [{:name 'a, :index 0, :expr 10}], :exprs []} (cc/parse '(loop* [a 10])))
   (assert= {:tag :loop, :locals [{:name 'a, :index 0, :expr 10}
                                 {:name 'b, :index 1, :expr 20}
                                 {:name 'c, :index 2, :expr 30}], :exprs []} (cc/parse '(loop* [a 10 b 20 c 30])))
   (assert= [{:tag :local, :index 1} {:tag :local, :index 2} {:tag :local, :index 0}] (:exprs (cc/parse '(loop* [a 10 b 20 c 30] b c a))))
   (let [loop3 (cc/parse '(loop* [a :x] (loop* [b :y c :z] (loop* [d :w]))))]
     (assert= [{:name 'a, :index 0, :expr :x}] (-> loop3 :locals))
     (assert= [{:name 'b, :index 1, :expr :y} {:name 'c, :index 2, :expr :z}] (-> loop3 :exprs first :locals))
     (assert= [{:name 'd, :index 3, :expr :w}] (-> loop3 :exprs first :exprs first :locals)))
   (assert= {:tag :loop
             :locals [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
                      {:name 'x, :index 1, :expr {:tag :local, :index 0}}
                      {:name 'x, :index 2, :expr {:tag :local, :index 1}}]
             :exprs [{:tag :local, :index 2}]} (cc/parse '(loop* [x x x x x x] x)))
   (assert= [{:name 'x, :index 0, :expr {:tag :var, :name 'x}}
             {:name 'y, :index 1, :expr {:tag :var, :name 'y}}
             {:name 'x, :index 2, :expr {:tag :local, :index 1}}
             {:name 'y, :index 3, :expr {:tag :local, :index 2}}] (:locals (cc/parse '(loop* [x x y y x y y x])))))


(deftest parse-def
  (assert= {:tag :def, :name 'x, :expr 10} (cc/parse '(def x 10)))
  (assert= {:tag :def, :name 'x, :expr nil} (cc/parse '(def x nil)))
  (assert= {:tag :def, :name 'x} (cc/parse '(def x)))
  (assert= {:tag :def, :name 'a/x, :expr 10} (cc/parse '(def a/x 10)))
  (assert= {:tag :def, :name 'xr, :expr {:tag :var, :name 'xr}} (cc/parse '(def xr xr)))
  (assert= {:tag :def, :name 'z, :meta {10 20}, :expr 13} (cc/parse '(def {10 20} z 13)))
  (assert= {:tag :def, :name 'z, :meta {10 20}} (cc/parse '(def {10 20} z))))


(deftest parse-throw
  (assert= {:tag :throw, :expr {:tag :var, :name 'x}} (cc/parse '(throw x))))


(deftest parse-dot
  (assert= {:tag :dot, :expr {:tag :var, :name 'x}, :member 'xf} (cc/parse '(. x -xf))))


(deftest parse-vector
  (assert= [] (cc/parse []))
  (assert= [5 6 7] (cc/parse [5 6 7]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [3 4]) x))) (cc/parse '[3 4 x]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/conj! (cleo.core/conj! (cleo.core/transient []) z) x) y))) (cc/parse '[z x y]))
  (assert= (cc/parse '(cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [2 4.0 "x" :k]) (f 3)))) (cc/parse '[2 4.0 "x" :k (f 3)]))
  (assert= [10 [20 30]] (cc/parse [10 [20 30]]))
  (assert= (cc/parse '(cleo.core/persistent!
                       (cleo.core/conj!
                        (cleo.core/transient [10])
                        (cleo.core/persistent! (cleo.core/conj! (cleo.core/transient [20]) x))))) (cc/parse '[10 [20 x]])))


(deftest parse-hash-set
  (assert= #{} (cc/parse #{}))
  (assert= #{5 6 7} (cc/parse #{5 6 7}))
  (assert= (cc/parse '(cleo.core/conj #{3 4} x)) (cc/parse '#{3 x 4}))
  (assert= (cc/parse '(cleo.core/conj (cleo.core/conj (cleo.core/conj #{} z) x) y)) (cc/parse '#{z x y}))
  (assert= (cc/parse '(cleo.core/conj #{2 4.0 "x" :k} (f 3))) (cc/parse '#{2 4.0 "x" (f 3) :k}))
  (assert= #{10 #{20 30}} (cc/parse #{10 #{20 30}}))
  (assert= (cc/parse '(cleo.core/conj #{10} (cleo.core/conj #{20} x))) (cc/parse '#{10 #{20 x}})))


(deftest parse-hash-map
  (assert= {:tag :const, :value {}} (cc/parse {}))
  (assert= {:tag :const, :value {5 6 7 8}} (cc/parse {5 6 7 8}))
  (assert= (cc/parse '(cleo.core/assoc {3 4 5 6} x y)) (cc/parse '{3 4 5 6 x y}))
  (assert= (cc/parse '(cleo.core/assoc {3 4} x 6)) (cc/parse '{3 4 x 6}))
  (assert= (cc/parse '(cleo.core/assoc {3 4} 5 x)) (cc/parse '{3 4 5 x}))
  (assert= {:tag :const, :value {{1 2} 3 4 {5 6}}} (cc/parse '{{1 2} 3 4 {5 6}}))
  (let [m2 (cc/parse '{3 4 5 x y 6})]
    (assert (or (= (cc/parse '(cleo.core/assoc (cleo.core/assoc {3 4} 5 x) y 6)) m2)
                (= (cc/parse '(cleo.core/assoc (cleo.core/assoc {3 4} y 6) 5 x)) m2))))
  (assert= (cc/parse '(cleo.core/assoc {1 2} 10 (cleo.core/assoc {} 20 x))) (cc/parse '{1 2 10 {20 x}}))
  (assert= (cc/parse '(cleo.core/assoc {1 2} (cleo.core/assoc {} x 20) 10)) (cc/parse '{1 2 {x 20} 10})))


(deftest parse-nested-structures
  (assert= [[10 20] [[30 [40]]]] (cc/parse [[10 20] [[30 [40]]]]))
  (assert= #{10 20 [30 40] #{50 #{} #{60}}} (cc/parse #{10 20 [30 40] #{50 #{} #{60}}}))
  (assert= [10 {20 {30 40}} #{50} [60]] (cc/parse [10 {20 {30 40}} #{50} [60]]))
  (assert= {:tag :const, :value {10 {20 {30 40}} #{50} [60]}} (cc/parse {10 {20 {30 40}} #{50} [60]})))


(deftest parse-let-with-other-forms
  (assert= [{:tag :if
             :cond {:tag :local, :index 1}
             :then {:tag :local, :index 2}
             :else {:tag :local, :index 0}}] (:exprs (cc/parse '(let* [x 10 y 20 z 30] (if y z x)))))
  (assert= [{:tag :do
             :exprs [{:tag :local, :index 1}
                     {:tag :local, :index 0}]}] (:exprs (cc/parse '(let* [x 10 y 20] (do y x)))))
  (assert= [{:tag :call
             :fn {:tag :local, :index 0}
             :args [{:tag :local, :index 1}]}] (:exprs (cc/parse '(let* [f 0 x 10] (f x)))))
  (assert= [{:tag :def
             :name 'x
             :meta {10 20}
             :expr {:tag :local, :index 1}}] (:exprs (cc/parse '(let* [x 1 y 2] (def {10 20} x y)))))
  (assert= [{:tag :throw
             :expr {:tag :local, :index 0}}] (:exprs (cc/parse '(let* [x 1] (throw x)))))
  (assert= [{:tag :dot
             :expr {:tag :local, :index 0}
             :member 'mz}] (:exprs (cc/parse '(let* [x 1] (. x -mz)))))
  (assert= (:exprs (cc/parse '(let* [x 1] (cleo.core/persistent! (cleo.core/conj! (cleo.core/transient []) x))))) (:exprs (cc/parse '(let* [x 1] [x]))))
  (assert= (:exprs (cc/parse '(let* [x 1] (cleo.core/conj #{} x)))) (:exprs (cc/parse '(let* [x 1] #{x}))))
  (assert= (:exprs (cc/parse '(let* [x 1 y 2] (cleo.core/assoc {3 4 5 6} x y)))) (:exprs (cc/parse '(let* [x 1 y 2] {3 4 5 6 x y}))))
  (assert= [{:tag :local, :index 0}] (:exprs (cc/parse '(let* [x 1] (try* x)))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :finally {:tag :local, :index 1}}] (:exprs (cc/parse '(let* [f 1 g 2] (try* f (finally* g))))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :catch {:type 'X, :local {:name 'x :index 2}, :expr {:tag :local, :index 1}}}]
           (:exprs (cc/parse '(let* [f 1 g 2] (try* f (catch* X x g))))))
  (assert= [{:tag :try, :expr {:tag :local, :index 0}, :catch {:type 'X, :local {:name 'x :index 2}, :expr {:tag :local, :index 2}}}]
           (:exprs (cc/parse '(let* [f 1 g 2] (try* f (catch* X x x))))))  )


(defmacro add-macro [x y] `(cleo.core/+ ~x ~y))


(deftest parse-macro
  (assert= (cc/parse '(cleo.core/+ (cleo.core/+ 1 2) (cleo.core/+ 3 4))) (cc/parse '(cleo.core.test/add-macro (cleo.core.test/add-macro 1 2) (cleo.core.test/add-macro 3 4)))))


(deftest parse-try
  (assert= nil (cc/parse '(try*)))
  (assert= {:tag :var, :name 'x} (cc/parse '(try* x))))


(deftest parse-try-catch
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :catch {:type 'X, :local {:name 'x :index 0}, :expr {:tag :var, :name 'g}}} (cc/parse '(try* f (catch* X x g))))
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :catch {:type 'X, :local {:name 'x :index 0}, :expr {:tag :local, :index 0}}} (cc/parse '(try* f (catch* X x x)))))


(deftest parse-try-finally
  (assert= {:tag :try, :expr {:tag :var, :name 'f}, :finally {:tag :var, :name 'g}} (cc/parse '(try* f (finally* g)))))


(deftest parse-fn
  (assert= {:tag :fn, :bodies []} (cc/parse '(fn*)))
  (assert= {:tag :fn, :name 'abc, :name-index 0, :bodies []} (cc/parse '(fn* abc)))
  (assert= {:tag :fn, :bodies [{:params [] :expr nil}]} (cc/parse '(fn* [])))
  (assert= {:tag :fn, :name 'abc, :name-index 0, :bodies [{:params [] :expr nil}]} (cc/parse '(fn* abc [])))
  (assert= [{:params [] :expr {:tag :var, :name 'f}}] (:bodies (cc/parse '(fn* [] f))))
  (assert= [{:params [] :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* f [] f))))
  (assert= [{:params [{:name 'x, :index 0}], :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [x] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [x y] x))))
  (assert= [{:params [{:name 'x, :index 1} {:name 'y, :index 2}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* f [x y] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y] y))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y &] y))))
  (assert= [{:params [{:name 'x, :index 0}], :vararg :true, :expr {:tag :local, :index 0}}] (:bodies (cc/parse '(fn* [& x] x))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :vararg :true, :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x & y] y))))
  (assert-no-exception (cc/parse '(fn* ([x] nil) ([x & xs] nil))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1} {:name 'z, :index 2}], :vararg :true, :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* [x y & z] y))))
  (assert= [{:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}] (:bodies (cc/parse '(fn* ([x y] y)))))
  (assert= 'abc (:name (cc/parse '(fn* abc ([x y] y)))))
  (assert= [{:params [{:name 'z, :index 0}], :expr {:tag :local, :index 0}}
            {:params [{:name 'x, :index 0} {:name 'y, :index 1}], :expr {:tag :local, :index 1}}]
           (:bodies (cc/parse '(fn* ([z] z) ([x y] y)))))
  (assert= {:params [{:name 'a, :index 0} {:name 'b, :index 1}]
            :expr {:tag :fn
                   :bodies [{:params [{:name 'a, :index 2} {:name 'c, :index 3}]
                             :expr {:tag :do
                                    :exprs [{:tag :local, :index 2}
                                            {:tag :local, :index 1}
                                            {:tag :local, :index 3}]}}]}}
           (-> (cc/parse '(fn* [a b] (fn* [a c] (do a b c)))) :bodies first))
  (assert= {:params [{:name 'a, :index 1}]
            :expr {:tag :fn
                   :name 'g
                   :name-index 2
                   :bodies [{:params [{:name 'b, :index 3}]
                             :expr {:tag :do
                                    :exprs [{:tag :local, :index 0}
                                            {:tag :local, :index 1}
                                            {:tag :local, :index 2}
                                            {:tag :local, :index 3}]}}]}}
           (-> (cc/parse '(fn* f [a] (fn* g [b] (do f a g b)))) :bodies first))
  (assert= {:tag :let
            :locals [{:name 'z, :index 1, :expr 10}]
            :exprs [{:tag :local, :index 1}]}
           (-> (cc/parse '(fn* [z] (let* [z 10] z))) :bodies first :expr))
  (assert= {:params [{:name 'z, :index 2}]
            :expr {:tag :do
                   :exprs [{:tag :local, :index 0} {:tag :local, :index 2}]}}
           (-> (cc/parse '(let* [x 10 z 20] (fn* [z] (do x z)))) :exprs first :bodies first)))


(deftest parse-recur
  (assert= {:tag :recur
            :args [{:tag :local, :index 1}
                   {:tag :local, :index 0}]}
           (-> (cc/parse '(fn* [a b] (recur b a))) :bodies first :expr))
  (assert= {:tag :recur
            :args [{:tag :local, :index 1}
                   {:tag :local, :index 2}]}
           (-> (cc/parse '(fn* [a b] (let [c 5] (recur b c)))) :bodies first :expr :exprs first))
  (assert-no-exception (cc/parse '(fn* [x] (do 10 (recur 20)))))
  (assert-no-exception (cc/parse '(fn* [x] (let* [c 0] 10 (recur 20)))))
  (assert-no-exception (cc/parse '(loop* [c 0] 10 (recur 20))))
  (assert-no-exception (cc/parse '(fn* [x] (if x (recur x) 1))))
  (assert-no-exception (cc/parse '(fn* [x] (if x 1 (recur x))))))


(deftest parse-errors
  (assert-compilation-error "Too few arguments to if" (cc/parse '(if)))
  (assert-compilation-error "Too few arguments to if" (cc/parse '(if 1)))
  (assert-compilation-error "Too many arguments to if" (cc/parse '(if 1 2 3 4 )))

  (assert-compilation-error "Wrong number of args (0) passed to quote, form: (quote)" (cc/parse '(quote)))
  (assert-compilation-error "Wrong number of args (2) passed to quote, form: (quote 10 \"20\")" (cc/parse '(quote 10 "20")))

  (assert-compilation-error "Wrong number of args (0) passed to let*, form: (let*)" (cc/parse '(let*)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(let* nil)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(let* ())))
  (assert-compilation-error "Bad binding form, expected matched symbol expression pairs" (cc/parse '(let* [a 10 b])))
  (assert-compilation-error "Unsupported binding form: 10" (cc/parse '(let* [10 20])))
  (assert-compilation-error "Can't let qualified name: x/a" (cc/parse '(let* [x/a 20])))

  (assert-compilation-error "Wrong number of args (0) passed to loop*, form: (loop*)" (cc/parse '(loop*)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(loop* nil)))
  (assert-compilation-error "Bad binding form, expected vector" (cc/parse '(loop* ())))
  (assert-compilation-error "Bad binding form, expected matched symbol expression pairs" (cc/parse '(loop* [a 10 b])))
  (assert-compilation-error "Unsupported binding form: 10" (cc/parse '(loop* [10 20])))
  (assert-compilation-error "Can't let qualified name: x/a" (cc/parse '(loop* [x/a 20])))

  (assert-compilation-error "Too few arguments to def" (cc/parse '(def)))
  (assert-compilation-error "Too few arguments to def" (cc/parse '(def {2 3})))
  (assert-compilation-error "Too many arguments to def" (cc/parse '(def x 10 30)))
  (assert-compilation-error "Too many arguments to def" (cc/parse '(def {} x 10 30)))
  (assert-compilation-error "First argument to def must be a Symbol" (cc/parse '(def 10 20)))
  (assert-compilation-error "First argument to def must be a Symbol" (cc/parse '(def 10 x)))

  (assert-compilation-error "Too few arguments to throw, expected a single value" (cc/parse '(throw)))
  (assert-compilation-error "Too many arguments to throw, expected a single value" (cc/parse '(throw 10 20)))

  (assert-compilation-error "Malformed member expression" (cc/parse '(. x y)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x 10)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x -)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(.)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x y)))
  (assert-compilation-error "Malformed member expression" (cc/parse '(. x -y 20)))

  (assert-compilation-error "expected catch* or finally* block in try*" (cc/parse '(try* 10 20)))
  (assert-compilation-error "expected catch* or finally* block in try*" (cc/parse '(try* 10 (something))))
  (assert-compilation-error "missing exception type in catch*" (cc/parse '(try* 10 (catch*))))
  (assert-compilation-error "missing exception binding in catch*" (cc/parse '(try* 10 (catch* Exception))))
  (assert-compilation-error "missing catch* body" (cc/parse '(try* 10 (catch* Exception x))))
  (assert-compilation-error "missing finally* body" (cc/parse '(try* 10 (finally*))))
  (assert-compilation-error "Too many expressions in finally*, expected one" (cc/parse '(try* 10 (finally* 20 30))))
  (assert-compilation-error "Too many expressions in catch*, expected one" (cc/parse '(try* 10 (catch* Exception x 20 30))))
  (assert-compilation-error "Too many expressions in try*" (cc/parse '(try* 10 (catch* Exception x nil) (finally* nil))))

  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* 10 nil)))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* nil [])))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* some 10 nil)))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* (10 nil))))
  (assert-compilation-error "Bad fn* param list, expected vector" (cc/parse '(fn* some (10 nil))))
  (assert-compilation-error "fn* params must be symbols" (cc/parse '(fn* [10] nil)))
  (assert-compilation-error "fn* params must be symbols" (cc/parse '(fn* [x y 20] nil)))
  (assert-compilation-error "Can't user qualified name as parameter: a/x" (cc/parse '(fn* [a/x y] nil)))
  (assert-compilation-error "Can't user qualified name as parameter: b/y" (cc/parse '(fn* [x b/y] nil)))
  (assert-compilation-error "Too many forms passed to fn*" (cc/parse '(fn* [] 10 20)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [& x y] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x & y z] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x & y z &] nil)))
  (assert-compilation-error "Invalid parameter list" (cc/parse '(fn* [x y & &] nil)))

  (assert-compilation-error "Mismatched argument count to recur, expected 0 args, got 1" (cc/parse '(fn* [x] (loop* [] (recur 1)))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 0" (cc/parse '(fn* [] (loop* [x 5 y 6] (recur)))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(loop* [x 5 y 6] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(loop* [x 5 y 6] (recur 1 2 3))))
  (assert-compilation-error "Mismatched argument count to recur, expected 0 args, got 1" (cc/parse '(fn* [] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(fn* [x y] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(fn* [x y] (recur 1 2 3))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 1" (cc/parse '(fn* [x & y] (recur 1))))
  (assert-compilation-error "Mismatched argument count to recur, expected 2 args, got 3" (cc/parse '(fn* [x & y] (recur 1 2 3))))

  (assert-compilation-error "Can only recur from tail position" (cc/parse '(recur 10)))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do (recur) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (do 1 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y (recur 10)] 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y 1] (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (let* [y 1] 2 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y (recur 10)]) 0)))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y 1] (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (loop* [y 1] 2 (recur 10) 0))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10) (catch* Exception e e)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* 10 (catch* Exception e (recur 10))))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* (recur 10) (finally* 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (try* 10 (finally* (recur 10))))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] [(recur 10)])))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] #{(recur 10)})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] {(recur 10) :v})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] {:k (recur 10)})))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (f (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (f 0 (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] ((recur 10) 20))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (def z (recur 10)))))
  (assert-compilation-error "Can only recur from tail position" (cc/parse '(fn* [x] (if (recur 10) 1 2))))

  (assert-compilation-error "Can't have fixed arity function with more params than variadic function" (cc/parse '(fn* ([a b] nil) ([a & b] nil))))
  (assert-compilation-error "Can't have fixed arity function with more params than variadic function" (cc/parse '(fn* ([a b & c] nil) ([a b] nil) ([a b c]))))
  (assert-compilation-error "Can't have more than 1 variadic overload" (cc/parse '(fn* ([a & b] nil) ([& b] nil))))
  (assert-compilation-error "Can't have 2 overloads with same arity" (cc/parse '(fn* ([x] nil) ([x y] nil) ([x] nil)))))


(defn translate-body [form]
  (-> form
      cc/parse
      cc/optimize
      cc/translate
      :bodies
      first))


(deftest translate-fn
  (let [f (cc/translate (cc/parse '(fn* [])))]
    (assert= 2 (count f))
    (assert= (:bodies f) [{:arity 0
                           :bytecode [vm/CNIL]}])
    (assert-not (-> f :name namespace))
    (assert (str-starts-with? (-> f :name name) "anonfn--"))
    (assert= Int64 (-> f :name name (subs 8) read-string type)))
  (assert= {:name 'abc
            :bodies [{:arity 0
                      :bytecode [vm/CNIL]}]}
           (cc/translate (cc/parse '(fn* abc []))))
  (assert= {:name 'abc
            :bodies [{:arity 0
                      :bytecode [vm/LDL 255 255]}]}
           (cc/translate (cc/parse '(fn* abc [] abc))))
  (assert= {:name 'abc
            :bodies [{:arity 2
                      :bytecode [vm/LDL 254 255
                                 vm/POP
                                 vm/LDL 255 255
                                 vm/POP
                                 vm/LDL 253 255]}]}
           (cc/translate (cc/parse '(fn* abc [x y] (do x y abc)))))
  (assert= {:name 'abc
            :bodies [{:arity 2
                      :vararg :true
                      :bytecode [vm/LDL 254 255
                                 vm/POP
                                 vm/LDL 255 255
                                 vm/POP
                                 vm/LDL 253 255]}]}
           (cc/translate (cc/parse '(fn* abc [x & y] (do x y abc)))))
  (assert= {:name 'abc
            :bodies [{:arity 0
                      :bytecode [vm/CNIL]}
                     {:arity 1
                      :bytecode [vm/CNIL]}
                     {:arity 3
                      :bytecode [vm/CNIL]}]}
           (cc/translate (cc/parse '(fn* abc ([]) ([x]) ([x y z])))))
  (when slow-tests
    (assert-compilation-error "Too many params: 32768" (translate-body (list 'fn*
                                                                             (loop [i 0 bindings (transient [])]
                                                                               (if (< i 32768)
                                                                                 (recur (inc i) (-> bindings (conj! 'p)))
                                                                                 (persistent! bindings)))
                                                                             nil)))))


(deftest translate-const
  (assert= {:arity 0
            :consts [:xyz]
            :bytecode [vm/LDC 0 0]}
           (translate-body :xyz))
  (assert= {:arity 0
            :consts [100]
            :bytecode [vm/LDC 0 0]}
           (translate-body 100))
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body nil))
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(do)))
  (assert= {:arity 0
            :consts [{:a :b}]
            :bytecode [vm/LDC 0 0]}
           (translate-body {:a :b}))
  (assert= {:arity 0
            :consts [10 20 30]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 0 0
                       vm/POP
                       vm/CNIL
                       vm/POP
                       vm/LDC 2 0]}
           (translate-body '(do 10 20 10 nil 30)))
  (assert= {:arity 0
            :consts [() [] #{} {}]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 2 0
                       vm/POP
                       vm/LDC 3 0]}
           (translate-body '(do () [] #{} {})))
  (assert= {:arity 0
            :consts [10 20 30]
            :bytecode [vm/LDC 0 0
                       vm/POP
                       vm/LDC 1 0
                       vm/POP
                       vm/LDC 0 0
                       vm/POP
                       vm/CNIL
                       vm/POP
                       vm/LDC 2 0]}
           (translate-body '(do (do 10 (do 20  10)) (do) 30)))
  (assert= [vm/LDC 254 0
            vm/LDC 255 0
            vm/LDC 0 1
            vm/LDC 1 1
            vm/CALL 226]
           (->> (translate-body '(fn* [f] (f (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
                                             33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                             65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                             97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                             129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                             161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                             193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                             225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257)))
                :bytecode (drop (+ 2 (* 3 256))))))


(defmacro binding-ns [name expr]
  `(let [prev# (ns-name *ns*)]
     (try*
       (do
         (in-ns ~name)
         ~expr)
       (finally*
         (in-ns prev#)))))


(def test-var0 10)
(def test-var1 10)
(def {:dynamic nil} test-var2 20)
(def {:dynamic :true} test-dynvar 30)
(def {:const :true} test-constvar 77)
(def {:macro :true} test-macro 40)
(def test-var2 30)
(def test-var3 40)
(def test-var4 50)
(def test-var5 60)
(def test-var6 70)
(def test-var7 80)
(def test-var8 90)
(def test-var9 100)
(def test-var10 110)
(def test-var11 120)
(def test-var12 130)
(def test-var13 140)
(def test-var14 150)
(def test-var15 160)
(def test-var16 170)
(def test-var17 180)
(def test-var18 190)
(def test-var19 200)
(def test-var20 210)
(def test-var21 220)
(def test-var22 230)
(def test-var23 240)
(def test-var24 250)
(def test-var25 260)
(def test-var26 270)
(def test-var27 280)
(def test-var28 290)
(def test-var29 300)
(def test-var30 310)
(def test-var31 320)
(def test-var32 330)
(def test-var33 340)
(def test-var34 350)
(def test-var35 360)
(def test-var36 370)
(def test-var37 380)
(def test-var38 390)
(def test-var39 400)
(def test-var40 410)
(def test-var41 420)
(def test-var42 430)
(def test-var43 440)
(def test-var44 450)
(def test-var45 460)
(def test-var46 470)
(def test-var47 480)
(def test-var48 490)
(def test-var49 500)
(def test-var50 510)
(def test-var51 520)
(def test-var52 530)
(def test-var53 540)
(def test-var54 550)
(def test-var55 560)
(def test-var56 570)
(def test-var57 580)
(def test-var58 590)
(def test-var59 600)
(def test-var60 610)
(def test-var61 620)
(def test-var62 630)
(def test-var63 640)
(def test-var64 650)
(def test-var65 660)
(def test-var66 670)
(def test-var67 680)
(def test-var68 690)
(def test-var69 700)
(def test-var70 710)
(def test-var71 720)
(def test-var72 730)
(def test-var73 740)
(def test-var74 750)
(def test-var75 760)
(def test-var76 770)
(def test-var77 780)
(def test-var78 790)
(def test-var79 800)
(def test-var80 810)
(def test-var81 820)
(def test-var82 830)
(def test-var83 840)
(def test-var84 850)
(def test-var85 860)
(def test-var86 870)
(def test-var87 880)
(def test-var88 890)
(def test-var89 900)
(def test-var90 910)
(def test-var91 920)
(def test-var92 930)
(def test-var93 940)
(def test-var94 950)
(def test-var95 960)
(def test-var96 970)
(def test-var97 980)
(def test-var98 990)
(def test-var99 1000)
(def test-var100 1010)
(def test-var101 1020)
(def test-var102 1030)
(def test-var103 1040)
(def test-var104 1050)
(def test-var105 1060)
(def test-var106 1070)
(def test-var107 1080)
(def test-var108 1090)
(def test-var109 1100)
(def test-var110 1110)
(def test-var111 1120)
(def test-var112 1130)
(def test-var113 1140)
(def test-var114 1150)
(def test-var115 1160)
(def test-var116 1170)
(def test-var117 1180)
(def test-var118 1190)
(def test-var119 1200)
(def test-var120 1210)
(def test-var121 1220)
(def test-var122 1230)
(def test-var123 1240)
(def test-var124 1250)
(def test-var125 1260)
(def test-var126 1270)
(def test-var127 1280)
(def test-var128 1290)
(def test-var129 1300)
(def test-var130 1310)
(def test-var131 1320)
(def test-var132 1330)
(def test-var133 1340)
(def test-var134 1350)
(def test-var135 1360)
(def test-var136 1370)
(def test-var137 1380)
(def test-var138 1390)
(def test-var139 1400)
(def test-var140 1410)
(def test-var141 1420)
(def test-var142 1430)
(def test-var143 1440)
(def test-var144 1450)
(def test-var145 1460)
(def test-var146 1470)
(def test-var147 1480)
(def test-var148 1490)
(def test-var149 1500)
(def test-var150 1510)
(def test-var151 1520)
(def test-var152 1530)
(def test-var153 1540)
(def test-var154 1550)
(def test-var155 1560)
(def test-var156 1570)
(def test-var157 1580)
(def test-var158 1590)
(def test-var159 1600)
(def test-var160 1610)
(def test-var161 1620)
(def test-var162 1630)
(def test-var163 1640)
(def test-var164 1650)
(def test-var165 1660)
(def test-var166 1670)
(def test-var167 1680)
(def test-var168 1690)
(def test-var169 1700)
(def test-var170 1710)
(def test-var171 1720)
(def test-var172 1730)
(def test-var173 1740)
(def test-var174 1750)
(def test-var175 1760)
(def test-var176 1770)
(def test-var177 1780)
(def test-var178 1790)
(def test-var179 1800)
(def test-var180 1810)
(def test-var181 1820)
(def test-var182 1830)
(def test-var183 1840)
(def test-var184 1850)
(def test-var185 1860)
(def test-var186 1870)
(def test-var187 1880)
(def test-var188 1890)
(def test-var189 1900)
(def test-var190 1910)
(def test-var191 1920)
(def test-var192 1930)
(def test-var193 1940)
(def test-var194 1950)
(def test-var195 1960)
(def test-var196 1970)
(def test-var197 1980)
(def test-var198 1990)
(def test-var199 2000)
(def test-var200 2010)
(def test-var201 2020)
(def test-var202 2030)
(def test-var203 2040)
(def test-var204 2050)
(def test-var205 2060)
(def test-var206 2070)
(def test-var207 2080)
(def test-var208 2090)
(def test-var209 2100)
(def test-var210 2110)
(def test-var211 2120)
(def test-var212 2130)
(def test-var213 2140)
(def test-var214 2150)
(def test-var215 2160)
(def test-var216 2170)
(def test-var217 2180)
(def test-var218 2190)
(def test-var219 2200)
(def test-var220 2210)
(def test-var221 2220)
(def test-var222 2230)
(def test-var223 2240)
(def test-var224 2250)
(def test-var225 2260)
(def test-var226 2270)
(def test-var227 2280)
(def test-var228 2290)
(def test-var229 2300)
(def test-var230 2310)
(def test-var231 2320)
(def test-var232 2330)
(def test-var233 2340)
(def test-var234 2350)
(def test-var235 2360)
(def test-var236 2370)
(def test-var237 2380)
(def test-var238 2390)
(def test-var239 2400)
(def test-var240 2410)
(def test-var241 2420)
(def test-var242 2430)
(def test-var243 2440)
(def test-var244 2450)
(def test-var245 2460)
(def test-var246 2470)
(def test-var247 2480)
(def test-var248 2490)
(def test-var249 2500)
(def test-var250 2510)
(def test-var251 2520)
(def test-var252 2530)
(def test-var253 2540)
(def test-var254 2550)
(def test-var255 2560)
(def test-var256 2570)
(def test-var257 2580)


(define-var 'cleo.compiler.private-var.test/test-var {:private :true})


(deftest translate-var
  (assert= {:arity 0
            :vars [#'test-var1]
            :bytecode [vm/LDV 0 0]}
           (translate-body 'cleo.core.test/test-var1))
  (assert-compilation-error "unable to resolve symbol: cleo.core.test/missing-var" (translate-body 'cleo.core.test/missing-var))
  (assert= {:arity 0
            :vars [#'test-var2 #'test-dynvar]
            :bytecode [vm/LDV 0 0
                       vm/POP
                       vm/LDDV 1 0]}
           (translate-body '(do cleo.core.test/test-var2 cleo.core.test/test-dynvar)))
  (assert= {:arity 0
            :vars [#'test-var1 #'test-var2]
            :bytecode [vm/LDV 0 0
                       vm/POP
                       vm/LDV 1 0
                       vm/POP
                       vm/LDV 0 0]}
           (translate-body '(do cleo.core.test/test-var1 cleo.core.test/test-var2 cleo.core.test/test-var1)))
  (assert-compilation-error "var: cleo.compiler.private-var.test/test-var is not public" (cc/translate (cc/parse 'cleo.compiler.private-var.test/test-var)))
  (binding-ns 'cleo.compiler.private-var.test
              (assert= {:arity 0
                        :vars [#'cleo.compiler.private-var.test/test-var]
                        :bytecode [vm/LDV 0 0]}
                       (translate-body 'cleo.compiler.private-var.test/test-var)))
  (assert-compilation-error "Can't take value of a macro: #'cleo.core.test/test-macro" (cc/translate (cc/parse 'cleo.core.test/test-macro)))
  (assert= [vm/LDV 254 0
            vm/POP
            vm/LDV 255 0
            vm/POP
            vm/LDV 0 1
            vm/POP
            vm/LDV 1 1]
           (->> (translate-body (cons 'do (loop [i 0 vars (transient [])]
                                           (if (< i 258)
                                             (recur (inc i) (conj! vars (symbol "cleo.core.test" (str "test-var" i))))
                                             (persistent! vars)))))
                :bytecode
                (drop (* 4 254))))
  (assert= {:arity 0
            :consts [77]
            :bytecode [vm/LDC 0 0]}
           (translate-body 'cleo.core.test/test-constvar)))


(deftest translate-param
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [a] a)))
  (assert= {:arity 3
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 253 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* fx [a b c] (do b a c)))))


(deftest translate-call
  (assert= {:arity 0
            :vars [#'test-var1]
            :bytecode [vm/LDV 0 0
                       vm/CALL 0]}
           (translate-body '(cleo.core.test/test-var1)))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/CALL 0]}
           (translate-body '(fn* [p] (p))))
  (assert= {:arity 1
            :consts [10 20]
            :vars [#'test-var1]
            :bytecode [vm/LDL 255 255
                       vm/LDV 0 0
                       vm/LDC 0 0
                       vm/LDC 1 0
                       vm/CALL 3]}
           (translate-body '(fn* [f] (f cleo.core.test/test-var1 10 20))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 253 255
                       vm/CALL 1
                       vm/CALL 1
                       vm/CALL 2]}
           (translate-body '(fn* [a b c] (a (b) (c (b a))))))
  (assert-no-exception (translate-body
                        '(fn* [f] (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
                                     33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                     65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                     97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                     129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                     161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                     193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                     225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254))))
  (assert-compilation-error "Too many arguments: 256"
                            (translate-body
                             '(fn* [f] (f 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
                                          33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64
                                          65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
                                          97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128
                                          129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160
                                          161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192
                                          193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224
                                          225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255)))))


(deftest transform-expr
  (let [with-tag (fn with-tag [tag]
                   (fn [x path] (and (map? x) (= tag (:tag x)))))
        mark-path (fn mark-path [x path]
                    (assoc x :marked-path path))]
    (assert= {:tag :if
              :cond {:tag :do
                     :exprs [9]
                     :marked-path [:cond]}
              :then {:tag :do
                     :exprs [1 2 3]
                     :marked-path [:then]}
              :else {:tag :do
                     :exprs [5 6 7]
                     :marked-path [:else]}}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(if (do 9) (do 1 2 3) (do 5 6 7)))))
    (assert= {:tag :throw
              :expr {:tag :dot
                     :expr {:tag :var
                            :name 'x}
                     :member 'y
                     :marked-path [:expr]}}
             (cc/transform-expr (with-tag :dot) mark-path (cc/parse '(throw (. x -y)))))
    (assert= {:tag :try
              :expr {:fn {:tag :var
                          :name 'f}
                     :tag :call
                     :args [10]
                     :marked-path [:expr]}
              :finally {:tag :call
                        :fn {:tag :var
                             :name 'f}
                        :args [20]
                        :marked-path [:finally]}}
             (cc/transform-expr (with-tag :call) mark-path (cc/parse '(try* (f 10) (finally* (f 20))))))
    (assert= {:tag :try
              :expr {:fn {:tag :var
                          :name 'f}
                     :tag :call
                     :args [10]
                     :marked-path [:expr]}
              :catch {:type 'Exception
                      :local {:index 0
                              :name 'e}
                      :expr {:tag :call
                             :fn {:tag :var
                                  :name 'f}
                             :args [20]
                             :marked-path [:catch :expr]}}}
             (cc/transform-expr (with-tag :call) mark-path (cc/parse '(try* (f 10) (catch* Exception e (f 20))))))
    (assert= {:tag :call
              :fn {:tag :if, :cond 1, :then 2, :else nil
                   :marked-path [:fn]}
              :args [{:tag :if, :cond 3, :then 4, :else nil
                      :marked-path [:args 0]}
                     {:tag :if, :cond 5, :then 6, :else nil
                      :marked-path [:args 1]}]}
             (cc/transform-expr (with-tag :if) mark-path (cc/parse '((if 1 2) (if 3 4) (if 5 6)))))
    (assert= {:tag :do
              :exprs [{:tag :if, :cond 1, :then 2, :else nil
                       :marked-path [:exprs 0]}
                      {:tag :if, :cond 3, :then 4, :else nil
                       :marked-path [:exprs 1]}]}
             (cc/transform-expr (with-tag :if) mark-path (cc/parse '(do (if 1 2) (if 3 4)))))
    (assert= {:tag :let
              :locals [{:index 0, :name 'x
                        :expr {:tag :do
                               :exprs [1]
                               :marked-path [:locals 0 :expr]}}
                       {:index 1, :name 'y
                        :expr {:tag :do
                               :exprs [2]
                               :marked-path [:locals 1 :expr]}}]
              :exprs [{:tag :do
                       :exprs [3]
                       :marked-path [:exprs 0]}
                      {:tag :do
                       :exprs [4]
                       :marked-path [:exprs 1]}]}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(let* [x (do 1) y (do 2)] (do 3) (do 4)))))
    (assert= {:tag :loop
              :locals [{:index 0, :name 'x
                        :expr {:tag :do
                               :exprs [1]
                               :marked-path [:locals 0 :expr]}}
                       {:index 1, :name 'y
                        :expr {:tag :do
                               :exprs [2]
                               :marked-path [:locals 1 :expr]}}]
              :exprs [{:tag :do
                       :exprs [3]
                       :marked-path [:exprs 0]}
                      {:tag :do
                       :exprs [4]
                       :marked-path [:exprs 1]}]}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(loop* [x (do 1) y (do 2)] (do 3) (do 4)))))
    (assert= {:tag :fn
              :bodies [{:params []
                        :expr {:tag :do
                               :exprs [10]
                               :marked-path [:bodies 0 :expr]}}
                       {:params [{:index 0, :name 'x}]
                        :expr {:tag :do
                               :exprs [20]
                               :marked-path [:bodies 1 :expr]}}]}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(fn* ([] (do 10)) ([x] (do 20))))))
    (assert= {:tag :loop
              :locals [{:index 0, :name 'x, :expr 0}
                       {:index 1, :name 'y, :expr 1}]
              :exprs [{:tag :recur
                       :args [{:tag :do
                               :exprs [1]
                               :marked-path [:exprs 0 :args 0]}
                              {:tag :do
                               :exprs [2]
                               :marked-path [:exprs 0 :args 1]}]}]}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(loop* [x 0 y 1] (recur (do 1) (do 2))))))
    (assert= {:tag :def
              :name 'x}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(def x))))
    (assert= {:tag :def
              :name 'x
              :expr {:tag :do
                     :exprs [30]
                     :marked-path [:expr]}}
             (cc/transform-expr (with-tag :do) mark-path (cc/parse '(def x (do 30)))))))


(defn identity-inline {:const :true} ([x] x) ([] "ignored") ([x y] "ignored"))


(deftest translate-call-inline-identity
  (assert= {:arity 0
            :consts [20]
            :bytecode [vm/LDC 0 0]}
           (translate-body '(cleo.core.test/identity-inline 20)))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn [x] (cleo.core.test/identity-inline x))))
  (assert= {:arity 0
            :consts [cleo.core.test/identity-inline]
            :bytecode [vm/LDC 0 0]}
           (translate-body '(cleo.core.test/identity-inline cleo.core.test/identity-inline))))


(defn const-inline {:const :true} ([] "the const") ([x] "ignored"))


(deftest translate-no-arg-returning-const
  (assert= {:arity 0
            :consts ["the const"]
            :bytecode [vm/LDC 0 0]}
           (translate-body '(cleo.core.test/const-inline)))
  (assert= {:arity 1
            :consts ["the const"]
            :bytecode [vm/LDC 0 0]}
           (translate-body '(fn [x] (cleo.core.test/const-inline)))))


(deftest translate-let
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(let* [])))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [x] (let* [] x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* [x y] (let* [] x y))))
  (assert= {:arity 0
            :locals-size 2
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 0 0
                       vm/LDC 0 0
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/POP
                       vm/LDL 1 0]}
           (translate-body '(let* [x 10 y 10] x y)))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [x] (let* [x x] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0]}
           (translate-body '(fn* [x] (let* [x x
                                            x x] x))))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (let* [x (let* [y (let* [z a] z)] y)] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/LDL 1 0
                       vm/CALL 1
                       vm/BR 9 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (if a (let* [x a y a] (x y)) (let* [x a] x)))))
  (let [let257 (translate-body '(fn* [a] (let* [a00 nil a01 nil a02 nil a03 nil a04 nil a05 nil a06 nil a07 nil
                                                a08 nil a09 nil a0a nil a0b nil a0c nil a0d nil a0e nil a0f nil
                                                a10 nil a11 nil a12 nil a13 nil a14 nil a15 nil a16 nil a17 nil
                                                a18 nil a19 nil a1a nil a1b nil a1c nil a1d nil a1e nil a1f nil
                                                a20 nil a21 nil a22 nil a23 nil a24 nil a25 nil a26 nil a27 nil
                                                a28 nil a29 nil a2a nil a2b nil a2c nil a2d nil a2e nil a2f nil
                                                a30 nil a31 nil a32 nil a33 nil a34 nil a35 nil a36 nil a37 nil
                                                a38 nil a39 nil a3a nil a3b nil a3c nil a3d nil a3e nil a3f nil
                                                a40 nil a41 nil a42 nil a43 nil a44 nil a45 nil a46 nil a47 nil
                                                a48 nil a49 nil a4a nil a4b nil a4c nil a4d nil a4e nil a4f nil
                                                a50 nil a51 nil a52 nil a53 nil a54 nil a55 nil a56 nil a57 nil
                                                a58 nil a59 nil a5a nil a5b nil a5c nil a5d nil a5e nil a5f nil
                                                a60 nil a61 nil a62 nil a63 nil a64 nil a65 nil a66 nil a67 nil
                                                a68 nil a69 nil a6a nil a6b nil a6c nil a6d nil a6e nil a6f nil
                                                a70 nil a71 nil a72 nil a73 nil a74 nil a75 nil a76 nil a77 nil
                                                a78 nil a79 nil a7a nil a7b nil a7c nil a7d nil a7e nil a7f nil
                                                a80 nil a81 nil a82 nil a83 nil a84 nil a85 nil a86 nil a87 nil
                                                a88 nil a89 nil a8a nil a8b nil a8c nil a8d nil a8e nil a8f nil
                                                a90 nil a91 nil a92 nil a93 nil a94 nil a95 nil a96 nil a97 nil
                                                a98 nil a99 nil a9a nil a9b nil a9c nil a9d nil a9e nil a9f nil
                                                aa0 nil aa1 nil aa2 nil aa3 nil aa4 nil aa5 nil aa6 nil aa7 nil
                                                aa8 nil aa9 nil aaa nil aab nil aac nil aad nil aae nil aaf nil
                                                ab0 nil ab1 nil ab2 nil ab3 nil ab4 nil ab5 nil ab6 nil ab7 nil
                                                ab8 nil ab9 nil aba nil abb nil abc nil abd nil abe nil abf nil
                                                ac0 nil ac1 nil ac2 nil ac3 nil ac4 nil ac5 nil ac6 nil ac7 nil
                                                ac8 nil ac9 nil aca nil acb nil acc nil acd nil ace nil acf nil
                                                ad0 nil ad1 nil ad2 nil ad3 nil ad4 nil ad5 nil ad6 nil ad7 nil
                                                ad8 nil ad9 nil ada nil adb nil adc nil add nil ade nil adf nil
                                                ae0 nil ae1 nil ae2 nil ae3 nil ae4 nil ae5 nil ae6 nil ae7 nil
                                                ae8 nil ae9 nil aea nil aeb nil aec nil aed nil aee nil aef nil
                                                af0 nil af1 nil af2 nil af3 nil af4 nil af5 nil af6 nil af7 nil
                                                af8 nil af9 nil afa nil afb nil afc nil afd nil afe nil aff nil
                                                a100 a] a100)))]
    (assert= [vm/LDL 255 255
              vm/STL 0 1
              vm/LDL 0 1] (drop (* 4 256) (:bytecode let257))))
  (when slow-tests
    (assert-compilation-error "Too many locals: 32769" (translate-body (list 'let* (loop [i 0 bindings (transient [])]
                                                                                     (if (< i 32769)
                                                                                       (recur (inc i) (-> bindings (conj! 'l) (conj! i)))
                                                                                       (persistent! bindings))))))))


(deftest translate-loop
  (assert= {:arity 0
            :bytecode [vm/CNIL]}
           (translate-body '(loop* [])))
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255]}
           (translate-body '(fn* [x] (loop* [] x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/POP
                       vm/LDL 255 255]}
           (translate-body '(fn* [x y] (loop* [] x y))))
  (assert= {:arity 0
            :locals-size 2
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 0 0
                       vm/LDC 0 0
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/POP
                       vm/LDL 1 0]}
           (translate-body '(loop* [x 10 y 10] x y)))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [x] (loop* [x x] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0]}
           (translate-body '(fn* [x] (loop* [x x
                                             x x] x))))
  (assert= {:arity 1
            :locals-size 1
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (loop* [x (let* [y (loop* [z a] z)] y)] x))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/LDL 1 0
                       vm/CALL 1
                       vm/BR 9 0
                       vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0]}
           (translate-body '(fn* [a] (if a (loop* [x a y a] (x y)) (let* [x a] x))))))


(deftest translate-throw
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/THROW]}
           (translate-body '(fn* [p] (throw p))))
  (assert= {:arity 0
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/THROW]}
           (translate-body '(throw 10))))


(deftest translate-if
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/BNIL 6 0
                       vm/LDL 254 255
                       vm/BR 3 0
                       vm/LDL 255 255]}
           (translate-body '(fn* [a b c] (if a b c))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/BNIL 8 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 5 0
                       vm/LDL 255 255
                       vm/CALL 0]}
           (translate-body '(fn* [a b c] (if (a) (b) (c)))))
  (assert= {:arity 3
            :consts [101 102 103 104]
            :bytecode [vm/LDL 253 255
                       vm/BNIL 30 0
                       vm/LDL 254 255
                       vm/BNIL 18 0
                       vm/LDL 255 255
                       vm/BNIL 6 0
                       vm/LDC 0 0
                       vm/BR 3 0
                       vm/LDC 1 0
                       vm/BR 3 0
                       vm/LDC 2 0
                       vm/BR 3 0
                       vm/LDC 3 0]}
           (translate-body '(fn* [a b c] (if a (if b (if c 101 102) 103) 104)))))


(deftest translate-dot
  (assert= {:arity 1
            :consts ['xf]
            :bytecode [vm/LDL 255 255
                       vm/LDC 0 0
                       vm/LDDF]}
           (translate-body '(fn* [x] (. x -xf))))
  (assert= {:arity 2
            :consts ['xf]
            :bytecode [vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 1
                       vm/LDC 0 0
                       vm/LDDF]}
           (translate-body '(fn* [f x] (. (f x) -xf))))
  (assert= {:arity 1
            :consts ['xf]
            :vars [#'cleo.core/list]
            :bytecode [vm/LDV 0 0
                       vm/LDL 255 255
                       vm/CALL 1
                       vm/LDC 0 0
                       vm/LDDF]}
           (translate-body '(fn* [x] (. (cleo.core/list x) -xf)))))


(deftest translate-cast
  (assert= {:arity 1
            :consts [cast List]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 255 255
                       vm/CALL 2]}
           (translate-body '(fn* [x] (cast List x))))
  (assert-compilation-error "First argument to cast must be a type" (translate-body '(fn* [x] (cast 10 x)))))


(deftype ABC [a b c])

; it breaks deftype
'(deftest translate-new
  (assert= {:arity 3
            :consts [new ABC]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 4]}
           (translate-body '(fn* [x y z] (new cleo.core.test/ABC x y z))))
  (assert-compilation-error "First argument to new must be a type" (translate-body '(fn* [x] (new 10 x)))))


(deftype F259 [f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15
               f16 f17 f18 f19 f20 f21 f22 f23 f24 f25 f26 f27 f28 f29 f30 f31
               f32 f33 f34 f35 f36 f37 f38 f39 f40 f41 f42 f43 f44 f45 f46 f47
               f48 f49 f50 f51 f52 f53 f54 f55 f56 f57 f58 f59 f60 f61 f62 f63
               f64 f65 f66 f67 f68 f69 f70 f71 f72 f73 f74 f75 f76 f77 f78 f79
               f80 f81 f82 f83 f84 f85 f86 f87 f88 f89 f90 f91 f92 f93 f94 f95
               f96 f97 f98 f99 f100 f101 f102 f103 f104 f105 f106 f107 f108 f109 f110 f111
               f112 f113 f114 f115 f116 f117 f118 f119 f120 f121 f122 f123 f124 f125 f126 f127
               f128 f129 f130 f131 f132 f133 f134 f135 f136 f137 f138 f139 f140 f141 f142 f143
               f144 f145 f146 f147 f148 f149 f150 f151 f152 f153 f154 f155 f156 f157 f158 f159
               f160 f161 f162 f163 f164 f165 f166 f167 f168 f169 f170 f171 f172 f173 f174 f175
               f176 f177 f178 f179 f180 f181 f182 f183 f184 f185 f186 f187 f188 f189 f190 f191
               f192 f193 f194 f195 f196 f197 f198 f199 f200 f201 f202 f203 f204 f205 f206 f207
               f208 f209 f210 f211 f212 f213 f214 f215 f216 f217 f218 f219 f220 f221 f222 f223
               f224 f225 f226 f227 f228 f229 f230 f231 f232 f233 f234 f235 f236 f237 f238 f239
               f240 f241 f242 f243 f244 f245 f246 f247 f248 f249 f250 f251 f252 f253 f254 f255
               f256 f257 f258])


(def {:const :true} abc (new ABC 7 8 9))

(deftest translate-dot-with-known-type
  (assert= {:arity 1
            :consts [cast ABC]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 255 255
                       vm/CALL 2
                       vm/LDSF 0 0]}
           (translate-body '(fn* [x] (. (cast cleo.core.test/ABC x) -a))))
  (assert= {:arity 1
            :consts [cast ABC]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 255 255
                       vm/CALL 2
                       vm/LDSF 1 0]}
           (translate-body '(fn* [x] (. (cast cleo.core.test/ABC x) -b))))
  (assert= {:arity 1
            :consts [cast F259]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 255 255
                       vm/CALL 2
                       vm/LDSF 2 1]}
           (translate-body '(fn* [x] (. (cast cleo.core.test/F259 x) -f258))))
  (assert-compilation-error "Field: abc not present in type: ABC" (translate-body '(fn* [x] (. (cast cleo.core.test/ABC x) -abc))))
  (assert-compilation-error "Field: zzzzz not present in type: cleo.core/Int64" (translate-body '(fn* [x] (. (cast Int64 x) -zzzzz))))
  (assert-compilation-error "Field: zzzzz not present in type: cleo.core/Int64" (translate-body '(fn* [x] (. 10 -zzzzz))))
  (assert-compilation-error "Field: zzzzz not present in type: cleo.core/List" (translate-body '(fn* [x] (. () -zzzzz))))
  (assert-compilation-error "Field: zzzzz not present in type: ABC" (translate-body '(fn* [x] (. cleo.core.test/abc -zzzzz))))
  (assert= {:arity 3
            :consts [new ABC]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 4
                       vm/LDSF 1 0]}
           (translate-body '(fn* [x y z] (. (new cleo.core.test/ABC x y z) -b))))
)


(deftest translate-apply
  (assert= {:arity 1
            :bytecode [vm/LDL 255 255
                       vm/CNIL
                       vm/APPLY 0]}
           (translate-body '(fn* [f] (cleo.core/apply f nil))))
  (assert= {:arity 1
            :consts [10 20 30]
            :bytecode [vm/LDL 255 255
                       vm/LDC 0 0
                       vm/LDC 1 0
                       vm/LDC 2 0
                       vm/CNIL
                       vm/APPLY 3]}
           (translate-body '(fn* [f] (apply f 10 20 30 nil))))
  (assert= {:arity 3
            :consts [10 20]
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDC 0 0
                       vm/APPLY 0
                       vm/LDL 255 255
                       vm/LDC 1 0
                       vm/CALL 1
                       vm/APPLY 1]}
           (translate-body '(fn* [f g h] (apply f (apply g 10) (h 20)))))
  (assert-compilation-error "Wrong number of args (0) passed to cleo.core/apply" (cc/translate (cc/parse '(apply))))
  (assert-compilation-error "Wrong number of args (0) passed to cleo.core/apply" (cc/translate (cc/parse '(cleo.core/apply))))
  (assert-compilation-error "Wrong number of args (1) passed to cleo.core/apply" (cc/translate (cc/parse '(fn* [f] (cleo.core/apply f))))))


(define-var 'cleo.compiler.def.test.other/ex nil)

(in-ns 'cleo.compiler.imported-def.test)
(def imported-existing 20)
(cleo.core/in-ns 'cleo.compiler.def.test)
(cleo.core/refer 'cleo.compiler.imported-def.test)
(def existing 10)
(cleo.core/in-ns 'cleo.core.test)

(deftest translate-def
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def x 10)))]
    (assert (resolve 'cleo.compiler.def.test/x))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/x) 10]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/STVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def z nil)))]
    (assert (resolve 'cleo.compiler.def.test/z))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/z)]
              :bytecode [vm/LDC 0 0
                         vm/CNIL
                         vm/STVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def w)))]
    (assert (resolve 'cleo.compiler.def.test/w))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/w)]
              :bytecode [vm/LDC 0 0]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def xr xr)))]
    (assert (resolve 'cleo.compiler.def.test/xr))
    (assert= {:arity 0
              :consts [(resolve 'cleo.compiler.def.test/xr)]
              :vars [(resolve 'cleo.compiler.def.test/xr)]
              :bytecode [vm/LDC 0 0
                         vm/LDV 0 0
                         vm/STVV]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def {:x 7 :y '(z)} y 10)))
        y-var (resolve 'cleo.compiler.def.test/y)]
    (assert= 7 (:x (meta y-var)))
    (assert= '(z) (:y (meta y-var)))
    (assert= {:arity 0
              :consts [y-var 10 {:x 7 :y '(z)}]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/STVV
                         vm/LDC 2 0
                         vm/STVM]}
             tbody))
  (let [tbody (binding-ns 'cleo.compiler.def.test
                          (translate-body '(def {:x 7 :y '(z)} s)))
        s-var (resolve 'cleo.compiler.def.test/s)]
    (assert= 7 (:x (meta s-var)))
    (assert= '(z) (:y (meta s-var)))
    (assert= {:arity 0
              :consts [s-var {:x 7 :y '(z)}]
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/STVM]}
             tbody))
  (assert= (resolve 'cleo.compiler.imported-def.test/imported-existing)
           (binding-ns 'cleo.compiler.def.test (resolve 'imported-existing)))
  (assert-compilation-error "imported-existing already refers to: #'cleo.compiler.imported-def.test/imported-existing in namespace: cleo.compiler.def.test"
                            (binding-ns 'cleo.compiler.def.test
                                           (translate-body '(def imported-existing 10))))
  (assert (resolve 'cleo.compiler.def.test.other/ex))
  (assert-compilation-error "Can't create defs outside of current ns"
                            (binding-ns 'cleo.compiler.def.test
                                        (cc/translate (cc/parse '(def cleo.compiler.def.test.other/ex)))))
  (assert-compilation-error "Can't refer to qualified var that doesn't exist"
                            (binding-ns 'cleo.compiler.def.test
                                        (cc/translate (cc/parse '(def cleo.compiler.def.test.other/nex)))))
  (do
    (binding-ns 'cleo.compiler.def.test
                (translate-body '(def existing 7)))
    (assert= 10 cleo.compiler.def.test/existing)))


(deftest translate-recur
  (assert= {:arity 0
            :bytecode [vm/BR 253 255]}
           (translate-body '(fn* [] (recur))))
  (assert= {:arity 1
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/STL 255 255
                       vm/BR (- 256 9) 255]}
           (translate-body '(fn* [x] (recur 10))))
  (assert= {:arity 3
            :consts [10]
            :bytecode [vm/LDC 0 0
                       vm/LDL 255 255
                       vm/LDL 253 255
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/STL 253 255
                       vm/BR (- 256 21) 255]}
           (translate-body '(fn* [x y z] (recur 10 z x))))
  (assert= {:arity 2
            :bytecode [vm/LDL 255 255
                       vm/BNIL 23 0
                       vm/LDL 254 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 1
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/BR (- 256 26) 255
                       vm/BR 1 0
                       vm/CNIL]}
           (translate-body '(fn* [f x] (if x (recur f (f x))))))
  (assert= {:arity 2
            :vararg :true
            :consts [1 2]
            :bytecode [vm/LDC 0 0
                       vm/LDC 1 0
                       vm/STL 255 255
                       vm/STL 254 255
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [x & xs] (recur 1 2))))
  (assert= {:arity 0
            :bytecode [vm/BR 253 255]}
           (translate-body '(fn* [] (loop* [] (recur)))))
  (assert= {:arity 3
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/LDL 253 255
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/STL 1 0
                       vm/LDL 1 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/STL 0 0
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [a b f] (do (f) (loop* [x a y b] (recur y x))))))
  (assert= {:arity 1
            :locals-size 2
            :bytecode [vm/LDL 255 255
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/STL 1 0
                       vm/LDL 1 0
                       vm/STL 0 0
                       vm/BR (- 256 15) 255]}
           (translate-body '(fn* [x] (loop* [a x] (let* [b a] (recur b)))))))


(deftest translate-try-catch
  (assert= {:arity 2
            :locals-size 1
            :bytecode [vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/LDL 0 0
                       vm/CALL 1]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 8, :stack-size 0, :type Exception}]}
           (translate-body '(fn* [f g] (try* (f) (catch* Exception e (g e))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/LDL 0 0
                       vm/CALL 1
                       vm/BR 11 0
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/LDL 0 0
                       vm/CALL 1]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 8, :stack-size 0, :type Exception}
                              {:start-offset 0, :end-offset 19, :handler-offset 22, :stack-size 0, :type IllegalArgument}]}
           (translate-body '(fn* [f g h] (try* (try* (f) (catch* Exception e (g e))) (catch* IllegalArgument e (h e))))))
  (assert= {:arity 2
            :locals-size 3
            :bytecode [vm/LDL 254 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/CALL 0
                       vm/BR 11 0
                       vm/STL 2 0
                       vm/LDL 1 0
                       vm/LDL 2 0
                       vm/CALL 1]
            :exception-table [{:start-offset 12, :end-offset 17, :handler-offset 20, :stack-size 0, :type Exception}]}
           (translate-body '(fn* [a b] (let* [f a g b] (try* (f) (catch* Exception e (g e)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/CALL 1]
            :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}]}
           (translate-body '(fn* [f g x] (f (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/CALL 3]
            :exception-table [{:start-offset 9, :end-offset 14, :handler-offset 17, :stack-size 3, :type Exception}]}
           (translate-body '(fn* [f g x] (f x g (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 255 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 8 0
                       vm/STL 0 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/APPLY 2]
            :exception-table [{:start-offset 9, :end-offset 14, :handler-offset 17, :stack-size 3, :type Exception}]}
           (translate-body '(fn* [f g x] (cleo.core/apply f x g (try* (x) (catch* Exception e (g)))))))
  (assert= {:arity 3
            :locals-size 1
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/BR 6 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/BR 6 0
                       vm/STL 0 0
                       vm/LDL 0 0
                       vm/CALL 2]
            :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}
                              {:start-offset 17, :end-offset 22, :handler-offset 25, :stack-size 2, :type Exception}]}
           (translate-body '(fn* [f x y] (f (try* (x) (catch* Exception e e)) (try* (y) (catch* Exception e e))))))
  (let [body (binding-ns 'cleo.compiler.def.test
                         (translate-body '(fn* [x] (def z (try* (x) (catch* cleo.core/Exception e e))))))]
    (assert= {:arity 1
              :locals-size 1
              :consts [(resolve 'cleo.compiler.def.test/z)]
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/CALL 0
                         vm/BR 6 0
                         vm/STL 0 0
                         vm/LDL 0 0
                         vm/STVV]
              :exception-table [{:start-offset 3, :end-offset 8, :handler-offset 11, :stack-size 1, :type Exception}]}
             body)))


(deftest translate-try-finally
  (assert= {:arity 2
            :bytecode [vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}]}
           (translate-body '(fn* [f g] (try* (f) (finally* (g))))))
  (assert= {:arity 2
            :locals-size 2
            :bytecode [vm/LDL 254 255
                       vm/STL 0 0
                       vm/LDL 255 255
                       vm/STL 1 0
                       vm/LDL 0 0
                       vm/CALL 0
                       vm/LDL 1 0
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 1 0
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 12, :end-offset 17, :handler-offset 26, :stack-size 0}]}
           (translate-body '(fn* [a b] (let* [f a g b] (try* (f) (finally* (g)))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/CALL 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}
                              {:start-offset 0, :end-offset 21, :handler-offset 30, :stack-size 0}]}
           (translate-body '(fn* [f g h] (try* (try* (f) (finally* (g))) (finally* (h))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255
                       vm/LDL 254 255
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/CALL 2]
            :exception-table [{:start-offset 6, :end-offset 11, :handler-offset 20, :stack-size 2}]}
           (translate-body '(fn* [f g x] (f g (try* (x) (finally* (g)))))))
  (assert= {:arity 3
            :bytecode [vm/LDL 253 255 ; (f)
                       vm/CALL 0

                       vm/LDL 254 255 ; (g)
                       vm/CALL 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP

                       vm/BR 7 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP
                       vm/THROW

                       vm/POP

                       vm/BR 23 0
                       vm/LDL 254 255 ; (g)
                       vm/CALL 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP

                       vm/BR 7 0
                       vm/LDL 255 255 ; (h)
                       vm/CALL 0
                       vm/POP
                       vm/THROW

                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 5, :end-offset 10, :handler-offset 19, :stack-size 1}
                              {:start-offset 30, :end-offset 35, :handler-offset 44, :stack-size 2}
                              {:start-offset 0, :end-offset 5, :handler-offset 30, :stack-size 0}]}
           (translate-body '(fn* [f g h] (try* (f) (finally* (try* (g) (finally* (h))))))))
  (assert= {:arity 4
            :bytecode [vm/LDL 252 255
                       vm/CALL 0
                       vm/LDL 253 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 253 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW
                       vm/POP
                       vm/LDL 254 255
                       vm/CALL 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/BR 7 0
                       vm/LDL 255 255
                       vm/CALL 0
                       vm/POP
                       vm/THROW]
            :exception-table [{:start-offset 0, :end-offset 5, :handler-offset 14, :stack-size 0}
                              {:start-offset 22, :end-offset 27, :handler-offset 36, :stack-size 0}]}
           (translate-body '(fn* [f g h i] (do (try* (f) (finally* (g))) (try* (h) (finally* (i))))))))


(deftest translate-ifn
  (let [f (translate-body '(fn* [] (fn* [] 10)))]
    (assert= {:arity 0
              :bytecode [vm/LDC 0 0]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= [{:arity 0,
               :consts [10],
               :bytecode [vm/LDC 0 0]}]
             (-> f :consts first deserialize-fn :bodies))
    (assert (str-starts-with? (-> f :consts first deserialize-fn :name name) "anonfn--")))
  (let [f (translate-body '(fn* [x y] (fn* [] (x y))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (fn* [] (x 10 y y x 20 30))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [10 20 30 nil nil],
              :bytecode [vm/LDC 3 0
                         vm/LDC 0 0
                         vm/LDC 4 0
                         vm/LDC 4 0
                         vm/LDC 3 0
                         vm/LDC 1 0
                         vm/LDC 2 0
                         vm/CALL 6]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (let* [z x] (fn* [] (z x)))))]
    (assert= {:arity 2
              :locals-size 1
              :bytecode [vm/LDL 254 255
                         vm/STL 0 0
                         vm/LDC 0 0
                         vm/LDL 0 0
                         vm/LDL 254 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x y] (fn* ([] (x 10)) ([a] (a x y)) ([a & b] (b y)))))]
    (assert= {:arity 2
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= [{:arity 0
               :consts [10 nil nil]
               :bytecode [vm/LDC 1 0
                          vm/LDC 0 0
                          vm/CALL 1]}
              {:arity 1
               :consts [nil nil]
               :bytecode [vm/LDL 255 255
                          vm/LDC 0 0
                          vm/LDC 1 0
                          vm/CALL 2]}
              {:arity 2
               :vararg :true
               :consts [nil nil]
               :bytecode [vm/LDL 255 255
                          vm/LDC 1 0
                          vm/CALL 1]}]
             (-> f :consts first deserialize-fn :bodies)))
  (let [f (translate-body '(fn* [x] (fn* [x] (fn* [] x))))
        inner-f (-> f :consts first deserialize-fn :bodies first)]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0]}
             (dissoc f :consts))
    (assert= {:arity 1,
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/IFN 1]}
             (dissoc inner-f :consts))
    (assert= {:arity 0,
              :consts [nil],
              :bytecode [vm/LDC 0 0]}
             (-> inner-f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* [x] (fn* [y] (fn* [] (x y)))))
        inner-f (-> f :consts first deserialize-fn :bodies first)]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0
                         vm/LDL 255 255
                         vm/IFN 1]}
             (dissoc f :consts))
    (assert= {:arity 1,
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc inner-f :consts))
    (assert= {:arity 0,
              :consts [nil nil],
              :bytecode [vm/LDC 0 0
                         vm/LDC 1 0
                         vm/CALL 1]}
             (-> inner-f :consts first deserialize-fn :bodies first)))
  (let [f (translate-body '(fn* f1 [x] (fn* [] (f1 x 20))))]
    (assert= {:arity 1
              :bytecode [vm/LDC 0 0
                         vm/LDL 254 255
                         vm/LDL 255 255
                         vm/IFN 2]}
             (dissoc f :consts))
    (assert= 1 (-> f :consts count))
    (assert= {:arity 0,
              :consts [20 nil nil],
              :bytecode [vm/LDC 1 0
                         vm/LDC 2 0
                         vm/LDC 0 0
                         vm/CALL 2]}
             (-> f :consts first deserialize-fn :bodies first))))


(deftest eval-fn
  (let [f (binding-ns 'cleo.core.test
                      (cc/eval '(fn dummy [x & xs] (reduce + x xs))))]
    (assert= 4 (f 4))
    (assert= 10 (f 4 6))
    (assert= 19 (f 4 6 9)))
  (let [f (binding-ns 'cleo.core.test
                      (cc/eval '(fn dummy
                                  ([x y z] (+ x (- y z)))
                                  ([a b c & d] [a b c d])
                                  ([x] 10))))]
    (assert= 7 (f 8 4 5))
    (assert= 10 (f 8))
    (assert= '(1 2 3 (4)) (f 1 2 3 4)))
  (let [f (binding-ns 'cleo.core.test
                      (cc/eval '(fn dummy
                                  ([a] (try* (throw (IllegalArgument. "Bad")) (finally* (reset! a 5))))
                                  ([_ x] (try* (throw x) (catch* IllegalArgument e e))))))
        a (atom 1)]
    (assert-throws IllegalArgument (f a))
    (assert= 5 @a)
    (assert-throws IndexOutOfBounds (f 0 (IndexOutOfBounds.)))
    (assert= IllegalArgument (type (f 0 (IllegalArgument. "x"))))))


(defmacro get-var-value-at-macroexpansion [name]
  @(resolve name))


(def eval-var-value (atom nil))
(def eval-test-var1 :not-defined)
(def eval-test-var2 :not-defined)
(def eval-test-var3 :not-defined)
(defmacro make-do [& forms]
  (cons 'do forms))


(deftest eval
  (assert= 10 (cc/eval 10))
  (assert= 'abc (cc/eval ''abc)))


(deftest eval-do
  (assert= nil (cc/eval '(do)))

  (assert= (resolve 'cleo.core.test/eval-test-var1)
           (binding-ns 'cleo.core.test
                       (cc/eval '(do
                                   (def eval-test-var1 :before-expansion)
                                   (reset! eval-var-value (get-var-value-at-macroexpansion eval-test-var1))
                                   (def eval-test-var1 :after-expansion)))))
  (assert= :after-expansion @(resolve 'cleo.core.test/eval-test-var1))
  (assert= :before-expansion @eval-var-value)

  (assert= (resolve 'cleo.core.test/eval-test-var2)
           (binding-ns 'cleo.core.test
                       (cc/eval '(make-do
                                   (def eval-test-var2 :before-expansion)
                                   (reset! eval-var-value (get-var-value-at-macroexpansion eval-test-var2))
                                   (def eval-test-var2 :after-expansion)))))
  (assert= :after-expansion @(resolve 'cleo.core.test/eval-test-var2))
  (assert= :before-expansion @eval-var-value)

  (assert= (resolve 'cleo.core.test/eval-test-var3)
           (binding-ns 'cleo.core.test
                       (cc/eval '((fn* [] (do
                                            (def eval-test-var3 :before-expansion)
                                            (reset! eval-var-value (get-var-value-at-macroexpansion eval-test-var3))
                                            (def eval-test-var3 :after-expansion)))))))
  (assert= :after-expansion @(resolve 'cleo.core.test/eval-test-var3))
  (assert= :not-defined @eval-var-value))
