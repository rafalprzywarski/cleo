(ns cleo.core.test)


(def tests (atom {}))
(def current-test (atom nil))
(def failed-tests (atom #{}))


(def deftest
  (macro* deftest [name & body]
    `(swap! tests assoc* '~name (fn* ~name [] (do ~@body)))))


(def assert=
  (macro* assert= [expected actual]
    `(let* [expected-val# ~expected
            actual-val# ~actual]
       (if (= expected-val# actual-val#)
         nil
         (do
           (swap! failed-tests conj* @current-test)
           (println @current-test "assertion failed:" ~(pr-str actual) "expected to equal:" expected-val# "actual:" actual-val#))))))


(def assert
  (macro* assert [actual]
    `(let* [actual-val# ~actual]
       (if actual-val#
         nil
         (do
           (swap! failed-tests conj* @current-test)
           (println @current-test "assertion failed:" ~(pr-str actual) "expected to be true, actual:" actual-val#))))))


(def assert-not
  (macro* assert-not [actual]
    `(assert (not ~actual))))


(def assert-throws
  (macro* [expected actual]
    `(try*
      (let* [actual-val# ~actual]
        (do
          (swap! failed-tests conj* @current-test)
          (println @current-test "assertion failed:" ~(pr-str actual) "expected to throw" ~(pr-str expected) "actual value:" actual-val#)))
      (catch* ~expected ~'e nil))))


(def main
  (fn* main []
    (do
      (loop* [tests (seq @tests)]
        (if tests
          (do
            (reset! current-test ((first tests) 0))
            (((first tests) 1))
            (recur (next tests)))))
      (print "ok:" (- (count @tests) (count @failed-tests)))
      (if (< 0 (count @failed-tests))
        (print " failed:" (count @failed-tests)))
      (println)
      (if (= 0 (count @failed-tests)) 0 1))))


(deftest defmacro
  (assert= '(def sonia (macro* sonia [x] (do (a) (b) (c)))) (macroexpand '(defmacro sonia [x] (a) (b) (c))))
  (assert= '(def sonia (macro* sonia [x] (a))) (macroexpand '(defmacro sonia [x] (a))))
  (assert= '(def sonia (macro* sonia [x])) (macroexpand '(defmacro sonia [x]))))


(deftest let
  (assert= '(let* [a 1 b 2] (do (x) (y))) (macroexpand '(let [a 1 b 2] (x) (y))))
  (assert= '(let* [a 1 b 2] (x)) (macroexpand '(let [a 1 b 2] (x))))
  (assert= '(let* [a 1 b 2] nil) (macroexpand '(let [a 1 b 2]))))


(deftest fn
  (assert= '(fn* [a b] (do (x) (y))) (macroexpand '(fn [a b] (x) (y))))
  (assert= '(fn* abc [a b] (do (x) (y))) (macroexpand '(fn abc [a b] (x) (y))))
  (assert= '(fn* [a b] (x)) (macroexpand '(fn [a b] (x))))
  (assert= '(fn* abc [a b] (x)) (macroexpand '(fn abc [a b] (x))))
  (assert= '(fn* [a b]) (macroexpand '(fn [a b])))
  (assert= '(fn* abc [a b]) (macroexpand '(fn abc [a b])))
  (assert= '(fn* ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* abc ([a b] (do (x) (y))) ([z] (do (w) (q)))) (macroexpand '(fn abc ([a b] (x) (y)) ([z] (w) (q)))))
  (assert= '(fn* ([a b] (do (x) (y))) ([z])) (macroexpand '(fn ([a b] (x) (y)) ([z])))))


(deftest defn
  (assert= '(def abc (cleo.core/fn abc [a b] (x) (y))) (macroexpand '(defn abc [a b] (x) (y)))))


(deftest not
  (assert= nil (not 10))
  (assert= nil (not [1]))
  (assert= :true (not nil)))


(deftest or
  (assert= nil (or))
  (assert= 10 (or 10))
  (assert= nil (or nil))
  (assert= :x (or nil :x))
  (assert= :x (or :x :y))
  (assert= nil (or nil nil))
  (assert= :x (or nil nil :x))
  (assert= :y (or nil :y :x))
  (assert= :a (or :a nil :x))
  (assert= nil (or nil nil nil)))


(deftest and
  (assert= :true (and))
  (assert= 10 (and 10))
  (assert= nil (and nil))
  (assert= nil (and nil :x))
  (assert= nil (and :x nil))
  (assert= :y (and :x :y))
  (assert= nil (and nil nil))
  (assert= nil (and nil nil :x))
  (assert= nil (and nil :y :x))
  (assert= nil (and :a nil :x))
  (assert= :d (and :a :b :c :d)))


(deftest seq?
  (assert (seq? ()))
  (assert (seq? (list 1 2)))
  (assert (not (seq? nil)))
  (assert (not (seq? [1 2])))
  (assert (seq? (seq [1 2])))
  (assert (not (seq? #{1 2})))
  (assert (not (seq? {1 2})))
  (assert (not (seq? 10))))


(deftest when
  (assert= '(if x (do)) (macroexpand '(when x)))
  (assert= '(if x (do y)) (macroexpand '(when x y)))
  (assert= '(if x (do y z)) (macroexpand '(when x y z))))


(deftest cond
  (assert= nil (macroexpand '(cond)))
  (assert= `(if (~'= 1 2) (~'= 3 4) (cond)) (macroexpand '(cond (= 1 2) (= 3 4))))
  (assert= `(if :a :b (cond :c :d)) (macroexpand '(cond :a :b :c :d)))
  (assert-throws IllegalArgument (cond :a))
  (assert-throws IllegalArgument (cond (= 1 2) :b :c)))


(deftest bit-and
  (assert= (bit-and* 12345 54321) (bit-and 12345 54321))
  (assert= (bit-and* (bit-and* 12345 54321) 97553) (bit-and 12345 54321 97553))
  (assert= (bit-and* (bit-and* (bit-and* 12345 54321) 97553) 57753) (bit-and 12345 54321 97553 57753)))


(deftest bit-or
  (assert= (bit-or* 12345 54321) (bit-or 12345 54321))
  (assert= (bit-or* (bit-or* 12345 54321) 97553) (bit-or 12345 54321 97553))
  (assert= (bit-or* (bit-or* (bit-or* 12345 54321) 97553) 57753) (bit-or 12345 54321 97553 57753)))


(deftest bit-xor
  (assert= (bit-xor* 12345 54321) (bit-xor 12345 54321))
  (assert= (bit-xor* (bit-xor* 12345 54321) 97553) (bit-xor 12345 54321 97553))
  (assert= (bit-xor* (bit-xor* (bit-xor* 12345 54321) 97553) 57753) (bit-xor 12345 54321 97553 57753)))


(deftest bit-and-not
  (assert= (bit-and-not* 12345 54321) (bit-and-not 12345 54321))
  (assert= (bit-and-not* (bit-and-not* 12345 54321) 97553) (bit-and-not 12345 54321 97553))
  (assert= (bit-and-not* (bit-and-not* (bit-and-not* 12345 54321) 97553) 57753) (bit-and-not 12345 54321 97553 57753)))


(deftest even?
  (assert (even? 10))
  (assert-not (even? 11))
  (assert (even? -10))
  (assert-not (even? -11)))


(deftest odd?
  (assert (odd? 11))
  (assert-not (odd? 10))
  (assert (odd? -11))
  (assert-not (odd? -10)))


(deftest conj
  (assert= [] (conj))
  (assert= [10 20] (conj [10 20]))
  (assert= [10 20 30] (conj [10 20] 30))
  (assert= [10 20 30 40] (conj [10 20] 30 40))
  (assert= [10 20 30 40 50] (conj [10 20] 30 40 50))
  (assert= [10 20 nil nil] (conj [10 20] nil nil))
  (assert= nil (conj nil))
  (assert= '(20 10) (conj nil 10 20))
  (assert= '(nil) (conj nil nil)))


(deftest assoc
  (assert= {:a 1 :b 2} (assoc {:a 1} :b 2))
  (assert= {:a 1 :b 2 :c 3} (assoc {:a 1} :b 2 :c 3))
  (assert= {:a 1 :b 2 :c 3 :d 4} (assoc {:a 1} :b 2 :c 3 :d 4))
  (assert= {:a 1 :b 2} (assoc nil :a 1 :b 2))
  (assert-throws IllegalArgument (assoc {} :a 1 :b)))


(deftest dissoc
  (assert= {:a 1 :b 2} (dissoc {:a 1 :b 2}))
  (assert= {:a 1} (dissoc {:a 1 :b 2} :b))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3} :b :c))
  (assert= {:a 1} (dissoc {:a 1 :b 2 :c 3 :d 4} :b :c :d))
  (assert= nil (dissoc nil))
  (assert= nil (dissoc nil :a)))


(deftest every?
  (assert (every? odd? nil))
  (assert (every? odd? []))
  (assert (every? odd? [1 3 5]))
  (assert-not (every? odd? [2 3 5]))
  (assert-not (every? odd? [1 2 5]))
  (assert-not (every? odd? [1 3 2])))


(deftest some
  (let [pred (fn [x] (and (even? x) (pr-str x)))]
    (assert= nil (some pred nil))
    (assert= nil (some pred []))
    (assert= nil (some pred [1 3 5]))
    (assert= "4" (some pred [4 3 5]))
    (assert= "8" (some pred [1 8 5]))
    (assert= "10" (some pred [1 3 10]))))


(deftest if-let
  (assert= :a (if-let [x (seq [:a])] (first x)))
  (assert= nil (if-let [x (seq [])] (first x)))
  (assert= :a (if-let [x (seq [:a])] (first x) :b))
  (assert= :b (if-let [x (seq [])] (first x) :b)))


(deftest when-let
  (assert= nil (when-let [x (seq [:a])]))
  (assert= :a (when-let [x (seq [:a])] (+ 1 2) (first x)))
  (assert= nil (when-let [x (seq [])] (+ 1 2) (first x))))
