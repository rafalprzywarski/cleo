(ns cleo.compiler)


(def parse)


(defn- add-local [scope name]
  (let [next-local-index (get scope :next-local-index 0)]
    (-> scope
        (update :indexed-locals (fn [locals] (assoc locals name next-local-index)))
        (assoc :next-local-index (inc next-local-index)))))


(defn- parse-const [form]
  (if (map? form)
    {:tag :const
     :value form}
    form))


(defn- parse-symbol [scope s]
  (if-let [local-index (get (:indexed-locals scope) s)]
    {:tag :local
     :index local-index}
    {:tag :var
     :name s}))


(defn- parse-if [scope form]
  (let [form (next form)
        cond (if form
               (first form)
               (throw (CompilationError. "Too few arguments to if")))
        form (next form)
        then (if form
               (first form)
               (throw (CompilationError. "Too few arguments to if")))
        form (next form)
        else (first form)]
    (if (next form)
      (throw (CompilationError. "Too many arguments to if"))
      {:tag :if
       :cond (parse scope cond)
       :then (parse scope then)
       :else (parse scope else)})))


(defn- parse-do [scope form]
  {:tag :do
   :exprs (vec (map (fn [x] (parse scope x)) (next form)))})


(defn- parse-quote [form]
  (when (or (not (next form))
            (nnext form))
    (throw (CompilationError. (str "Wrong number of args (" (dec (count form)) ") passed to quote, form: " (pr-str form)))))
  (parse-const (second form)))


(defn- check-let-bindings [form]
  (let [bindings (next form)
        bindings (if bindings
                   (first bindings)
                   (throw (CompilationError. (str "Wrong number of args (" (dec (count form)) ") passed to let*, form: " (pr-str form)))))]
    (when (not (vector? bindings))
      (throw (CompilationError. "Bad binding form, expected vector")))
    (when (not (zero? (rem (count bindings) 2)))
      (throw (CompilationError. "Bad binding form, expected matched symbol expression pairs")))
    bindings))


(defn- parse-let-bindings [scope bindings]
  (loop [bindings (seq bindings)
         scope scope
         locals (transient [])]
    (if bindings
      (let [[name expr & more] bindings]
        (when (not (symbol? name))
          (throw (CompilationError. (str "Unsupported binding form: " name))))
        (when (namespace name)
          (throw (CompilationError. (str "Can't let qualified name: " name))))
        (recur more
               (add-local scope name)
               (conj! locals {:name name
                              :index (get scope :next-local-index 0)
                              :expr (parse scope expr)})))
      [scope (persistent! locals)])))


(defn- parse-let [scope form]
  (check-let-bindings form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :let,
     :locals locals,
     :exprs (vec (map (fn [x] (parse scope x)) (nnext form)))}))


(defn- parse-def [scope form]
  (let [form (next form)
        meta (first form)
        meta (if (map? meta) meta nil)
        form (if meta (next form) form)
        name (if form
               (first form)
               (throw (CompilationError. "Too few arguments to def")))
        form (next form)]
    (when (not (symbol? name))
      (throw (CompilationError. "First argument to def must be a Symbol")))
    (when (next form)
      (throw (CompilationError. "Too many arguments to def")))
    {:tag :def
     :name name
     :meta meta
     :expr (parse scope (first form))}))


(defn- parse-throw [scope form]
  (let [form (next form)]
    (when (not form)
      (throw (CompilationError. "Too few arguments to throw, expected a single value")))
    (when (next form)
      (throw (CompilationError. "Too many arguments to throw, expected a single value")))
    {:tag :throw
     :expr (parse scope (first form))}))


(defn- parse-dot [scope form]
  (let [fail (fn [] (throw (CompilationError. "Malformed member expression")))
        form (next form)
        expr (if form (parse scope (first form)) (fail))
        form (next form)
        member (if form (name (first form)) (fail))]
    (when (or (< (count member) 2)
              (not (= "-" (get member 0)))
              (next form))
      (fail))
    {:tag :dot
     :expr expr
     :member (symbol nil (subs member 1))}))


(defn- parse-call [scope form]
  {:tag :call,
   :fn (parse scope (first form))
   :args (vec (map (fn [x] (parse scope x)) (next form)))})


(defn- parse-seq [scope form]
  (if-let [form (seq form)]
    (let [f (first form)]
      (cond
        (= f 'if) (parse-if scope form)
        (= f 'do) (parse-do scope form)
        (= f 'quote) (parse-quote form)
        (= f 'let*) (parse-let scope form)
        (= f 'def) (parse-def scope form)
        (= f 'throw) (parse-throw scope form)
        (= f '.) (parse-dot scope form)
        :else (parse-call scope form)))
    ()))


(defn- is-const [form]
  (and (not (symbol? form))
       (not (seq? form))
       (or (and (not (vector? form))
                (not (set? form))
                (not (map? form)))
           (every? is-const form))))


(defn- split-vector-by-const [v]
  (if (every? is-const v)
    [v, nil]
    (loop [more (seq v)
           prefix (transient [])]
      (if (is-const (first more))
        (recur (next more) (conj! prefix (first more)))
        [(persistent! prefix) (vec more)]))))


(defn- parse-vector [scope form]
  (let [[prefix more] (split-vector-by-const form)]
    (if (seq more)
      (parse scope
             (list 'cleo.core/persistent!
                   (reduce (fn [call elem] (list 'cleo.core/conj! call elem))
                           (list 'cleo.core/transient prefix)
                           more)))
      form)))


(defn- split-set-by-const [s]
  (if (every? is-const s)
    [s, nil]
    (loop [s (seq s)
           subset #{}
           more (transient [])]
      (if s
        (if (is-const (first s))
          (recur (next s) (conj subset (first s)) more)
          (recur (next s) subset (conj! more (first s))))
        [subset (persistent! more)]))))


(defn- parse-set [scope form]
  (let [[subset more] (split-set-by-const form)]
    (if (seq more)
      (parse scope
             (reduce (fn [call elem] (list 'cleo.core/conj call elem))
                     subset
                     more))
      form)))


(defn- split-map-by-const [m]
  (if (every? is-const m)
    [m, nil]
    (loop [s (seq m)
           submap {}
           more (transient [])]
      (if s
        (let [kv (first s)]
          (if (is-const kv)
            (recur (next s) (assoc submap (first kv) (second kv)) more)
            (recur (next s) submap (conj! more (first s)))))
        [submap (persistent! more)]))))


(defn- parse-map [scope form]
  (let [[submap more] (split-map-by-const form)]
    (if (seq more)
      (parse scope
             (reduce (fn [call elem] (list 'cleo.core/assoc call (first elem) (second elem)))
                     submap
                     more))
      (parse-const form))) )


(defn parse
  ([form]
   (parse nil form))
  ([scope form]
   (let [form (macroexpand form)]
     (cond
       (symbol? form) (parse-symbol scope form)
       (seq? form) (parse-seq scope form)
       (vector? form) (parse-vector scope form)
       (set? form) (parse-set scope form)
       (map? form) (parse-map scope form)
       :else (parse-const form)))))
