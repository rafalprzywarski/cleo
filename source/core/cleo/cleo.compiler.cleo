(ns cleo.compiler)


(def parse)


(defn- fail [& msg]
  (throw (CompilationError. (apply str msg))))

(defn- add-local [scope name]
  (let [next-local-index (get scope :next-local-index 0)]
    (-> scope
        (update :indexed-locals (fn [locals] (assoc locals name next-local-index)))
        (assoc :next-local-index (inc next-local-index)))))


(defn- parse-const [form]
  (if (map? form)
    {:tag :const
     :value form}
    form))


(defn- parse-symbol [scope s]
  (if-let [local-index (get (:indexed-locals scope) s)]
    {:tag :local
     :index local-index}
    {:tag :var
     :name s}))


(defn- parse-if [scope form]
  (let [form (next form)
        cond (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        then (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        else (first form)]
    (if (next form)
      (fail "Too many arguments to if")
      {:tag :if
       :cond (parse scope cond)
       :then (parse scope then)
       :else (parse scope else)})))


(defn- parse-do [scope form]
  {:tag :do
   :exprs (vec (map (fn [x] (parse scope x)) (next form)))})


(defn- parse-quote [form]
  (when (or (not (next form))
            (nnext form))
    (fail "Wrong number of args (" (dec (count form)) ") passed to quote, form: " (pr-str form)))
  (parse-const (second form)))


(defn- check-let-bindings [name form]
  (let [bindings (next form)
        bindings (if bindings
                   (first bindings)
                   (fail "Wrong number of args (" (dec (count form)) ") passed to " name ", form: " (pr-str form)))]
    (when (not (vector? bindings))
      (fail "Bad binding form, expected vector"))
    (when (not (zero? (rem (count bindings) 2)))
      (fail "Bad binding form, expected matched symbol expression pairs"))
    bindings))


(defn- parse-let-bindings [scope bindings]
  (loop [bindings (seq bindings)
         scope scope
         locals (transient [])]
    (if bindings
      (let [[name expr & more] bindings]
        (when (not (symbol? name))
          (fail "Unsupported binding form: " name))
        (when (namespace name)
          (fail "Can't let qualified name: " name))
        (recur more
               (add-local scope name)
               (conj! locals {:name name
                              :index (get scope :next-local-index 0)
                              :expr (parse scope expr)})))
      [scope (persistent! locals)])))


(defn- parse-let [scope form]
  (check-let-bindings 'let* form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :let,
     :locals locals,
     :exprs (vec (map (fn [x] (parse scope x)) (nnext form)))}))


(defn- parse-loop [scope form]
  (check-let-bindings 'loop* form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :loop,
     :locals locals,
     :exprs (vec (map (fn [x] (parse scope x)) (nnext form)))}))


(defn- parse-def [scope form]
  (let [form (next form)
        meta (first form)
        meta (if (map? meta) meta nil)
        form (if meta (next form) form)
        name (if form
               (first form)
               (fail "Too few arguments to def"))
        form (next form)]
    (when (not (symbol? name))
      (fail "First argument to def must be a Symbol"))
    (when (next form)
      (fail "Too many arguments to def"))
    {:tag :def
     :name name
     :meta meta
     :expr (parse scope (first form))}))


(defn- parse-throw [scope form]
  (let [form (next form)]
    (when (not form)
      (fail "Too few arguments to throw, expected a single value"))
    (when (next form)
      (fail "Too many arguments to throw, expected a single value"))
    {:tag :throw
     :expr (parse scope (first form))}))


(defn- parse-dot [scope form]
  (let [fail (fn [] (fail "Malformed member expression"))
        form (next form)
        expr (if form (parse scope (first form)) (fail))
        form (next form)
        member (if form (name (first form)) (fail))]
    (when (or (< (count member) 2)
              (not (= "-" (get member 0)))
              (next form))
      (fail))
    {:tag :dot
     :expr expr
     :member (symbol nil (subs member 1))}))


(defn- parse-finally [scope ast form]
  (when (not form)
    (fail "missing finally* body"))
  (when (next form)
    (fail "Too many expressions in finally*, expected one"))
  (assoc ast :finally (parse scope (first form))))


(defn- parse-catch [scope ast form]
  (let [type (if form
               (first form)
               (fail "missing exception type in catch*"))
        form (next form)
        binding (if form
                  (first form)
                  (fail "missing exception binding in catch*"))
        form (next form)
        expr (if form
               (first form)
               (fail "missing catch* body"))]
    (when (next form)
      (fail "Too many expressions in catch*, expected one"))
    (assoc ast :catch {:type type
                       :local {:name binding, :index (get scope :next-local-index 0)} ; bad
                       :expr (parse (add-local scope binding) expr)})))


(defn- parse-try [scope form]
  (let [form (next form)
        expr (first form)
        ast {:tag :try
             :expr (parse scope expr)}
        form (next form)]
    (if form
      (let [form (if (next form)
                   (fail "Too many expressions in try*")
                   (first form))
            s (if (seq? form)
                (first form)
                (fail "expected catch* or finally* block in try*"))
            form (next form)]
        (cond
          (= s 'finally*) (parse-finally scope ast form)
          (= s 'catch*) (parse-catch scope ast form)
          :else  (fail "expected catch* or finally* block in try*")))
      (:expr ast))))


(defn- check-fn-params [params]
  (when (not (vector? params))
    (fail "Bad fn* param list, expected vector"))
  (doseq [p params]
    (when (not (symbol? p))
      (fail "fn* params must be symbols"))
    (when (namespace p)
      (fail "Can't user qualified name as parameter: " p)))
  (let [va (= '& (get params (- (count params) 2)))
        trailing-amp (= '& (get params (dec (count params))))
        rparams (filter (fn [p] (not= '& p)) params)]
    (when (and (not= (count rparams) (count params))
               (or (and (not va) (not trailing-amp))
                   (not= (inc (count rparams)) (count params))))
      (fail "Invalid parameter list"))
    [rparams va]))


(defn- parse-fn-body [scope form]
  (let [[params va] (check-fn-params (first form))
        form (next form)]
    (let [scope (reduce add-local scope params)
          params (vec (map (fn [p] {:name p, :index ((:indexed-locals scope) p)}) params))
          ast {:params params
               :expr (parse scope (first form))}]
      (when (next form)
        (fail "Too many forms passed to fn*"))
      (if va
        (assoc ast :vararg :true)
        ast))))


(defn- parse-fn [scope form]
  (let [form (next form)
        name (when (symbol? (first form)) (first form))
        form (if (symbol? name) (next form) form)
        bodies (if (and form (not (seq? (first form)))) (list form) form)
        bodies (vec (map (fn [body] (parse-fn-body scope body)) bodies))]
    {:tag :fn
     :name name
     :bodies bodies}))


(defn- parse-call [scope form]
  {:tag :call,
   :fn (parse scope (first form))
   :args (vec (map (fn [x] (parse scope x)) (next form)))})


(defn- parse-seq [scope form]
  (if-let [form (seq form)]
    (let [f (first form)]
      (cond
        (= f 'if) (parse-if scope form)
        (= f 'do) (parse-do scope form)
        (= f 'quote) (parse-quote form)
        (= f 'let*) (parse-let scope form)
        (= f 'loop*) (parse-loop scope form)
        (= f 'def) (parse-def scope form)
        (= f 'throw) (parse-throw scope form)
        (= f '.) (parse-dot scope form)
        (= f 'try*) (parse-try scope form)
        (= f 'fn*) (parse-fn scope form)
        :else (parse-call scope form)))
    ()))


(defn- is-const [form]
  (and (not (symbol? form))
       (not (seq? form))
       (or (and (not (vector? form))
                (not (set? form))
                (not (map? form)))
           (every? is-const form))))


(defn- split-vector-by-const [v]
  (if (every? is-const v)
    [v, nil]
    (loop [more (seq v)
           prefix (transient [])]
      (if (is-const (first more))
        (recur (next more) (conj! prefix (first more)))
        [(persistent! prefix) (vec more)]))))


(defn- parse-vector [scope form]
  (let [[prefix more] (split-vector-by-const form)]
    (if (seq more)
      (parse scope
             (list 'cleo.core/persistent!
                   (reduce (fn [call elem] (list 'cleo.core/conj! call elem))
                           (list 'cleo.core/transient prefix)
                           more)))
      form)))


(defn- split-set-by-const [s]
  (if (every? is-const s)
    [s, nil]
    (loop [s (seq s)
           subset #{}
           more (transient [])]
      (if s
        (if (is-const (first s))
          (recur (next s) (conj subset (first s)) more)
          (recur (next s) subset (conj! more (first s))))
        [subset (persistent! more)]))))


(defn- parse-set [scope form]
  (let [[subset more] (split-set-by-const form)]
    (if (seq more)
      (parse scope
             (reduce (fn [call elem] (list 'cleo.core/conj call elem))
                     subset
                     more))
      form)))


(defn- split-map-by-const [m]
  (if (every? is-const m)
    [m, nil]
    (loop [s (seq m)
           submap {}
           more (transient [])]
      (if s
        (let [kv (first s)]
          (if (is-const kv)
            (recur (next s) (assoc submap (first kv) (second kv)) more)
            (recur (next s) submap (conj! more (first s)))))
        [submap (persistent! more)]))))


(defn- parse-map [scope form]
  (let [[submap more] (split-map-by-const form)]
    (if (seq more)
      (parse scope
             (reduce (fn [call elem] (list 'cleo.core/assoc call (first elem) (second elem)))
                     submap
                     more))
      (parse-const form))) )


(defn parse
  ([form]
   (parse nil form))
  ([scope form]
   (let [form (macroexpand form)]
     (cond
       (symbol? form) (parse-symbol scope form)
       (seq? form) (parse-seq scope form)
       (vector? form) (parse-vector scope form)
       (set? form) (parse-set scope form)
       (map? form) (parse-map scope form)
       :else (parse-const form)))))
