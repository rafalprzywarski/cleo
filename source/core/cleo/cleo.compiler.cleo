(ns cleo.compiler)
(require 'cleo.vm)
(alias 'vm 'cleo.vm)


(def parse-form)


(defn- fail [& msg]
  (throw (CompilationError. (apply str msg))))


(defn- add-local-with-index [scope name]
  (let [index (get scope :next-local-index 0)]
    [(-> scope
         (update :indexed-locals (fn [locals] (assoc locals name index)))
         (assoc :next-local-index (inc index)))
     index]))


(defn- add-local [scope name]
  (first (add-local-with-index scope name)))


(defn- no-recur [scope]
  (dissoc scope :recur-size))


(defn- parse-const [form]
  (if (map? form)
    {:tag :const
     :value form}
    form))


(defn- parse-symbol [scope s]
  (if-let [local-index (get (:indexed-locals scope) s)]
    {:tag :local
     :index local-index}
    {:tag :var
     :name s}))


(defn- parse-if [scope form]
  (let [form (next form)
        cond (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        then (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        else (first form)]
    (if (next form)
      (fail "Too many arguments to if")
      {:tag :if
       :cond (parse-form (no-recur scope) cond)
       :then (parse-form scope then)
       :else (parse-form scope else)})))


(defn- parse-exprs [scope form]
  (let [nrscope (no-recur scope)]
    (loop [form form
           out (transient [])]
      (if form
        (recur (next form)
               (conj! out (parse-form (if (next form) nrscope scope) (first form))))
        (persistent! out)))))


(defn- parse-do [scope form]
  {:tag :do
   :exprs (parse-exprs scope (next form))})


(defn- parse-quote [form]
  (when (or (not (next form))
            (nnext form))
    (fail "Wrong number of args (" (dec (count form)) ") passed to quote, form: " (pr-str form)))
  (parse-const (second form)))


(defn- check-let-bindings [name form]
  (let [bindings (next form)
        bindings (if bindings
                   (first bindings)
                   (fail "Wrong number of args (" (dec (count form)) ") passed to " name ", form: " (pr-str form)))]
    (when (not (vector? bindings))
      (fail "Bad binding form, expected vector"))
    (when (not (zero? (rem (count bindings) 2)))
      (fail "Bad binding form, expected matched symbol expression pairs"))
    bindings))


(defn- parse-let-bindings [scope bindings]
  (loop [bindings (seq bindings)
         scope scope
         locals (transient [])]
    (if bindings
      (let [[name expr & more] bindings]
        (when (not (symbol? name))
          (fail "Unsupported binding form: " name))
        (when (namespace name)
          (fail "Can't let qualified name: " name))
        (let [[new-scope local-index] (add-local-with-index scope name)]
          (recur more
                 new-scope
                 (conj! locals {:name name
                                :index local-index
                                :expr (parse-form (no-recur scope) expr)}))))
      [scope (persistent! locals)])))


(defn- parse-let [scope form]
  (check-let-bindings 'let* form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :let,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-loop [scope form]
  (check-let-bindings 'loop* form)
  (let [[scope locals] (parse-let-bindings scope (second form))
        scope (assoc scope :recur-size (count locals))]
    {:tag :loop,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-def [scope form]
  (let [form (next form)
        meta (first form)
        meta (if (map? meta) meta nil)
        form (if meta (next form) form)
        name (if form
               (first form)
               (fail "Too few arguments to def"))
        form (next form)]
    (when (not (symbol? name))
      (fail "First argument to def must be a Symbol"))
    (when (next form)
      (fail "Too many arguments to def"))
    {:tag :def
     :name name
     :meta meta
     :expr (parse-form (no-recur scope) (first form))}))


(defn- parse-throw [scope form]
  (let [form (next form)]
    (when (not form)
      (fail "Too few arguments to throw, expected a single value"))
    (when (next form)
      (fail "Too many arguments to throw, expected a single value"))
    {:tag :throw
     :expr (parse-form scope (first form))}))


(defn- parse-dot [scope form]
  (let [fail (fn [] (fail "Malformed member expression"))
        form (next form)
        expr (if form (parse-form scope (first form)) (fail))
        form (next form)
        member (if form (name (first form)) (fail))]
    (when (or (< (count member) 2)
              (not (= "-" (get member 0)))
              (next form))
      (fail))
    {:tag :dot
     :expr expr
     :member (symbol nil (subs member 1))}))


(defn- parse-finally [scope ast form]
  (when (not form)
    (fail "missing finally* body"))
  (when (next form)
    (fail "Too many expressions in finally*, expected one"))
  (assoc ast :finally (parse-form (no-recur scope) (first form))))


(defn- parse-catch [scope ast form]
  (let [type (if form
               (first form)
               (fail "missing exception type in catch*"))
        form (next form)
        binding (if form
                  (first form)
                  (fail "missing exception binding in catch*"))
        form (next form)
        expr (if form
               (first form)
               (fail "missing catch* body"))]
    (when (next form)
      (fail "Too many expressions in catch*, expected one"))
    (let [[scope local-index] (add-local-with-index scope binding)]
      (assoc ast :catch {:type type
                         :local {:name binding, :index local-index}
                         :expr (parse-form (no-recur scope) expr)}))))


(defn- parse-try [scope form]
  (let [form (next form)
        expr (first form)
        ast {:tag :try
             :expr (parse-form (no-recur scope) expr)}
        form (next form)]
    (if form
      (let [form (if (next form)
                   (fail "Too many expressions in try*")
                   (first form))
            s (if (seq? form)
                (first form)
                (fail "expected catch* or finally* block in try*"))
            form (next form)]
        (cond
          (= s 'finally*) (parse-finally scope ast form)
          (= s 'catch*) (parse-catch scope ast form)
          :else  (fail "expected catch* or finally* block in try*")))
      (:expr ast))))


(defn- check-fn-params [params]
  (when (not (vector? params))
    (fail "Bad fn* param list, expected vector"))
  (doseq [p params]
    (when (not (symbol? p))
      (fail "fn* params must be symbols"))
    (when (namespace p)
      (fail "Can't user qualified name as parameter: " p)))
  (let [va (= '& (get params (- (count params) 2)))
        trailing-amp (= '& (get params (dec (count params))))
        rparams (filter (fn [p] (not= '& p)) params)]
    (when (and (not= (count rparams) (count params))
               (or (and (not va) (not trailing-amp))
                   (not= (inc (count rparams)) (count params))))
      (fail "Invalid parameter list"))
    [rparams va]))


(defn- parse-fn-body [scope form]
  (let [[params va] (check-fn-params (first form))
        form (next form)]
    (let [scope (reduce add-local scope params)
          scope (assoc scope :recur-size (count params))
          params (vec (map (fn [p] {:name p, :index ((:indexed-locals scope) p)}) params))
          ast {:params params
               :expr (parse-form scope (first form))}]
      (when (next form)
        (fail "Too many forms passed to fn*"))
      (if va
        (assoc ast :vararg :true)
        ast))))


(defn validate-overloads [bodies]
  (let [va-bodies (filter :vararg bodies)
        fa-bodies (filter (fn [b] (not (:vararg b))) bodies)]
    (when (< 1 (count va-bodies))
      (fail "Can't have more than 1 variadic overload"))
    (let [va-arity (if (seq va-bodies) (-> va-bodies first :params count))]
      (reduce (fn [arities {:keys [params vararg]}]
                (let [arity (count params)]
                  (when (and va-arity
                             (< (dec va-arity) arity))
                    (fail "Can't have fixed arity function with more params than variadic function"))
                  (when (arities arity)
                    (fail "Can't have 2 overloads with same arity"))
                  (conj arities arity)))
              #{}
              fa-bodies))))


(defn- parse-fn [scope form]
  (let [form (next form)
        name (when (symbol? (first form)) (first form))
        scope (if name (add-local scope name) scope)
        form (if (symbol? name) (next form) form)
        bodies (if (and form (not (seq? (first form)))) (list form) form)
        bodies (vec (map (fn [body] (parse-fn-body scope body)) bodies))]
    (validate-overloads bodies)
    (let [ast {:tag :fn
               :bodies bodies}
          ast (if name
                (assoc ast
                       :name name
                       :name-index (get (:indexed-locals scope) name))
                ast)]
      ast)))


(defn- parse-recur [scope form]
  (let [form (next form)]
    (when (not (:recur-size scope))
      (fail "Can only recur from tail position"))
    (when (not= (count form) (:recur-size scope))
      (fail "Mismatched argument count to recur, expected " (:recur-size scope) " args, got " (count form)))
    {:tag :recur
     :args (vec (map (fn [x] (parse-form scope x)) form))}))


(defn- parse-call [scope form]
  (let [scope (no-recur scope)]
    {:tag :call,
     :fn (parse-form scope (first form))
     :args (vec (map (fn [x] (parse-form scope x)) (next form)))}))


(defn- parse-seq [scope form]
  (if-let [form (seq form)]
    (let [f (first form)]
      (cond
        (= f 'if) (parse-if scope form)
        (= f 'do) (parse-do scope form)
        (= f 'quote) (parse-quote form)
        (= f 'let*) (parse-let scope form)
        (= f 'loop*) (parse-loop scope form)
        (= f 'def) (parse-def scope form)
        (= f 'throw) (parse-throw scope form)
        (= f '.) (parse-dot scope form)
        (= f 'try*) (parse-try scope form)
        (= f 'fn*) (parse-fn scope form)
        (= f 'recur) (parse-recur scope form)
        :else (parse-call scope form)))
    ()))


(defn- is-const [form]
  (and (not (symbol? form))
       (not (seq? form))
       (or (and (not (vector? form))
                (not (set? form))
                (not (map? form)))
           (every? is-const form))))


(defn- split-vector-by-const [v]
  (if (every? is-const v)
    [v, nil]
    (loop [more (seq v)
           prefix (transient [])]
      (if (is-const (first more))
        (recur (next more) (conj! prefix (first more)))
        [(persistent! prefix) (vec more)]))))


(defn- parse-vector [scope form]
  (let [[prefix more] (split-vector-by-const form)]
    (if (seq more)
      (parse-form scope
             (list 'cleo.core/persistent!
                   (reduce (fn [call elem] (list 'cleo.core/conj! call elem))
                           (list 'cleo.core/transient prefix)
                           more)))
      form)))


(defn- split-set-by-const [s]
  (if (every? is-const s)
    [s, nil]
    (loop [s (seq s)
           subset #{}
           more (transient [])]
      (if s
        (if (is-const (first s))
          (recur (next s) (conj subset (first s)) more)
          (recur (next s) subset (conj! more (first s))))
        [subset (persistent! more)]))))


(defn- parse-set [scope form]
  (let [[subset more] (split-set-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/conj call elem))
                     subset
                     more))
      form)))


(defn- split-map-by-const [m]
  (if (every? is-const m)
    [m, nil]
    (loop [s (seq m)
           submap {}
           more (transient [])]
      (if s
        (let [kv (first s)]
          (if (is-const kv)
            (recur (next s) (assoc submap (first kv) (second kv)) more)
            (recur (next s) submap (conj! more (first s)))))
        [submap (persistent! more)]))))


(defn- parse-map [scope form]
  (let [[submap more] (split-map-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/assoc call (first elem) (second elem)))
                     submap
                     more))
      (parse-const form))) )


(defn- parse-form
  ([scope form]
   (let [form (macroexpand form)]
     (cond
       (symbol? form) (parse-symbol scope form)
       (seq? form) (parse-seq scope form)
       (vector? form) (parse-vector scope form)
       (set? form) (parse-set scope form)
       (map? form) (parse-map scope form)
       :else (parse-const form)))))


(defn parse [form]
  (parse-form nil form))


(def translate-expr!)


(defn- intern [m val]
  (if (contains? m val)
    m
    (assoc m val (count m))))


(defn- conj-i16! [v n]
  (-> v
      (conj! (bit-and n 0xff))
      (conj! (bit-and (bit-shift-right n 8) 0xff))))


(defn- assoc-i16! [v off n]
  (-> v
      (assoc! off (bit-and n 0xff))
      (assoc! (inc off) (bit-and (bit-shift-right n 8) 0xff))))


(defn- translate-const! [{:keys [consts] :as body} val]
  (if val
    (let [consts (intern consts val)]
      (assoc body
             :consts consts
             :bytecode (-> (:bytecode body) (conj! vm/LDC) (conj! (get consts val)) (conj! 0))))
    (assoc body
           :bytecode (conj! (:bytecode body) vm/CNIL))))


(defn- serialize [m]
  (let [sm (loop [n (count m)
                  s (transient [])]
             (if (pos? n)
               (recur (dec n) (conj! s 0))
               s))]
    (persistent! (reduce (fn [s [val index]]
                           (assoc! s index val))
                         sm
                         m))))


(defn- translate-exprs! [body exprs]
  (reduce (fn [body expr]
            (-> body
                (assoc :bytecode (conj! (:bytecode body) vm/POP))
                (translate-expr! expr)))
          (translate-expr! body (first exprs))
          (next exprs)))


(defn- translate-do! [body {exprs :exprs}]
  (translate-exprs! body exprs))


(defn translate-var! [{:keys [vars] :as body} {name :name}]
  (let [v (resolve name)
        vars (intern vars v)
        opcode (if (:dynamic (meta v)) vm/LDDV vm/LDV)]
    (when (not v)
      (fail "unable to resolve symbol: " name))
    (when (:macro (meta v))
      (fail "Can't take value of a macro: " v))
    (when (and (:private (meta v))
               (not (identical? *ns* (:ns (meta v)))))
      (fail "var: " name " is not public"))
    (assoc body
           :vars vars
           :bytecode (-> (:bytecode body) (conj! opcode) (conj! (vars v)) (conj! 0)))))


(defn translate-local-index! [{:keys [parent-locals parent-local-loads] {locals :locals} :scope :as body} index]
  (if (contains? parent-locals index)
    (-> body
        (update :parent-local-loads (fn [pll] (conj! pll {:offset (count (:bytecode body)), :index index})))
        (update :bytecode (fn [bc] (-> bc (conj! vm/LDC) (conj-i16! 0)))))
    (update body :bytecode (fn [bc] (-> bc (conj! vm/LDL) (conj-i16! (locals index)))))))


(defn translate-local! [body {index :index}]
  (translate-local-index! body index))

(defn inc-stack-depth [body]
  (update body :scope (fn [s] (update s :stack-depth inc))))


(defn- push-scope [{scope :scope :as body}]
  (assoc body :scope (assoc scope :prev scope)))


(defn- pop-scope [body]
  (assoc body :scope (-> body :scope :prev)))


(defn translate-call! [body {:keys [fn args]}]
  (let [apply? (and (map? fn)
                    (= (:tag fn) :var)
                    (= (resolve (:name fn)) #'cleo.core/apply))
        arg-count (count args)
        fn (if apply? (first args) fn)
        args (if apply? (next args) args)
        opcode (if apply? vm/APPLY vm/CALL)
        body (push-scope body)
        body (translate-expr! body fn)
        body (inc-stack-depth body)
        body (reduce (fn [body arg] (-> body (translate-expr! arg) inc-stack-depth)) body args)
        body (pop-scope body)]
    (when (and apply?
               (< arg-count 2))
      (fail "Wrong number of args (" arg-count ") passed to cleo.core/apply"))
    (update body :bytecode (fn [bc]
                             (-> bc (conj! opcode) (conj! (if apply? (dec (count args)) (count args))))))))


(defn- add-tlocal [{{:keys [locals locals-size] :as scope} :scope :as body} index]
  [(assoc body
          :scope (assoc scope
                        :locals (assoc locals index locals-size)
                        :locals-size (inc locals-size))
          :locals-size (max (:locals-size body) (inc locals-size)))
   locals-size])


(defn- translate-binding! [body {:keys [index expr]}]
  (let [body (translate-expr! body expr)
        [body tindex] (add-tlocal body index)]
    (assoc body
           :bytecode (-> (:bytecode body) (conj! vm/STL) (conj! tindex) (conj! 0)))))


(defn- translate-let! [body {:keys [locals exprs]}]
  (let [body (push-scope body)
        body (reduce translate-binding! body locals)
        body (translate-exprs! body exprs)
        body (pop-scope body)]
    body))


(defn- translate-loop! [body {:keys [locals exprs]}]
  (let [body (push-scope body)
        recur-local-index (-> body :scope :locals-size)
        body (reduce translate-binding! body locals)
        body (assoc body :scope (assoc (:scope body)
                                       :recur-offset (count (:bytecode body))
                                       :recur-local-index recur-local-index))
        body (translate-exprs! body exprs)
        body (pop-scope body)]
    body))


(defn- translate-throw! [body {expr :expr}]
  (let [body (translate-expr! body expr)]
    (assoc body
           :bytecode (conj! (:bytecode body) vm/THROW))))


(defn- translate-if! [body {:keys [cond then else]}]
  (let [body (translate-expr! body cond)
        bnil-off (count (:bytecode body))
        body (assoc body :bytecode (-> (:bytecode body) (conj! vm/BNIL) (conj! 6) (conj! 0)))
        body (translate-expr! body then)
        br-off (count (:bytecode body))
        body (assoc body :bytecode (-> (:bytecode body) (conj! vm/BR) (conj! 3) (conj! 0)))
        body (translate-expr! body else)
        bytecode (:bytecode body)
        body (assoc body
                    :bytecode (-> bytecode
                                  (assoc! (inc bnil-off) (- br-off bnil-off))
                                  (assoc! (inc br-off) (- (- (count bytecode) br-off) 3))))]
    body))


(defn- translate-dot! [body {:keys [expr member]}]
  (let [body (translate-expr! body expr)
        body (translate-const! body member)
        body (assoc body :bytecode (conj! (:bytecode body) vm/LDDF))]
    body))


(defn- translate-def! [body {:keys [meta name expr]}]
  (let [body (translate-const! body name)
        body (inc-stack-depth body)
        cur-ns-name (str (ns-name *ns*))
        sym-ns (namespace name)]
    (when (and sym-ns
               (not= sym-ns cur-ns-name))
      (fail (if (resolve name) "Can't create defs outside of current ns" "Can't refer to qualified var that doesn't exist")))
    (define-var (symbol cur-ns-name (str name)) meta)
    (let [body (translate-expr! body expr)
          body (translate-const! body meta)
          body (assoc body :bytecode (conj! (:bytecode body) vm/SETV))]
      body)))


(defn- translate-reassign-locals! [body first-index n]
  (assoc body
         :bytecode (loop [i n
                          bytecode (:bytecode body)]
                     (if (pos? i)
                       (recur (dec i) (-> bytecode (conj! vm/STL) (conj-i16! (+ first-index (dec i)))))
                       bytecode))))


(defn- translate-recur! [body {args :args}]
  (let [body (reduce translate-expr! body args)
        recur-local-index (-> body :scope :recur-local-index)
        body (translate-reassign-locals! body recur-local-index (count args))
        br-off (count (:bytecode body))
        recur-off (-> body :scope :recur-offset)]
    (assoc body :bytecode (-> body :bytecode (conj! vm/BR) (conj-i16! (- (- recur-off br-off) 3))))))


(defn- translate-try-catch! [body {expr :expr {catch-expr :expr {catch-index :index} :local type :type} :catch}]
  (let [stack-size (-> body :scope :stack-depth)
        start-off (count (:bytecode body))
        body (translate-expr! body expr)
        body (push-scope body)
        [body tindex] (add-tlocal body catch-index)
        br-off (count (:bytecode body))
        body (assoc body :bytecode (-> body :bytecode (conj! vm/BR) (conj-i16! 0) (conj! vm/STL) (conj-i16! tindex)))
        body (translate-expr! body catch-expr)
        body (update body :bytecode (fn [bc] (assoc-i16! bc (inc br-off) (-> (count bc) (- br-off) (- 3)))))
        body (pop-scope body)
        body (update body :exception-table (fn [et]
                                             (conj! et {:start-offset start-off
                                                        :end-offset br-off
                                                        :handler-offset (+ br-off 3)
                                                        :stack-size stack-size
                                                        :type @(resolve type)})))]
    body))


(defn- translate-try-finally! [body {expr :expr finally-expr :finally}]
  (let [stack-size (-> body :scope :stack-depth)
        start-off (count (:bytecode body))
        body (translate-expr! body expr)
        body (push-scope body)
        body (inc-stack-depth body)
        end-off (count (:bytecode body))
        body (translate-expr! body finally-expr)
        body (update body :bytecode (fn [bc] (conj! bc vm/POP)))
        br-off (count (:bytecode body))
        body (update body :bytecode (fn [bc] (-> bc (conj! vm/BR) (conj-i16! 0))))
        body (inc-stack-depth body)
        body (translate-expr! body finally-expr)
        body (pop-scope body)
        body (update body :bytecode (fn [bc] (-> bc (conj! vm/POP) (conj! vm/THROW))))
        body (update body :bytecode (fn [bc] (assoc-i16! bc (inc br-off) (-> (count bc) (- br-off) (- 3)))))
        body (update body :exception-table (fn [et]
                                             (conj! et {:start-offset start-off
                                                        :end-offset end-off
                                                        :handler-offset (+ br-off 3)
                                                        :stack-size stack-size})))]
    body))


(defn- translate-try! [body expr]
  ((if (:catch expr) translate-try-catch! translate-try-finally!) body expr))


(def translate-fn)


(defn- translate-ifn! [body expr]
  (let [parent-locals (merge (or (:parent-locals body) {}) (-> body :scope :locals))
        tfn (translate-fn parent-locals expr)
        closed-parent-locals (-> tfn :closed-parent-locals)
        body (translate-const! body (serialize-fn tfn))
        body (reduce translate-local-index! body closed-parent-locals)]
    (if (empty? closed-parent-locals)
      body
      (update body :bytecode (fn [bc] (-> bc (conj! vm/IFN) (conj! (count closed-parent-locals))))))))


(defn- translate-expr! [body expr]
  (if (map? expr)
    (let [tag (:tag expr)]
      (cond (= tag :do) (translate-do! body expr)
            (= tag :var) (translate-var! body expr)
            (= tag :local) (translate-local! body expr)
            (= tag :call) (translate-call! body expr)
            (= tag :let) (translate-let! body expr)
            (= tag :loop) (translate-loop! body expr)
            (= tag :throw) (translate-throw! body expr)
            (= tag :if) (translate-if! body expr)
            (= tag :dot) (translate-dot! body expr)
            (= tag :def) (translate-def! body expr)
            (= tag :recur) (translate-recur! body expr)
            (= tag :try) (translate-try! body expr)
            (= tag :fn) (translate-ifn! body expr)
            :else (translate-const! body (:value expr))))
    (translate-const! body expr)))


(defn- make-locals [name-index params]
  (loop [index (- (count params))
         params (seq params)
         locals (if name-index {name-index (dec index)} {})]
    (if params
      (recur (inc index) (next params) (assoc locals (:index (first params)) index))
      locals)))


(defn- dissoc-empty [m k]
  (if (empty? (get m k))
    (dissoc m k)
    m))


(defn- translate-body [parent-locals fn-name-index {:keys [expr params vararg]}]
  (let [tbody {:arity (count params)
               :parent-locals parent-locals
               :parent-local-loads (transient [])
               :scope {:locals (make-locals fn-name-index params)
                       :locals-size 0
                       :recur-offset 0
                       :recur-local-index (- (count params))
                       :stack-depth 0}
               :locals-size 0
               :bytecode (transient [])
               :exception-table (transient [])}
        tbody (if vararg (assoc tbody :vararg :true) tbody)
        tbody (translate-expr! tbody expr)
        tbody (update tbody :bytecode persistent!)
        tbody (update tbody :exception-table persistent!)
        tbody (update tbody :consts serialize)
        tbody (update tbody :parent-local-loads persistent!)
        tbody (update tbody :vars serialize)
        tbody (if (zero? (:locals-size tbody))
                (dissoc tbody :locals-size)
                tbody)
        tbody (dissoc tbody :scope :parent-locals)
        tbody (-> tbody
                  (dissoc-empty :consts)
                  (dissoc-empty :vars)
                  (dissoc-empty :exception-table)
                  (dissoc-empty :parent-local-loads))]
    tbody))


(defn conj-nils! [n v]
  (loop [n n
         v (transient v)]
    (if (not (pos? n))
      (persistent! v)
      (recur (dec n) (conj! v nil)))))


(defn init-loads [{:keys [consts parent-local-loads] :as body} closed-parent-locals]
  (let [const-base (count consts)]
    (-> body
        (update :consts (fn [c] (conj-nils! (count closed-parent-locals) (or c []))))
        (update :bytecode (fn [bc]
                            (persistent! (reduce (fn [bc {:keys [index offset]}]
                                                   (assoc-i16! bc (inc offset) (+ const-base (closed-parent-locals index))))
                                                 (transient bc)
                                                 parent-local-loads)))))))


(defn intern-parent-locals [bodies]
  (reduce (fn [pls b]
            (reduce intern pls (map :index (:parent-local-loads b))))
          {}
          bodies))

(defn translate-fn [parent-locals {:keys [name name-index bodies]}]
  (let [tbodies (mapv (fn [body] (translate-body parent-locals name-index body)) bodies)
        closed-parent-locals (intern-parent-locals tbodies)
        tbodies (if (empty? closed-parent-locals)
                  tbodies
                  (mapv (fn [b] (init-loads b closed-parent-locals)) tbodies))
        f {:bodies tbodies}
        f (if (empty? closed-parent-locals)
            f
            (assoc f :closed-parent-locals (serialize closed-parent-locals)))
        f (if name
            (assoc f :name name)
            f)]
    f))


(defn translate [ast]
  (let [ast (if (or (not (map? ast))
                    (not= :fn (:tag ast)))
              {:tag :fn
               :bodies [{:params [], :expr ast}]}
              ast)]
    (translate-fn nil ast)))


(defn compile [form]
  (-> form
      parse
      translate
      serialize-fn))
