(ns cleo.compiler)
(require 'cleo.vm)
(alias 'vm 'cleo.vm)


(def parse-form)


(defn- fail [& msg]
  (throw (CompilationError. (apply str msg))))


(defn- add-local-with-index [scope name]
  (let [index (get scope :next-local-index 0)]
    [(-> scope
         (update :indexed-locals (fn [locals] (assoc locals name index)))
         (assoc :next-local-index (inc index)))
     index]))


(defn- add-local [scope name]
  (first (add-local-with-index scope name)))


(defn- no-recur [scope]
  (dissoc scope :recur-size))


(defn- parse-const [form]
  (if (map? form)
    {:tag :const
     :value form}
    form))


(defn- parse-symbol [scope s]
  (if-let [local-index (get (:indexed-locals scope) s)]
    {:tag :local
     :index local-index}
    {:tag :var
     :name s}))


(defn- parse-if [scope form]
  (let [form (next form)
        cond (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        then (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        else (first form)]
    (if (next form)
      (fail "Too many arguments to if")
      {:tag :if
       :cond (parse-form (no-recur scope) cond)
       :then (parse-form scope then)
       :else (parse-form scope else)})))


(defn- parse-exprs [scope form]
  (let [nrscope (no-recur scope)]
    (loop [form form
           out (transient [])]
      (if form
        (recur (next form)
               (conj! out (parse-form (if (next form) nrscope scope) (first form))))
        (persistent! out)))))


(defn- parse-do [scope form]
  {:tag :do
   :exprs (parse-exprs scope (next form))})


(defn- parse-quote [form]
  (when (or (not (next form))
            (nnext form))
    (fail "Wrong number of args (" (dec (count form)) ") passed to quote, form: " (pr-str form)))
  (parse-const (second form)))


(defn- check-let-bindings [name form]
  (let [bindings (next form)
        bindings (if bindings
                   (first bindings)
                   (fail "Wrong number of args (" (dec (count form)) ") passed to " name ", form: " (pr-str form)))]
    (when (not (vector? bindings))
      (fail "Bad binding form, expected vector"))
    (when (not (zero? (rem (count bindings) 2)))
      (fail "Bad binding form, expected matched symbol expression pairs"))
    bindings))


(defn- parse-let-bindings [scope bindings]
  (loop [bindings (seq bindings)
         scope scope
         locals (transient [])]
    (if bindings
      (let [[name expr & more] bindings]
        (when (not (symbol? name))
          (fail "Unsupported binding form: " name))
        (when (namespace name)
          (fail "Can't let qualified name: " name))
        (let [[new-scope local-index] (add-local-with-index scope name)]
          (recur more
                 new-scope
                 (conj! locals {:name name
                                :index local-index
                                :expr (parse-form (no-recur scope) expr)}))))
      [scope (persistent! locals)])))


(defn- parse-let [scope form]
  (check-let-bindings 'let* form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :let,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-loop [scope form]
  (check-let-bindings 'loop* form)
  (let [[scope locals] (parse-let-bindings scope (second form))
        scope (assoc scope :recur-size (count locals))]
    {:tag :loop,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-def [scope form]
  (let [form (next form)
        meta (first form)
        meta (if (map? meta) meta nil)
        form (if meta (next form) form)
        name (if form
               (first form)
               (fail "Too few arguments to def"))
        form (next form)]
    (when (not (symbol? name))
      (fail "First argument to def must be a Symbol"))
    (when (next form)
      (fail "Too many arguments to def"))
    {:tag :def
     :name name
     :meta meta
     :expr (parse-form (no-recur scope) (first form))}))


(defn- parse-throw [scope form]
  (let [form (next form)]
    (when (not form)
      (fail "Too few arguments to throw, expected a single value"))
    (when (next form)
      (fail "Too many arguments to throw, expected a single value"))
    {:tag :throw
     :expr (parse-form scope (first form))}))


(defn- parse-dot [scope form]
  (let [fail (fn [] (fail "Malformed member expression"))
        form (next form)
        expr (if form (parse-form scope (first form)) (fail))
        form (next form)
        member (if form (name (first form)) (fail))]
    (when (or (< (count member) 2)
              (not (= "-" (get member 0)))
              (next form))
      (fail))
    {:tag :dot
     :expr expr
     :member (symbol nil (subs member 1))}))


(defn- parse-finally [scope ast form]
  (when (not form)
    (fail "missing finally* body"))
  (when (next form)
    (fail "Too many expressions in finally*, expected one"))
  (assoc ast :finally (parse-form (no-recur scope) (first form))))


(defn- parse-catch [scope ast form]
  (let [type (if form
               (first form)
               (fail "missing exception type in catch*"))
        form (next form)
        binding (if form
                  (first form)
                  (fail "missing exception binding in catch*"))
        form (next form)
        expr (if form
               (first form)
               (fail "missing catch* body"))]
    (when (next form)
      (fail "Too many expressions in catch*, expected one"))
    (let [[scope local-index] (add-local-with-index scope binding)]
      (assoc ast :catch {:type type
                         :local {:name binding, :index local-index}
                         :expr (parse-form (no-recur scope) expr)}))))


(defn- parse-try [scope form]
  (let [form (next form)
        expr (first form)
        ast {:tag :try
             :expr (parse-form (no-recur scope) expr)}
        form (next form)]
    (if form
      (let [form (if (next form)
                   (fail "Too many expressions in try*")
                   (first form))
            s (if (seq? form)
                (first form)
                (fail "expected catch* or finally* block in try*"))
            form (next form)]
        (cond
          (= s 'finally*) (parse-finally scope ast form)
          (= s 'catch*) (parse-catch scope ast form)
          :else  (fail "expected catch* or finally* block in try*")))
      (:expr ast))))


(defn- check-fn-params [params]
  (when (not (vector? params))
    (fail "Bad fn* param list, expected vector"))
  (doseq [p params]
    (when (not (symbol? p))
      (fail "fn* params must be symbols"))
    (when (namespace p)
      (fail "Can't user qualified name as parameter: " p)))
  (let [va (= '& (get params (- (count params) 2)))
        trailing-amp (= '& (get params (dec (count params))))
        rparams (filter (fn [p] (not= '& p)) params)]
    (when (and (not= (count rparams) (count params))
               (or (and (not va) (not trailing-amp))
                   (not= (inc (count rparams)) (count params))))
      (fail "Invalid parameter list"))
    [rparams va]))


(defn- parse-fn-body [scope form]
  (let [[params va] (check-fn-params (first form))
        form (next form)]
    (let [scope (reduce add-local scope params)
          scope (assoc scope :recur-size (count params))
          params (vec (map (fn [p] {:name p, :index ((:indexed-locals scope) p)}) params))
          ast {:params params
               :expr (parse-form scope (first form))}]
      (when (next form)
        (fail "Too many forms passed to fn*"))
      (if va
        (assoc ast :vararg :true)
        ast))))


(defn- parse-fn [scope form]
  (let [form (next form)
        name (when (symbol? (first form)) (first form))
        form (if (symbol? name) (next form) form)
        bodies (if (and form (not (seq? (first form)))) (list form) form)
        bodies (vec (map (fn [body] (parse-fn-body scope body)) bodies))]
    {:tag :fn
     :name name
     :bodies bodies}))


(defn- parse-recur [scope form]
  (let [form (next form)]
    (when (not (:recur-size scope))
      (fail "Can only recur from tail position"))
    (when (not= (count form) (:recur-size scope))
      (fail "Mismatched argument count to recur, expected " (:recur-size scope) " args, got " (count form)))
    {:tag :recur
     :args (vec (map (fn [x] (parse-form scope x)) form))}))


(defn- parse-call [scope form]
  (let [scope (no-recur scope)]
    {:tag :call,
     :fn (parse-form scope (first form))
     :args (vec (map (fn [x] (parse-form scope x)) (next form)))}))


(defn- parse-seq [scope form]
  (if-let [form (seq form)]
    (let [f (first form)]
      (cond
        (= f 'if) (parse-if scope form)
        (= f 'do) (parse-do scope form)
        (= f 'quote) (parse-quote form)
        (= f 'let*) (parse-let scope form)
        (= f 'loop*) (parse-loop scope form)
        (= f 'def) (parse-def scope form)
        (= f 'throw) (parse-throw scope form)
        (= f '.) (parse-dot scope form)
        (= f 'try*) (parse-try scope form)
        (= f 'fn*) (parse-fn scope form)
        (= f 'recur) (parse-recur scope form)
        :else (parse-call scope form)))
    ()))


(defn- is-const [form]
  (and (not (symbol? form))
       (not (seq? form))
       (or (and (not (vector? form))
                (not (set? form))
                (not (map? form)))
           (every? is-const form))))


(defn- split-vector-by-const [v]
  (if (every? is-const v)
    [v, nil]
    (loop [more (seq v)
           prefix (transient [])]
      (if (is-const (first more))
        (recur (next more) (conj! prefix (first more)))
        [(persistent! prefix) (vec more)]))))


(defn- parse-vector [scope form]
  (let [[prefix more] (split-vector-by-const form)]
    (if (seq more)
      (parse-form scope
             (list 'cleo.core/persistent!
                   (reduce (fn [call elem] (list 'cleo.core/conj! call elem))
                           (list 'cleo.core/transient prefix)
                           more)))
      form)))


(defn- split-set-by-const [s]
  (if (every? is-const s)
    [s, nil]
    (loop [s (seq s)
           subset #{}
           more (transient [])]
      (if s
        (if (is-const (first s))
          (recur (next s) (conj subset (first s)) more)
          (recur (next s) subset (conj! more (first s))))
        [subset (persistent! more)]))))


(defn- parse-set [scope form]
  (let [[subset more] (split-set-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/conj call elem))
                     subset
                     more))
      form)))


(defn- split-map-by-const [m]
  (if (every? is-const m)
    [m, nil]
    (loop [s (seq m)
           submap {}
           more (transient [])]
      (if s
        (let [kv (first s)]
          (if (is-const kv)
            (recur (next s) (assoc submap (first kv) (second kv)) more)
            (recur (next s) submap (conj! more (first s)))))
        [submap (persistent! more)]))))


(defn- parse-map [scope form]
  (let [[submap more] (split-map-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/assoc call (first elem) (second elem)))
                     submap
                     more))
      (parse-const form))) )


(defn- parse-form
  ([scope form]
   (let [form (macroexpand form)]
     (cond
       (symbol? form) (parse-symbol scope form)
       (seq? form) (parse-seq scope form)
       (vector? form) (parse-vector scope form)
       (set? form) (parse-set scope form)
       (map? form) (parse-map scope form)
       :else (parse-const form)))))


(defn parse [form]
  (parse-form nil form))


(def translate-expr!)


(defn- intern-const [consts value]
  (if (contains? consts value)
    consts
    (assoc consts value (count consts))))


(defn- translate-const! [{:keys [bytecode consts] :as body} val]
  (if val
    (let [consts (intern-const consts val)]
      (assoc body
             :consts consts
             :bytecode (-> bytecode (conj! vm/LDC) (conj! (get consts val)) (conj! 0))))
    (assoc body
           :bytecode (conj! bytecode vm/CNIL))))


(defn- serialize-consts [consts]
  (let [sconsts (loop [n (count consts)
                       s (transient [])]
                  (if (pos? n)
                    (recur (dec n) (conj! s 0))
                    s))]
    (persistent! (reduce (fn [s [val index]]
                           (assoc! s index val))
                         sconsts
                         consts))))


(defn- translate-do! [body {exprs :exprs}]
  (reduce (fn [body expr]
            (-> body
                (assoc :bytecode (conj! (:bytecode body) vm/POP))
                (translate-expr! expr)))
          (translate-expr! body (first exprs))
          (next exprs)))


(defn- translate-expr! [{:keys [bytecode consts] :as body} expr]
  (if (map? expr)
    (let [tag (:tag expr)]
      (cond (= tag :do) (translate-do! body expr)
            :else (translate-const! body (:value expr))))
    (translate-const! body expr)))


(defn- translate-body [{:keys [expr params]}]
  (let [tbody {:arity (count params)
               :bytecode (transient [])}
        tbody (translate-expr! tbody expr)
        tbody (update tbody :bytecode persistent!)
        tbody (update tbody :consts serialize-consts)
        tbody (if (not (seq (:consts tbody)))
                (dissoc tbody :consts)
                tbody)]
    tbody))


(defn translate-fn [{:keys [name bodies]}]
  (let [f {:bodies (mapv translate-body bodies)}]
    (if name
      (assoc f :name name)
      f)))


(defn translate [ast]
  (let [ast (if (or (not (map? ast))
                    (not= :fn (:tag ast)))
              {:tag :fn
               :bodies [{:params [], :expr ast}]}
              ast)]
    (translate-fn ast)))
