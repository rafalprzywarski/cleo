(ns cleo.compiler)
(require 'cleo.vm)
(alias 'vm 'cleo.vm)


(def eval)
(def parse-form)


(defn- fail [& msg]
  (throw (CompilationError. (apply str msg))))


(defn- add-local-with-index [scope name]
  (let [index (get scope :next-local-index 0)]
    [(-> scope
         (update :indexed-locals (fn [locals] (assoc locals name index)))
         (assoc :next-local-index (inc index)))
     index]))


(defn- add-local [scope name]
  (first (add-local-with-index scope name)))


(defn- no-recur [scope]
  (dissoc scope :recur-size))


(defn- parse-const [form]
  (when form
    {:tag :const
     :value form}))


(defn- parse-symbol [scope s]
  (if-let [local-index (get (:indexed-locals scope) s)]
    {:tag :local
     :index local-index}
    {:tag :var
     :name s}))


(defn- parse-if [scope form]
  (let [form (next form)
        cond (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        then (if form
               (first form)
               (fail "Too few arguments to if"))
        form (next form)
        else (first form)]
    (if (next form)
      (fail "Too many arguments to if")
      {:tag :if
       :cond (parse-form (no-recur scope) cond)
       :then (parse-form scope then)
       :else (parse-form scope else)})))


(defn- parse-exprs [scope form]
  (let [nrscope (no-recur scope)]
    (loop [form form
           out (transient [])]
      (if form
        (recur (next form)
               (conj! out (parse-form (if (next form) nrscope scope) (first form))))
        (persistent! out)))))


(defn- parse-do [scope form]
  {:tag :do
   :exprs (parse-exprs scope (next form))})


(defn- parse-quote [form]
  (when (or (not (next form))
            (nnext form))
    (fail "Wrong number of args (" (dec (count form)) ") passed to quote, form: " (pr-str form)))
  (parse-const (second form)))


(defn- check-let-bindings [name form]
  (let [bindings (next form)
        bindings (if bindings
                   (first bindings)
                   (fail "Wrong number of args (" (dec (count form)) ") passed to " name ", form: " (pr-str form)))]
    (when (not (vector? bindings))
      (fail "Bad binding form, expected vector"))
    (when (not (zero? (rem (count bindings) 2)))
      (fail "Bad binding form, expected matched symbol expression pairs"))
    bindings))


(defn- parse-let-bindings [scope bindings]
  (loop [bindings (seq bindings)
         scope scope
         locals (transient [])]
    (if bindings
      (let [[name expr & more] bindings]
        (when (not (symbol? name))
          (fail "Unsupported binding form: " name))
        (when (namespace name)
          (fail "Can't let qualified name: " name))
        (let [[new-scope local-index] (add-local-with-index scope name)]
          (recur more
                 new-scope
                 (conj! locals {:name name
                                :index local-index
                                :expr (parse-form (no-recur scope) expr)}))))
      [scope (persistent! locals)])))


(defn- parse-let [scope form]
  (check-let-bindings 'let* form)
  (let [[scope locals] (parse-let-bindings scope (second form))]
    {:tag :let,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-loop [scope form]
  (check-let-bindings 'loop* form)
  (let [[scope locals] (parse-let-bindings scope (second form))
        scope (assoc scope :recur-size (count locals))]
    {:tag :loop,
     :locals locals,
     :exprs (parse-exprs scope (nnext form))}))


(defn- parse-def [scope form]
  (let [form (next form)
        meta (first form)
        meta (if (map? meta) meta nil)
        form (if meta (next form) form)
        name (if form
               (first form)
               (fail "Too few arguments to def"))
        form (next form)]
    (when (not (symbol? name))
      (fail "First argument to def must be a Symbol"))
    (when (next form)
      (fail "Too many arguments to def"))
    (let [ast {:tag :def
               :name name}
          ast (if meta (assoc ast :meta meta) ast)]
      (if form
        (assoc ast :expr (parse-form (no-recur scope) (first form)))
        ast))))


(defn- parse-throw [scope form]
  (let [form (next form)]
    (when (not form)
      (fail "Too few arguments to throw, expected a single value"))
    (when (next form)
      (fail "Too many arguments to throw, expected a single value"))
    {:tag :throw
     :expr (parse-form scope (first form))}))


(defn- parse-dot [scope form]
  (let [fail (fn [] (fail "Malformed member expression"))
        form (next form)
        expr (if form (parse-form scope (first form)) (fail))
        form (next form)
        member (if form (name (first form)) (fail))]
    (when (or (< (count member) 2)
              (not (= \- (get member 0)))
              (next form))
      (fail))
    {:tag :dot
     :expr expr
     :member (symbol nil (subs member 1))}))


(defn- parse-finally [scope ast form]
  (when (not form)
    (fail "missing finally* body"))
  (when (next form)
    (fail "Too many expressions in finally*, expected one"))
  (assoc ast :finally (parse-form (no-recur scope) (first form))))


(defn- parse-catch [scope ast form]
  (let [type (if form
               (first form)
               (fail "missing exception type in catch*"))
        form (next form)
        binding (if form
                  (first form)
                  (fail "missing exception binding in catch*"))
        form (next form)
        expr (if form
               (first form)
               (fail "missing catch* body"))]
    (when (next form)
      (fail "Too many expressions in catch*, expected one"))
    (let [[scope local-index] (add-local-with-index scope binding)]
      (assoc ast :catch {:type type
                         :local {:name binding, :index local-index}
                         :expr (parse-form (no-recur scope) expr)}))))


(defn- parse-try [scope form]
  (let [form (next form)
        expr (first form)
        ast {:tag :try
             :expr (parse-form (no-recur scope) expr)}
        form (next form)]
    (if form
      (let [form (if (next form)
                   (fail "Too many expressions in try*")
                   (first form))
            s (if (seq? form)
                (first form)
                (fail "expected catch* or finally* block in try*"))
            form (next form)]
        (cond
          (= s 'finally*) (parse-finally scope ast form)
          (= s 'catch*) (parse-catch scope ast form)
          :else  (fail "expected catch* or finally* block in try*")))
      (:expr ast))))


(defn- check-fn-params [params]
  (when (not (vector? params))
    (fail "Bad fn* param list, expected vector"))
  (doseq [p params]
    (when (not (symbol? p))
      (fail "fn* params must be symbols"))
    (when (namespace p)
      (fail "Can't user qualified name as parameter: " p)))
  (let [va (= '& (get params (- (count params) 2)))
        trailing-amp (= '& (get params (dec (count params))))
        rparams (filter (fn [p] (not= '& p)) params)]
    (when (and (not= (count rparams) (count params))
               (or (and (not va) (not trailing-amp))
                   (not= (inc (count rparams)) (count params))))
      (fail "Invalid parameter list"))
    [rparams va]))


(defn- parse-fn-body [scope form]
  (let [[params va] (check-fn-params (first form))
        form (next form)]
    (let [scope (reduce add-local scope params)
          scope (assoc scope :recur-size (count params))
          params (mapv (fn [p] {:name p, :index ((:indexed-locals scope) p)}) params)
          ast {:params params
               :expr (parse-form scope (first form))}]
      (when (next form)
        (fail "Too many forms passed to fn*"))
      (if va
        (assoc ast :vararg :true)
        ast))))


(defn validate-overloads [bodies]
  (let [va-bodies (filter :vararg bodies)
        fa-bodies (filter (fn [b] (not (:vararg b))) bodies)]
    (when (< 1 (count va-bodies))
      (fail "Can't have more than 1 variadic overload"))
    (let [va-arity (if (seq va-bodies) (-> va-bodies first :params count))]
      (reduce (fn [arities {:keys [params vararg]}]
                (let [arity (count params)]
                  (when (and va-arity
                             (< (dec va-arity) arity))
                    (fail "Can't have fixed arity function with more params than variadic function"))
                  (when (arities arity)
                    (fail "Can't have 2 overloads with same arity"))
                  (conj arities arity)))
              #{}
              fa-bodies))))


(defn- parse-fn [scope form]
  (let [form (next form)
        name (when (symbol? (first form)) (first form))
        scope (if name (add-local scope name) scope)
        form (if (symbol? name) (next form) form)
        bodies (if (and form (not (seq? (first form)))) (list form) form)
        bodies (mapv (fn [body] (parse-fn-body scope body)) bodies)]
    (validate-overloads bodies)
    (let [ast {:tag :fn
               :bodies bodies}
          ast (if name
                (assoc ast
                       :name name
                       :name-index (get (:indexed-locals scope) name))
                ast)]
      ast)))


(defn- parse-recur [scope form]
  (let [form (next form)]
    (when (not (:recur-size scope))
      (fail "Can only recur from tail position"))
    (when (not= (count form) (:recur-size scope))
      (fail "Mismatched argument count to recur, expected " (:recur-size scope) " args, got " (count form)))
    {:tag :recur
     :args (mapv (fn [x] (parse-form scope x)) form)}))


(defn- parse-call [scope form]
  (let [scope (no-recur scope)]
    {:tag :call,
     :fn (parse-form scope (first form))
     :args (mapv (fn [x] (parse-form scope x)) (next form))}))


(defn- parse-assign [scope form]
  (when (not= (count form) 3)
    (fail "Malformed set!, expected a target and an expression"))
  (let [scope (no-recur scope)
        form (next form)
        target (parse-form scope (first form))
        form (next form)
        arg (parse-form scope (first form))]
    (when (not (#{:var :dot} (:tag target)))
      (fail "set! target must be a var or a field"))
    {:tag :assign
     :target target
     :arg arg}))


(defn- parse-seq [scope form]
  (if-let [form (seq form)]
    (let [f (first form)]
      (cond
        (= f 'if) (parse-if scope form)
        (= f 'do) (parse-do scope form)
        (= f 'quote) (parse-quote form)
        (= f 'let*) (parse-let scope form)
        (= f 'loop*) (parse-loop scope form)
        (= f 'def) (parse-def scope form)
        (= f 'throw) (parse-throw scope form)
        (= f '.) (parse-dot scope form)
        (= f 'try*) (parse-try scope form)
        (= f 'fn*) (parse-fn scope form)
        (= f 'recur) (parse-recur scope form)
        (= f 'set!) (parse-assign scope form)
        :else (parse-call scope form)))
    (parse-const ())))


(defn- is-const [form]
  (and (not (symbol? form))
       (not (seq? form))
       (or (and (not (vector? form))
                (not (set? form))
                (not (map? form)))
           (every? is-const form))))


(defn- split-vector-by-const [v]
  (if (every? is-const v)
    [v, nil]
    (loop [more (seq v)
           prefix (transient [])]
      (if (is-const (first more))
        (recur (next more) (conj! prefix (first more)))
        [(persistent! prefix) (vec more)]))))


(defn- parse-vector [scope form]
  (let [[prefix more] (split-vector-by-const form)]
    (if (seq more)
      (parse-form scope
             (list 'cleo.core/persistent!
                   (reduce (fn [call elem] (list 'cleo.core/conj! call elem))
                           (list 'cleo.core/transient prefix)
                           more)))
      (parse-const form))))


(defn- split-set-by-const [s]
  (if (every? is-const s)
    [s, nil]
    (loop [s (seq s)
           subset #{}
           more (transient [])]
      (if s
        (if (is-const (first s))
          (recur (next s) (conj subset (first s)) more)
          (recur (next s) subset (conj! more (first s))))
        [subset (persistent! more)]))))


(defn- parse-set [scope form]
  (let [[subset more] (split-set-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/conj call elem))
                     subset
                     more))
      (parse-const form))))


(defn- split-map-by-const [m]
  (if (every? is-const m)
    [m, nil]
    (loop [s (seq m)
           submap {}
           more (transient [])]
      (if s
        (let [kv (first s)]
          (if (is-const kv)
            (recur (next s) (assoc submap (first kv) (second kv)) more)
            (recur (next s) submap (conj! more (first s)))))
        [submap (persistent! more)]))))


(defn- parse-map [scope form]
  (let [[submap more] (split-map-by-const form)]
    (if (seq more)
      (parse-form scope
             (reduce (fn [call elem] (list 'cleo.core/assoc call (first elem) (second elem)))
                     submap
                     more))
      (parse-const form))) )


(defn- parse-form
  ([scope form]
   (let [form (macroexpand form)]
     (cond
       (symbol? form) (parse-symbol scope form)
       (seq? form) (parse-seq scope form)
       (vector? form) (parse-vector scope form)
       (set? form) (parse-set scope form)
       (map? form) (parse-map scope form)
       :else (parse-const form)))))


(defn parse [form]
  (parse-form nil form))


(def translate-expr!)


(defn- intern [m val]
  (if (contains? m val)
    m
    (assoc m val (count m))))


(defn- intern-strict [m val]
  (intern m [(type val) val]))


(defn- get-index-strict [m val]
  (get m [(type val) val]))


(defn- conj-i16! [v n]
  (when (or (< n -32768)
            (< 32767 n))
    (fail "internal error: i16 out of range: " n))
  (-> v
      (conj! (bit-and n 0xff))
      (conj! (bit-and (bit-shift-right n 8) 0xff))))


(defn- assoc-i16! [v off n]
  (when (or (< n -32768)
            (< 32767 n))
    (fail "internal error: i16 out of range: " n))
  (-> v
      (assoc! off (bit-and n 0xff))
      (assoc! (inc off) (bit-and (bit-shift-right n 8) 0xff))))


(defn- conj-STL! [v n]
  (-> v
      (conj! vm/STL)
      (conj-i16! n)))


(defn- conj-u16! [v n]
  (when (or (< n 0)
            (< 65535 n))
    (fail "internal error: u16 out of range: " n))
  (-> v
      (conj! (bit-and n 0xff))
      (conj! (bit-and (bit-shift-right n 8) 0xff))))


(defn- assoc-u16! [v off n]
  (when (or (< n 0)
            (< 65535 n))
    (fail "internal error: u16 out of range: " n))
  (-> v
      (assoc! off (bit-and n 0xff))
      (assoc! (inc off) (bit-and (bit-shift-right n 8) 0xff))))


(defn- conj-LDC! [v n]
  (-> v
      (conj! vm/LDC)
      (conj-u16! n)))


(defn- translate-const! [{:keys [consts] :as body} val]
  (if val
    (let [consts (intern-strict consts val)]
      (assoc body
             :consts consts
             :bytecode (-> (:bytecode body) (conj-LDC! (get-index-strict consts val)))))
    (assoc body
           :bytecode (conj! (:bytecode body) vm/CNIL))))


(defn- serialize [m]
  (let [sm (loop [n (count m)
                  s (transient [])]
             (if (pos? n)
               (recur (dec n) (conj! s 0))
               s))]
    (persistent! (reduce (fn [s [val index]]
                           (assoc! s index val))
                         sm
                         m))))


(defn- serialize-strict [m]
  (mapv second (serialize m)))


(defn- translate-exprs! [body exprs]
  (reduce (fn [body expr]
            (-> body
                (assoc :bytecode (conj! (:bytecode body) vm/POP))
                (translate-expr! expr)))
          (translate-expr! body (first exprs))
          (next exprs)))


(defn- translate-do! [body {exprs :exprs}]
  (translate-exprs! body exprs))


(defn- maybe-resolve-var [name]
  (when-let [v (resolve name)]
    (let [vmeta (meta v)]
      (when (:macro vmeta)
        (fail "Can't take value of a macro: " v))
      (when (and (:private vmeta)
                 (not (identical? *ns* (:ns vmeta))))
        (fail "var: " name " is not public"))
      v)))


(defn- resolve-var [name]
  (or (maybe-resolve-var name)
      (fail "unable to resolve symbol: " name)))


(defn translate-var! [{:keys [vars consts] :as body} {name :name}]
  (let [v (resolve-var name)
        vmeta (meta v)]
    (if (:const vmeta)
      (let [consts (intern-strict consts @v)]
        (assoc body
               :consts consts
               :bytecode (-> body :bytecode (conj! vm/LDC) (conj-u16! (get-index-strict consts @v)))))
      (let [vars (intern vars v)
            opcode (if (:dynamic vmeta) vm/LDDV vm/LDV)]
        (assoc body
               :vars vars
               :bytecode (-> (:bytecode body) (conj! opcode) (conj-u16! (vars v))))))))


(defn translate-local-index! [{:keys [parent-locals parent-local-loads] {locals :locals} :scope :as body} index]
  (if (contains? parent-locals index)
    (-> body
        (update :parent-local-loads (fn [pll] (conj! pll {:offset (count (:bytecode body)), :index index})))
        (update :bytecode (fn [bc] (-> bc (conj-LDC! 0)))))
    (update body :bytecode (fn [bc] (-> bc (conj! vm/LDL) (conj-i16! (locals index)))))))


(defn translate-local! [body {index :index}]
  (translate-local-index! body index))

(defn inc-stack-depth [body]
  (update body :scope (fn [s] (update s :stack-depth inc))))


(defn- push-scope [{scope :scope :as body}]
  (assoc body :scope (assoc scope :prev scope)))


(defn- pop-scope [body]
  (assoc body :scope (-> body :scope :prev)))


(defn translate-call! [body {:keys [fn args]}]
  (when (< 255 (count args))
    (fail "Too many arguments: " (count args)))
  (let [apply? (and (= (:tag fn) :var)
                    (= (resolve (:name fn)) #'cleo.core/apply))
        arg-count (count args)
        fn (if apply? (first args) fn)
        args (if apply? (next args) args)
        opcode (if apply? vm/APPLY vm/CALL)
        body (push-scope body)
        body (translate-expr! body fn)
        body (inc-stack-depth body)
        body (reduce (fn [body arg] (-> body (translate-expr! arg) inc-stack-depth)) body args)
        body (pop-scope body)]
    (when (and apply?
               (< arg-count 2))
      (fail "Wrong number of args (" arg-count ") passed to cleo.core/apply"))
    (update body :bytecode (fn [bc]
                             (-> bc (conj! opcode) (conj! (if apply? (dec (count args)) (count args))))))))


(defn- add-tlocal [{{:keys [locals locals-size] :as scope} :scope :as body} index]
  (when (= locals-size 32768)
    (fail "Too many locals: " (inc locals-size)))
  [(assoc body
          :scope (assoc scope
                        :locals (assoc locals index locals-size)
                        :locals-size (inc locals-size))
          :locals-size (max (:locals-size body) (inc locals-size)))
   locals-size])


(defn- translate-binding! [body {:keys [index expr]}]
  (let [body (translate-expr! body expr)
        [body tindex] (add-tlocal body index)]
    (update body :bytecode (fn [bc] (-> bc (conj-STL! tindex))))))


(defn- translate-let! [body {:keys [locals exprs]}]
  (let [body (push-scope body)
        body (reduce translate-binding! body locals)
        body (translate-exprs! body exprs)
        body (pop-scope body)]
    body))


(defn- translate-loop! [body {:keys [locals exprs]}]
  (let [body (push-scope body)
        recur-local-index (-> body :scope :locals-size)
        body (reduce translate-binding! body locals)
        body (assoc body :scope (assoc (:scope body)
                                       :recur-offset (count (:bytecode body))
                                       :recur-local-index recur-local-index))
        body (translate-exprs! body exprs)
        body (pop-scope body)]
    body))


(defn- translate-throw! [body {expr :expr}]
  (let [body (translate-expr! body expr)]
    (assoc body
           :bytecode (conj! (:bytecode body) vm/THROW))))


(defn- translate-if! [body {:keys [cond then else]}]
  (let [body (translate-expr! body cond)
        bnil-off (count (:bytecode body))
        body (assoc body :bytecode (-> (:bytecode body) (conj! vm/BNIL) (conj-i16! 0)))
        body (translate-expr! body then)
        br-off (count (:bytecode body))
        body (assoc body :bytecode (-> (:bytecode body) (conj! vm/BR) (conj-i16! 0)))
        body (translate-expr! body else)
        bytecode (:bytecode body)
        body (assoc body
                    :bytecode (-> bytecode
                                  (assoc-i16! (inc bnil-off) (- br-off bnil-off))
                                  (assoc-i16! (inc br-off) (- (- (count bytecode) br-off) 3))))]
    body))


(defn- find-expr-type [expr]
  (if (= (:tag expr) :const)
    (type (:value expr))
    (:value-type expr)))


(defn- translate-dot! [body {:keys [expr member]}]
  (let [body (translate-expr! body expr)]
    (if-let [expr-type (find-expr-type expr)]
      (if-let [field-index (get-type-field-index expr-type member)]
        (assoc body :bytecode (-> (:bytecode body) (conj! vm/LDSF) (conj-u16! field-index)))
        (fail "Field: " member " not present in type: " expr-type))
      (let [body (translate-const! body member)
            body (assoc body :bytecode (conj! (:bytecode body) vm/LDDF))]
        body))))


(defn- translate-def! [body {:keys [meta name expr] :as def-expr}]
  (let [cur-ns-name (str (ns-name *ns*))
        sym-ns (namespace name)
        the-var (resolve name)]
    (when (and sym-ns
               (not= sym-ns cur-ns-name))
      (fail (if the-var "Can't create defs outside of current ns" "Can't refer to qualified var that doesn't exist")))
    (when (and the-var
               (not= (namespace (var-name the-var)) cur-ns-name))
      (fail (cleo.core/name name) " already refers to: " the-var " in namespace: " cur-ns-name))
    (let [meta (when meta
                 (eval meta))
          the-var (if the-var the-var (define-var (symbol cur-ns-name (str name)) meta))
          body (translate-const! body the-var)
          body (inc-stack-depth body)
          body (if (not= {} (get def-expr :expr {}))
                 (-> body
                     (translate-expr! expr)
                     (update :bytecode (fn [bc] (conj! bc vm/STVV))))
                 body)
          body (if meta
                 (-> body
                     (translate-const! meta)
                     (update :bytecode (fn [bc] (conj! bc vm/STVM))))
                 body)]
      body)))


(defn- translate-assign! [body {:keys [target arg]}]
  (let [the-var (resolve-var (:name target))]
    (-> body
        (translate-const! the-var)
        inc-stack-depth
        (translate-expr! arg)
        (update :bytecode (fn [bc] (conj! bc vm/STVB))))))


(defn- translate-reassign-locals! [body first-index n]
  (assoc body
         :bytecode (loop [i n
                          bytecode (:bytecode body)]
                     (if (pos? i)
                       (recur (dec i) (-> bytecode (conj-STL! (+ first-index (dec i)))))
                       bytecode))))


(defn- translate-recur! [body {args :args}]
  (let [body (reduce translate-expr! body args)
        recur-local-index (-> body :scope :recur-local-index)
        body (translate-reassign-locals! body recur-local-index (count args))
        br-off (count (:bytecode body))
        recur-off (-> body :scope :recur-offset)]
    (assoc body :bytecode (-> body :bytecode (conj! vm/BR) (conj-i16! (- (- recur-off br-off) 3))))))


(defn- translate-try-catch! [body {expr :expr {catch-expr :expr {catch-index :index} :local type :type} :catch}]
  (let [stack-size (-> body :scope :stack-depth)
        start-off (count (:bytecode body))
        body (translate-expr! body expr)
        body (push-scope body)
        [body tindex] (add-tlocal body catch-index)
        br-off (count (:bytecode body))
        body (assoc body :bytecode (-> body :bytecode (conj! vm/BR) (conj-i16! 0) (conj-STL! tindex)))
        body (translate-expr! body catch-expr)
        body (update body :bytecode (fn [bc] (assoc-i16! bc (inc br-off) (-> (count bc) (- br-off) (- 3)))))
        body (pop-scope body)
        body (update body :exception-table (fn [et]
                                             (conj! et {:start-offset start-off
                                                        :end-offset br-off
                                                        :handler-offset (+ br-off 3)
                                                        :stack-size stack-size
                                                        :type @(resolve type)})))]
    body))


(defn- translate-try-finally! [body {expr :expr finally-expr :finally}]
  (let [stack-size (-> body :scope :stack-depth)
        start-off (count (:bytecode body))
        body (translate-expr! body expr)
        body (push-scope body)
        body (inc-stack-depth body)
        end-off (count (:bytecode body))
        body (translate-expr! body finally-expr)
        body (update body :bytecode (fn [bc] (conj! bc vm/POP)))
        br-off (count (:bytecode body))
        body (update body :bytecode (fn [bc] (-> bc (conj! vm/BR) (conj-i16! 0))))
        body (inc-stack-depth body)
        body (translate-expr! body finally-expr)
        body (pop-scope body)
        body (update body :bytecode (fn [bc] (-> bc (conj! vm/POP) (conj! vm/THROW))))
        body (update body :bytecode (fn [bc] (assoc-i16! bc (inc br-off) (-> (count bc) (- br-off) (- 3)))))
        body (update body :exception-table (fn [et]
                                             (conj! et {:start-offset start-off
                                                        :end-offset end-off
                                                        :handler-offset (+ br-off 3)
                                                        :stack-size stack-size})))]
    body))


(defn- translate-try! [body expr]
  ((if (:catch expr) translate-try-catch! translate-try-finally!) body expr))


(def translate-fn)


(defn- translate-ifn! [body expr]
  (let [parent-locals (merge (or (:parent-locals body) {}) (-> body :scope :locals))
        tfn (translate-fn parent-locals expr)
        closed-parent-locals (-> tfn :closed-parent-locals)
        body (translate-const! body (serialize-fn tfn))
        body (reduce translate-local-index! body closed-parent-locals)]
    (if (empty? closed-parent-locals)
      body
      (update body :bytecode (fn [bc] (-> bc (conj! vm/IFN) (conj! (count closed-parent-locals))))))))


(defn- translate-expr! [body expr]
  (let [tag (:tag expr)]
    (cond (= tag :do) (translate-do! body expr)
          (= tag :var) (translate-var! body expr)
          (= tag :local) (translate-local! body expr)
          (= tag :call) (translate-call! body expr)
          (= tag :let) (translate-let! body expr)
          (= tag :loop) (translate-loop! body expr)
          (= tag :throw) (translate-throw! body expr)
          (= tag :if) (translate-if! body expr)
          (= tag :dot) (translate-dot! body expr)
          (= tag :def) (translate-def! body expr)
          (= tag :recur) (translate-recur! body expr)
          (= tag :try) (translate-try! body expr)
          (= tag :fn) (translate-ifn! body expr)
          (= tag :assign) (translate-assign! body expr)
          :else (translate-const! body (:value expr)))))


(defn- make-locals [name-index params]
  (loop [index (- (count params))
         params (seq params)
         locals (if name-index {name-index (dec index)} {})]
    (if params
      (recur (inc index) (next params) (assoc locals (:index (first params)) index))
      locals)))


(defn- dissoc-empty [m k]
  (if (empty? (get m k))
    (dissoc m k)
    m))


(defn- translate-body [parent-locals fn-name-index {:keys [expr params vararg]}]
  (when (< 32767 (count params))
    (fail "Too many params: " (count params)))
  (let [tbody {:arity (count params)
               :parent-locals parent-locals
               :parent-local-loads (transient [])
               :scope {:locals (make-locals fn-name-index params)
                       :locals-size 0
                       :recur-offset 0
                       :recur-local-index (- (count params))
                       :stack-depth 0}
               :locals-size 0
               :bytecode (transient [])
               :exception-table (transient [])}
        tbody (if vararg (assoc tbody :vararg :true) tbody)
        tbody (translate-expr! tbody expr)
        tbody (update tbody :bytecode persistent!)
        tbody (update tbody :exception-table persistent!)
        tbody (update tbody :consts serialize-strict)
        tbody (update tbody :parent-local-loads persistent!)
        tbody (update tbody :vars serialize)
        tbody (if (zero? (:locals-size tbody))
                (dissoc tbody :locals-size)
                tbody)
        tbody (dissoc tbody :scope :parent-locals)
        tbody (-> tbody
                  (dissoc-empty :consts)
                  (dissoc-empty :vars)
                  (dissoc-empty :exception-table)
                  (dissoc-empty :parent-local-loads))]
    tbody))


(defn conj-nils! [n v]
  (loop [n n
         v (transient v)]
    (if (not (pos? n))
      (persistent! v)
      (recur (dec n) (conj! v nil)))))


(defn init-loads [{:keys [consts parent-local-loads] :as body} closed-parent-locals]
  (let [const-base (count consts)]
    (-> body
        (update :consts (fn [c] (conj-nils! (count closed-parent-locals) (or c []))))
        (update :bytecode (fn [bc]
                            (persistent! (reduce (fn [bc {:keys [index offset]}]
                                                   (assoc-u16! bc (inc offset) (+ const-base (closed-parent-locals index))))
                                                 (transient bc)
                                                 parent-local-loads)))))))


(defn intern-parent-locals [bodies]
  (reduce (fn [pls b]
            (reduce intern pls (map :index (:parent-local-loads b))))
          {}
          bodies))


(defn translate-fn [parent-locals {:keys [name name-index bodies]}]
  (let [tbodies (mapv (fn [body] (translate-body parent-locals name-index body)) bodies)
        closed-parent-locals (intern-parent-locals tbodies)
        tbodies (if (empty? closed-parent-locals)
                  tbodies
                  (mapv (fn [b] (init-loads b closed-parent-locals)) tbodies))
        f {:bodies tbodies}
        f (if (empty? closed-parent-locals)
            f
            (assoc f :closed-parent-locals (serialize closed-parent-locals)))
        f (assoc f :name (or name (gensym "anonfn--")))]
    f))


(defn mapv-indexed [f coll]
  (loop [s (seq coll)
         i 0
         out (transient [])]
    (if s
      (recur (next s) (inc i) (conj! out (f i (first s))))
      (persistent! out))))


(defn transform-expr
  ([pred f expr]
   (transform-expr pred f expr []))
  ([pred f expr path]
   (if (pred expr path)
     (f expr path)
     (let [tag (:tag expr)
           maybe-update (fn [m k f] (if (contains? m k) (update m k f) m))
           transform-one (fn transform-one
                           ([expr path k]
                            (assoc expr k (transform-expr pred f (get expr k) (conj path k))))
                           ([expr k]
                            (transform-one expr path k)))
           transform-many (fn [expr k]
                            (assoc expr k (mapv-indexed (fn [i expr]
                                                          (transform-expr pred f expr (conj path k i)))
                                                        (get expr k))))
           maybe-transform-one (fn [expr k]
                                 (if (contains? expr k)
                                   (transform-one expr k)
                                   expr))
           transform-many-nested (fn [expr k0 k1]
                                   (assoc expr k0 (mapv-indexed (fn [i x]
                                                                  (transform-one x (conj path k0 i) k1))
                                                                (get expr k0))))]
       (cond (= tag :do) (transform-many expr :exprs)
             (= tag :call) (-> expr
                               (transform-one :fn)
                               (transform-many :args))
             (= tag :let) (-> expr
                              (transform-many-nested :locals :expr)
                              (transform-many :exprs))
             (= tag :loop) (-> expr
                               (transform-many-nested :locals :expr)
                               (transform-many :exprs))
             (= tag :throw) (transform-one expr :expr)
             (= tag :if) (-> expr
                             (transform-one :cond)
                             (transform-one :then)
                             (transform-one :else))
             (= tag :dot) (transform-one expr :expr)
             (= tag :def) (maybe-transform-one expr :expr)
             (= tag :recur) (transform-many expr :args)
             (= tag :try) (-> expr
                              (transform-one :expr)
                              (maybe-update :catch (fn [c] (transform-one c (conj path :catch) :expr)))
                              (maybe-transform-one :finally))
             (= tag :fn) (transform-many-nested expr :bodies :expr)
             :else expr)))))


(defn const-bytecode-fn [f]
  (and (= :var (:tag f))
       (let [v (resolve (:name f))]
         (and (:const (meta v))
              (identical? BytecodeFn (type @v))
              @v))))


(defn identity-call? [{f :fn args :args}]
  (and (= 1 (count args))
       (if-let [f (const-bytecode-fn f)]
         (= (get-bytecode-fn-body f 1) [vm/LDL 255 255]))))


(defn no-arg-returning-const? [{f :fn args :args}]
  (and (zero? (count args))
       (if-let [f (const-bytecode-fn f)]
         (= (get-bytecode-fn-body f 0) [vm/LDC 0 0]))))


(defn inline-identity-calls [ast]
  (transform-expr (fn [expr _]
                   (and (= (:tag expr) :call)
                        (identity-call? expr)))
                  (fn [call _] (-> call :args first))
                  ast))


(defn inline-no-arg-returning-const [ast]
  (transform-expr (fn [expr _]
                   (and (= (:tag expr) :call)
                        (no-arg-returning-const? expr)))
                  (fn [call _]
                    {:tag :const
                     :value (-> call :fn const-bytecode-fn (get-bytecode-fn-consts 0) first)})
                  ast))


(defn- check-resolve-var-expr [expr]
  (and (= (:tag expr) :var)
       (maybe-resolve-var (:name expr))))


(defn- type-expr? [expr]
  (when-let [v (check-resolve-var-expr expr)]
    (and (:const (meta v))
         (identical? (type @v) cleo.core/Type))))


(defn- type-or-protocol-expr? [expr]
  (when-let [v (check-resolve-var-expr expr)]
    (and (:const (meta v))
         (let [vtype (type @v)]
           (or (identical? vtype cleo.core/Type)
               (identical? vtype cleo.core/Protocol))))))


(defn- const-var? [expr]
  (when-let [v (check-resolve-var-expr expr)]
    (:const (meta v))))


(defn- type-cast-expr? [expr]
  (let [{tag :tag f :fn args :args} expr]
    (and (= tag :call)
         (identical? #'cleo.core/cast (check-resolve-var-expr f))
         (= (count args) 2)
         (or (type-or-protocol-expr? (first args))
             (fail "First argument to cast must be a type or a protocol"))
         (type-expr? (first args)))))


(defn- new-expr? [expr]
  (let [{tag :tag f :fn args :args} expr]
    (and (= tag :call)
         (identical? #'cleo.core/new (check-resolve-var-expr f))
         (< 1 (count args))
         (or (type-expr? (first args))
             (fail "First argument to new must be a type")))))


(defn- find-local-type [ast path index]
  (loop [path (pop path)]
    (when (seq path)
      (let [expr (reduce get ast path)]
        (if-let [local (and (= (get expr :tag) :let)
                            (some (fn [l]
                                    (and (= (:index l) index)
                                         l))
                                  (:locals expr)))]
          (:value-type local)
          (recur (pop path)))))))


(defn- annotate-const-cast-new [ast]
  (transform-expr (fn [expr _]
                    (or (const-var? expr)
                        (type-cast-expr? expr)
                        (new-expr? expr)))
                  (fn [expr _]
                    (assoc expr :value-type (if (const-var? expr)
                                              (-> expr :name resolve-var deref type)
                                              (-> expr :args first :name resolve-var deref))))
                  ast))


(defn- annotate-locals [ast]
  (let [let? (fn let? [{tag :tag}]
               (= tag :let))
        let-or-local? (fn let-or-local? [{tag :tag} _]
                        (or (= tag :let)
                            (= tag :local)))
        annotate (fn annotate [ll-expr _ local-types]
                   (cond
                     (let? ll-expr)
                     (let [[locals local-types] (reduce (fn [[locals local-types] {:keys [expr index] :as local-def}]
                                                          (let [expr (transform-expr let-or-local? (fn [expr _] (annotate expr _ local-types)) expr)
                                                                local-def (assoc local-def :expr expr)
                                                                local-def (if-let [etype (find-expr-type expr)]
                                                                            (assoc local-def :value-type etype)
                                                                            local-def)]
                                                            [(conj! locals local-def)
                                                             (assoc local-types index (:value-type local-def))]))
                                                        [(transient []) local-types]
                                                        (:locals ll-expr))
                           locals (persistent! locals)
                           ll-expr (assoc ll-expr :locals locals)
                           ll-expr (update ll-expr :exprs (fn [exprs]
                                                            (mapv (fn [expr]
                                                                    (transform-expr let-or-local? (fn [expr _] (annotate expr _ local-types)) expr))
                                                                  exprs)))]
                       (if-let [etype (find-expr-type (peek (:exprs ll-expr)))]
                         (assoc ll-expr :value-type etype)
                         ll-expr))
                     :local (if-let [ltype (get local-types (:index ll-expr))]
                              (assoc ll-expr :value-type ltype)
                              ll-expr)))]
    (transform-expr let-or-local? (fn [expr _] (annotate expr _ {})) ast)))


(defn compute-types [ast]
  (-> ast
      annotate-const-cast-new
      annotate-locals))


(defn optimize [ast]
  (-> ast
      compute-types
      inline-identity-calls
      inline-no-arg-returning-const))


(defn translate [ast]
  (let [ast (if (not= :fn (:tag ast))
              {:tag :fn
               :bodies [{:params [], :expr ast}]}
              ast)]
    (translate-fn nil ast)))


(defn- fn-wrap [expr]
  {:tag :fn
   :bodies [{:params []
             :expr expr}]})


(defn eval [form]
  (let [form (macroexpand form)]
    (if (and (seq? form) (= (first form) 'do))
      (reduce (fn [_ expr] (eval expr)) nil (next form))
      ((->> form
            parse
            fn-wrap
            optimize
            translate
            serialize-fn)))))
