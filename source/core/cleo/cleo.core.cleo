(ns cleo.core)


(def reduce1
  (fn* reduce1 [f val coll]
    (let* [s (seq coll)]
      (if s
        (recur f (f val (first s)) (next s))
        val))))


(def reverse1
  (fn* reverse1 [xs]
    (reduce1 conj* () xs)))


(def map1
  (fn* map1 [f s]
    (reverse1 (reduce1 (fn* [out x] (conj* out (f x))) () s))))


(def nnext
  (fn* nnext [x] (next (next x))))


(def rest
  (fn* [coll]
    (let* [n (next coll)]
      (if n n ()))))

(def prepend*
  (fn* prepend* [p b]
    (conj* (rest b) (apply* vector (concati p (first b))))))

(def wrapdo*
  (fn* wrapdo* [body eparams]
    (prepend*
      eparams
      (if (next body)
        (if (nnext body)
          (list (first body) (conj* (next body) 'do))
          body)
        (list (first body))))))


(def {:macro :true} defmacro
  (fn* defmacro [&form &env name & decl]
    (list 'def {:macro :true} name (if (vector? (first decl))
                      `(fn* ~name ~@(wrapdo* decl '[&form &env]))
                      `(fn* ~name ~@(map1 (fn* [d] (wrapdo* d '[&form &env])) decl))))))


(defmacro fn [& decl]
  (let* [name (if (symbol? (first decl)) [(first decl)] [])
         decl (if (symbol? (first decl)) (next decl) decl)]
    (if (vector? (first decl))
      `(fn* ~@name ~@(wrapdo* decl []))
      `(fn* ~@name ~@(map1 (fn* [d] (wrapdo* d [])) decl)))))


(defmacro defn [name & decl] (list 'def name `(fn ~name ~@decl)))


(defmacro not [x] `(if ~x nil :true))


(defmacro or
  ([] nil)
  ([x] x)
  ([x & xs] `(let* [x# ~x] (if x# x# (or ~@xs)))))


(defmacro and
  ([] :true)
  ([x] x)
  ([x & xs] `(let* [x# ~x] (if x# (and ~@xs) x#))))


(defn seq? [x] (isa? (type x) cleo.core/Sequence))


(defn second [x] (first (next x)))


(defmacro lazy-seq [& body] `(lazy-seq* (fn* [] (do ~@body))))


(defmacro when [expr & body]
  `(if ~expr (do ~@body)))


(defn every? [pred coll]
  (let* [s (seq coll)]
    (if s
      (when (pred (first s))
        (recur pred (next s)))
      :true)))


(defmacro cond [& pairs]
  (when pairs
    (if (not (next pairs))
      (throw (new IllegalArgument  "cond requires an even number of forms"))
      `(if ~(first pairs) ~(second pairs) (cond ~@(nnext pairs))))))


(defn partition-kv [coll]
  (let* [s (seq coll)]
    (if s
      (let* [n (next s)]
        (if n
          (conj* (partition-kv (next n)) [(first s) (first n)])
          ()))
      ())))


(defn conj
  ([] [])
  ([coll] coll)
  ([coll x] (conj* coll x))
  ([coll x & xs]
    (if xs
      (recur (conj* coll x) (first xs) (next xs))
      (conj* coll x))))


(defn dec [x] (- x 1))
(defn inc [x] (+ x 1))
(defn zero? [x] (= 0 x))
(defn pos? [x] (< 0 x))
(defn neg? [x] (< x 0))
(defn int? [x] (identical? (type x) Int64))
(defn even? [x] (zero? (bit-and* x 1)))
(defn odd? [x] (not (even? x)))


(defn assoc
  ([m k v] (assoc* m k v))
  ([m k v & kvs]
    (let* [m (assoc* m k v)]
      (if kvs
        (if (next kvs)
          (recur m (first kvs) (second kvs) (nnext kvs))
          (throw (new IllegalArgument "assoc expects even number of arguments")))
        m))))


(defn dissoc
  ([m] m)
  ([m k] (dissoc* m k))
  ([m k & ks]
   (let* [m (dissoc* m k)]
     (if ks
       (recur m (first ks) (next ks))
       m))))


(defn destructure [bindings]
  (let* [pairs (partition-kv bindings)
         destructure-binding
         (fn* destructure-binding [out b v]
           (let* [destructure-vector
                  (fn* [out b v]
                    (let* [vsym (gensym "val__")
                           ssym (gensym "seq__")
                           out (conj out vsym v ssym `(seq ~vsym))]
                      (loop* [out out
                              s (seq b)
                              expect-as? nil]
                             (if s
                               (cond
                                 (= '& (first s)) (recur (conj out (second s) ssym)
                                                         (nnext s)
                                                         :true)
                                 (= :as (first s)) (destructure-binding out (second s) vsym)
                                 :else (if expect-as?
                                         (throw (new IllegalArgument "Unsupported binding form, only :as can follow & parameter"))
                                         (recur (conj (destructure-binding out (first s) `(first ~ssym)) ssym `(next ~ssym))
                                                (next s)
                                                nil)))
                               out))))
                  destructure-map
                  (fn* [out b v]
                    (let* [vsym (gensym "val__")
                           out (conj out vsym v)
                           defaults (b :or)
                           all (b :as)
                           destructure-locals
                           (fn [out key-fn locals]
                             (reduce1 (fn* [out sym] (conj out sym `(get ~vsym ~(key-fn sym) ~(get defaults sym))))
                                      out
                                      locals))
                           out (if all (conj out all vsym) out)
                           out (destructure-locals out keyword (b :keys))
                           out (destructure-locals out (fn* [sym] (list 'quote sym)) (b :syms))
                           out (destructure-locals out name (b :strs))
                           b (dissoc b :or :as :keys :syms :strs)]
                      (reduce1 (fn* [out bk]
                                 (destructure-binding out
                                                      (first bk)
                                                      `(get ~vsym ~(second bk) ~(get defaults (first bk)))))
                               out
                               b)))]
             (cond
               (vector? b) (destructure-vector out b v)
               (map? b) (destructure-map out b v)
               (symbol? b) (conj out b v)
               :else (throw (new IllegalArgument (str "Unsupported binding form: " b))))))
         destructure-binding-pair (fn* [out bv] (destructure-binding out (first bv) (second bv)))]
    (reduce1 destructure-binding-pair [] pairs)))


(defmacro let [bindings & body]
  `(let* ~(destructure bindings) ~(if (next body)
                                    (conj* body 'do)
                                    (first body))))


(defn interleave2 [coll1 coll2]
  (loop* [s1 (seq coll1) s2 (seq coll2) out []]
    (if s1
      (recur (next s1) (next s2) (conj out (first s1) (first s2)))
      out)))

(defn pairs1 [coll1 coll2]
  (loop* [s1 (seq coll1) s2 (seq coll2) out []]
    (if s1
      (recur (next s1) (next s2) (conj out [(first s1) (first s2)]))
      out)))


(defmacro loop [bindings & body]
  (let [bvs (partition-kv bindings)
        bs (map1 first bvs)]
    (if (every? symbol? bs)
      `(loop* ~bindings ~(if (next body)
                           (conj* body 'do)
                           (first body)))
      (let [ls (map1 (fn* [p] (if (symbol? p) p (gensym "l__"))) bs)
            lvbls (reduce1 (fn* [out bvl]
                             (let [[[b v] l] bvl]
                               (if (symbol? b)
                                 (conj out b v)
                                 (conj out l v b l))))
                           []
                           (pairs1 bvs ls))]
        `(let ~lvbls
           (loop* ~(interleave2 ls ls)
             (let ~(interleave2 bs ls) ~@body)))))))


(defn destructure-fn [body]
  (let* [params (first body)]
    (if (every? symbol? params)
      body
      (loop* [s (seq params)
              dparams []
              locals []]
        (if s
          (let* [p (gensym "p__")]
            (recur (next s) (conj dparams p) (conj locals (first s) p)))
          `(~dparams (let ~locals ~@(next body))))))))


(def wrapdo*
  (fn* wrapdo* [body eparams]
    (destructure-fn
      (prepend*
        eparams
        (if (next body)
          (if (nnext body)
            (list (first body) (conj* (next body) 'do))
            body)
          (list (first body)))))))


(defn bit-and
  ([x y] (bit-and* x y))
  ([x y & more]
    (let [val (bit-and* x y)]
      (if more
        (recur val (first more) (next more))
        val))))


(defn bit-or
  ([x y] (bit-or* x y))
  ([x y & more]
    (let [val (bit-or* x y)]
      (if more
        (recur val (first more) (next more))
        val))))


(defn bit-xor
  ([x y] (bit-xor* x y))
  ([x y & more]
    (let [val (bit-xor* x y)]
      (if more
        (recur val (first more) (next more))
        val))))


(defn bit-and-not
  ([x y] (bit-and-not* x y))
  ([x y & more]
    (let [val (bit-and-not* x y)]
      (if more
        (recur val (first more) (next more))
        val))))


(defmacro when-let [bindings & body]
  `(let [val# ~(bindings 1)]
     (if val#
       (let [~(bindings 0) val#] ~@body))))


(defmacro if-let
  ([bindings then] `(if-let ~bindings ~then nil))
  ([bindings then else]
    `(let [val# ~(bindings 1)]
       (if val#
         (let [~(bindings 0) val#] ~then)
         ~else))))


(defn some [pred coll]
  (when-let [s (seq coll)]
    (or (pred (first s))
        (recur pred (next s)))))


(defn vec [x]
  (if (vector? x)
    x
    (reduce1 conj [] x)))


(defmacro dotimes [bindings & body]
  (let [[b n] bindings]
    `(let* [n# ~n]
       (loop* [~b 0]
         (if (< ~b n#)
           (do
             ~@body
             (recur (inc ~b))))))))


(defmacro doseq [bindings & body]
  (let [[b s] bindings]
    `(loop* [s# (seq ~s)]
       (if s#
         (let [~b (first s#)]
           ~@body
           (recur (next s#)))))))


(defn map [f coll]
  (lazy-seq
    (when-let [s (seq coll)]
      (cons (f (first s)) (map f (next s))))))


(defn filter [pred coll]
  (lazy-seq
    (when-let [s (seq coll)]
      (let [v (first s)
            n (next s)]
        (if (pred v)
          (cons v (filter pred n))
          (filter pred n))))))


(defmacro ns [name & references]
  (let [gen-reference
        (fn [[kind & args]]
          `(~(symbol "cleo.core" (cleo.core/name kind)) ~@(map (fn [arg] `'~arg) args)))]
    `(do
       (cleo.core/in-ns '~name)
       (cleo.core/refer '~'cleo.core)
       ~@(map gen-reference references))))
